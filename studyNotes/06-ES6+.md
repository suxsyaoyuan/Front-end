# ECMAScript6+

# d1. 简介

ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。

1994 年后该组织改名为Ecma 国际。

ECMAScript 是由 Ecma 国际通过ECMA-262 标准化的脚本程序设计语言。

es6转义es5——Babel

# d2. let和const关键字

#### A.let 

var存在变量提升的问题。

ES6 新增了let命令，用来***\*声明变量\****。

使用 let 声明的变量有几个特点：

- 不存在变量提升
- 块级作用域，let声明的变量只在它所在的代码块有效，for循环中使用var会存在用来计数的循环变量泄露为全局变量的问题，使用let每一次循环的i都是一个新的变量。
- 不允许重复声明
- 不影响作用域链
- 不污染全局变量

应用场景：以后声明变量使用let 就对了。

#### B. const

const 关键字用来***\*声明常量\****，const 声明有以下特点：

- 值不允许修改
- 不存在变量提升
- 只在声明所在的块级作用域内有效
- 声明必须赋初始值
- 标识符一般为大写
- 不允许重复声明

注意：对象属性修改和数组元素变化不会出发 const 错误

应用场景：声明对象类型使用 const，非对象类型声明选择 let

#### C. ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。

所以，ES6 一共有 6 种声明变量的方法。

ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

# **d2.  模板字符串**

模板字符串（template string）是增强版的字符串，用***\*反引号 `\**** 标识，它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

特点：

- 字符串中可以出现换行符
- 可以使用 ${xxx} 形式输出变量

```javascript
<script>
let name = 'jack';
console.log(`hello, ${name}`);
</script>
```

应用场景：当遇到字符串与变量拼接的情况使用模板字符串。

# **d3.  函数的扩展**

#### A. 函数参数的默认值

ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

ES6 允许给函数参数设置默认值，即直接写在参数定义的后面。当调用函数时不给实参，则使用参数默认值。

arguments：在function中使用，装有所有实参的伪数组，可以索引，可取长度，但是没有数组的push等方法

参数变量是默认声明的，所以不能用let或const再次声明。

参数默认值不是传值的，而是每次都重新计算默认值表达式的值。

#### B. 剩余参数

ES6 引入 rest 参数（形式为***\*...变量名\****），用于获取函数的多余参数，这样就不需要使用arguments对象了。

rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.from先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。

#### C. spread运算符

剩余运算符：把多个独立的合并到一个数组中，放在函数的形参上。

扩展运算符：将一个数组分割，并将各个项作为分离的参数传给函数。

扩展运算符也可以将对象解包。

处理数组中的最大值：`Math.max(...arr)`

应用：展开数组、数组合并、数组克隆、将伪数组转换为真实数组、将伪数组转换为真实数组。

#### D.  箭头函数

ES6 使用***\*「箭头」=>\**** 定义函数，function(){} 等于 ()=>{}。

- 如果形参只有一个，则小括号可以省略。
- 函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果。

```js
let add = val => val;
let add = val => (val + 5);
let add = (val1, val2) => (val1 + val2);
```

- 箭头函数没有this的指向，箭头函数内部的 this 始终指向声明时所在作用域下 this 的值，一旦使用箭头函数，就不存在当前作用域，内部的this就是定义时上层作用域中的this。
- 使用箭头函数，函数内部没有 arguments。
- 箭头函数不能使用new关键字来实例化对象。
- function函数是一个对象，但是箭头函数不是一个对象，它是一个语法糖、表达式。
- 箭头函数可以与变量解构结合使用。

#### E. 指数运算符

​	在 ES7 中引入指数运算符` **`，用来实现幂运算，功能与` Math.pow(a, b) `结果相同。

```js
2 ** 3   // 8
Math.pow(2, 3)   // 8
```



# **d4.**  **解构赋值**

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构赋值。

针对数据和对象来进行操作

取属性的时候不用一个个取了

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

#### A. 对象的解构赋值

```js
//完全解构
let node = {
type: 'iden',
name: 'foo'
}
let { type, name } = node;
console.log(type, name)       //iden foo
//不完全解构，可以忽略某些属性\****
let obj = {
a: {
name: '张三'
},
b: [],
 c: 'hello world'

}
let { a } = obj;
//剩余运算符，将其他剩余的属性展开到一个对象中存储\****
let { a, ...res } = obj;
console.log(a, res);
//默认值

let { a, b = 30 } = { a: 20 };\****
```

#### B. 数组的解构赋值

```js
const arr = ['red', 'green', 'blue'];
let [r, g, b] = arr;  //red green blue
//可嵌套
let [a, [b], c] = [1, [2], 3];
```

# **d5.  对象的扩展**

ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。

```js
const name = '张三';
const age = 19;
const person = {
name, //等同于name:name
age,
// 方法也可以简写
sayName() {
console.log(this.name);
}
}
person.sayName();
```

### A. Object.is()

is()  和 ===：比较两个值是否严格相等

Object.is() 方法判断两个值是否为同一个值。如果满足以下条件则两个值相等：

- 都是 undefined
- 都是 null
- 都是 true 或 false
- 都是相同长度的字符串且相同字符按相同顺序排列
- 都是相同对象（意味着每个对象有同一个引用）
- 都是数字且都是 +0、都是 -0、都是 NaN、或都是非零而且非 NaN 且为同一个值

> 不同于相等运算符（==）：==会自动转换数据类型
>
> 不同于严格相等运算符（===）：===NaN不等于自身，以及+0等于-0

```js
console.log(NaN === NaN);      // false

console.log(Obejct.is(NaN, NaN));   // true 
```

### B. Object.assign()

对象合并

Object.assign(target, obj1, obj2...)，将原对象（obj1、obj2、）的所有属性，复制到目标对象（target）。

```js
//返回合并后的新对象
let newObj = Object.assign({}, { a: 1 }, { b: 2 });
console.log(newObj);   // {a: 1, b: 2}
//相当于浅拷贝
```

### C. Object.fromEntries

`Object.fromEntries() ` 方法把可迭代对象的键值对列表转换为一个对象。

```JS
语法：Object.fromEntries(iterable)
//iterable：类似 Array 、 Map 或者其它实现了可迭代协议的可迭代对象。
//返回值：一个由该迭代对象条目提供对应属性的新对象。
```

相当于 Object.entries （ES8）的逆运算。

### D. Object.entries

`Object.entries()`方法返回一个给定对象自身可遍历属性`[key,value]`的数组（数组元素也是一个个的数组的数组）.

```js
const obj = {a: 1, b: 2, c: 3};
console.log(Object.entries(obj))
// [ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]
//返回的是一个数组，这样就可以使用`for...of` 遍历了。
const obj = { a: 1, b: 2, c: 3 };
for (let [k, v] of Object.entries(obj)) {
  console.log(k, v)
}
```

### E. Object.values 

`Object.values()` 方法返回一个给定对象的所有可枚举属性值的数组，类似于`Object.keys()`，只是前者返回属性值，后者返回键值组合的数组。

```js
let obj = {
  a: 1,
  b: {1:2},
  c: [1,2,3]
}
console.log(Object.values(obj))
// [1, {1: 2}, [1,2,3]]
console.log(Object.keys(obj))
// ['a', 'b', 'c']Copy to clipboardErrorCopied
```

### F. trimStart() & trimEnd()

`trimStart() ` 去除字符串开头连续的空格（trimLeft 是此方法的别名）

`trimEnd() ` 去除字符串末尾连续的空格（trimRight 是此方法的别名）

# d6. *Symbol类型*

原始数据类型Symbol，它表示的是独一无二的值。

```js
const name = Symbol('name');
```

最大的用途：用来定义对象的私有变量

如果用 Symbol 定义的是对象中的变量，取值时一定要用 [变量名] 

如果用 Symbol 定义的是对象中的变量，该变量不能作为key，无法用 for 循环遍历

```js
//获取symbol声明的属性值：
let s = Obejct.getOwnpropertySymbols(Obj);
let m = Reflect.ownKeys(obj); `
```

```js
//使用 Symbol() 创建的 Symbol 字面量，可以直接使用 description 获取该字面量的描述。
Symbol.prototype.description
```

# **d7.  Map和Set**

### A. Set集合

Set集合：表示无重复值的有序列表。

- 添加元素：`set.add(2);`
- 添加字符串：`set.add('4');`
- 删除元素：`set.delete(2);`
- 校验某个值是否在 set 中：`set.has('4');`
- 访问集合的长度：`set.size);`
- 遍历集合：`set.forEach((val, key)) => {}` ：set函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。

```JS
//set 转换成 数组（使用扩展运算符）：
let set2 = new Set([1, 2, 3, 3 , 3 ,4]); //集合1234
let arr = [...set2]; //数组
//Set中对象的引用无法被释放
```

Weakset：

- 不能传入非对象类型的参数
- 不可迭代
- 没有size属性

### B. Map

Map是键值对的有序列表，键和值是任意类型。

map返回的是处理后的数组

- set() 设置值：`map.set('name', '张三');`
- get() 获取值：`console.log(map.get('name'));`
- has()  校验某个值是否在 map 中：

```
console.log(map.has('name'));
```

- delete()  删除值：`map.delete('name');`
- clear()  清除所有值：`map.clear();`

# **d8.**  **数组的扩展**

#### A.  Array.from()

```js
// 将伪数组转为真正的数组
let arr2 = Array.from(argumets);
let arr2 = [].slice.call(argumets);  //es5`
let lis = document.querySelectorAll('li');  
// querySelectorAll()方法返回的是一个类似数组的对象
let names2 = Array.from(lis, ele => ele.textContent);  
// Array.from()方法还可以接受第二个参数，对每个元素进行处理
console.log(names2);
//将伪数组转为真正的数组还可以使用扩展运算符
let lis = document.querySelectorAll('li');
console.log([...lis]);
```

#### B.  Array.of()

将一组值（任意数据类型），转换为数组

```js
console.log(Array.of(3, 11, 20, [1, 2, 3], { id: 1 }));
```

#### C.  CopyWithin

在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

```js
copyWithin(target,  start = 0,  end = this.length);
//target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
//start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
//end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
//这三个参数都应该是数值，如果不是，会自动转为数值。
[1, 2, 3, 8, 9, 10].copyWithin(0, 3);   // [8, 9, 10, 8, 9, 10];
```

#### D.  find()和findIndex()

`find() `方法：找出第一个符合条件的数组成员，它的参数是一个回调函数。

`findIndex() `方法：找出第一个符合条件的数组成员的索引。

```js
let num = [1, 4, -5, 10, -4].find(n => n < 0);
console.log(num);       // -5
let numIdex = [1, 4, -5, 10, -4].findIndex(n => n < 0);
console.log(numIdex);     // 2
```

#### E. entries()，keys()和values()

`entries()，keys()和values()`——用于遍历数组

它们都返回一个遍历器对象，可以用`for...of`循环进行遍历，唯一的区别是：

keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

```js
for (let index of ['a', 'b'].keys()) {
console.log(index);
}// 0 1

for (let elem of ['a', 'b'].values()) {
console.log(elem);
}// 'a' 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
console.log(index, elem);
}// 0 "a" 1 "b"
```

#### F. includes()

返回一个布尔值，表示某个数组***\*是否包含给定的值\****

```js
console.log([1, 2, 3].includes(2));   // true
console.log([1, 2, 3].includes(4));   // false
```

注意：以前的 indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，返回值是1或-1，所以要去比较是否不等于-1，表达起来不够直观。

#### G. Array.prototype.flat

Array.prototype.flat(i)：展平一个多维数，i 为要展开的层数，默认为1，即展开一层。

```js
//使用 Infinity 作为深度，展开任意深度的嵌套数组
[1, [2, 3, [4, 5]]].flat(Infinity)// [1, 2, 3, 4, 5, 6]
//也可以使用 flat 来去除数组空项
let arr = [1,2,3,,4]
arr.flat() // [1,2,3,4]
//Array.prototype.flatMap：相当于 map 和 flat 的结合，方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。

let arr = [1,2,3,4]
let res1 = arr.map(x => [x ** 2])
console.log(res1)
// [[1],[4],[9],[16]]

let res2 = arr.flatMap(x => [x ** 2])
console.log(res2)
// [1,4,9,16]
```

```js
map()
    - 可以根据原有数组返回一个新数组
    - 需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素
    - 回调函数中有三个参数：
        第一个参数：当前元素
        第二个参数：当前元素的索引
        第三个参数：当前数组

filter()
    - 可以从一个数组中获得符和条件的元素
    - 会根据回调函数的结果来决定是否保留元素，true保留，false不保留

find()
    - 可以从一个数组中获得符和条件的第一个元素

reduce()
    - 可以用来合并数组中的元素
    - 需要两个参数：
        回调函数（指定运算规则）
            四个参数：
                prev 上一次运算结果
                curr 当前值
                index 当前索引
                arr 当前数组
        初始值
            - 用来指定第一次运算时prev，如果不指定则直接从第二个元素开始计算
```

# **d9.**  **Iterator**

遍历器（Iterator）是一种新的遍历机制（接口)：为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作「for of循环」，依次处理该数据结构的所有成员，特点：

 *   拥有next方法：用于依次遍历数据结构的成员
 *   每一次遍历返回的结果是一个对象 {done:false,value:xxx}
     *   done:记录是否遍历完成
     *   value:当前遍历的结果

Iterator 的作用有三个：

- 一是为各种数据结构，提供一个统一的、简便的访问接口；
- 二是使得数据结构的成员能够按某种次序排列；
- 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。

拥有Symbol.iterator属性的数据结构（值），被称为可被遍历的，可以基于for of循环处理：
 *   数组 Array
 *   部分类数组：arguments对象 /NodeList对象 /HTMLCollection...
 *   String
 *   Set
 *   Map
 *   TypedArray
 *   generator object
 *   ...

> 对象默认不具备Symbol.iterator，属于不可被遍历的数据结构。

**Iterator 的遍历过程是这样的：**创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。不断调用指针对象的next方法，直到它指向数据结构的结束位置。

```js
let items = ['one', 'two', 'three'];
//创建一个遍历器
let ite = items[Symbol.iterator]();

//每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
console.log(ite.next()) // { value: 'one', done: false }
console.log(ite.next()) // { value: 'two', done: false }
console.log(ite.next()) // { value: 'three', done: false }
console.log(ite.next()) // { value: undefined, done: true }
```

**核心：**

1、迭代器是一个接口，能快捷访问数据，通过symbol.iterator来创建迭代器。

2、迭代器是用于遍历数据结构的指针

```js
class Iterator {
    constructor(assemble) {
        let self = this;
        self.assemble = assemble;
        self.index = 0;
    }
    next() {
        let self = this,
            assemble = self.assemble;
        if (self.index > assemble.length - 1) {
            return {
                done: true,
                value: undefined
            };
        }
        return {
            done: false,
            value: assemble[self.index++]
        };
    }
}
let itor = new Iterator([10, 20, 30, 40]);
console.log(itor.next()); //->{value:10,done:false}
console.log(itor.next()); //->{value:20,done:false}
console.log(itor.next()); //->{value:30,done:false}
console.log(itor.next()); //->{value:40,done:false}
console.log(itor.next()); //->{value:undefined,done:true}
```

```js
// 让对象也具备迭代器规范
Object.prototype[Symbol.iterator] = function () {
    let assemble = this,
        keys = Object.keys(assemble)
            .concat(Object.getOwnPropertySymbols(assemble)),
        index = 0;
    return {
        next() {
            if (index > keys.length - 1) {
                return {
                    done: true,
                    value: undefined
                };
            }
            return {
                done: false,
                value: assemble[keys[index++]]
            };
        }
    };
};
let obj = {
    name: 'zhufeng',
    age: 12,
    teacher: 'team'
};
for (let value of obj) {
    console.log(value);
}

// 如果是类数组对象，可直接继承数组的Symbol.iterator「JQ也是如此」
let obj = {
    0: 10,
    1: 20,
    2: 30,
    length: 3
};
obj[Symbol.iterator] = Array.prototype[Symbol.iterator];
for (let value of obj) {
    console.log(value);
}
/*
数组迭代的方式：for、while、forEach/map等、for/in、for/of
for/of主要用于获取数据结构中每一项的值
*/
```

# d10.  **Generator**

### 01  语法

与形式上，Generator 函数是一个普通函数，但是有两个特征（区别）：

- 一是，function关键字与函数名之间有一个星号 * ；
- 二是，函数体内部使用yield表达式，让函数挂起。

Generator 函数是分段执行的，只有调用next方法才会遍历下一个内部状态。yield是暂停执行标志，next()是恢复执行。当 next() 传入参数时，该参数就会被当作上一个 yield 表达式的返回值。

```js
function* add() {
console.log('start');
// 这里的 x 不是 yield '2' 的返回值，它是下一个 next（）调用恢复执行时传入的参数值
let x = yield '2';         // yield 暂停执行标志
console.log('one:' + x);
let y = yield '3';         // yield 暂停执行标志
console.log('two:' + y);
return x + y;
}

// 返回一个遍历器对象
let fn = add()

// next() 恢复执行标志
console.log(fn.next());    // start    {value: '2', done: false}

// 当 next() 传入参数时，该参数就会被当作上一个 yield 表达式的返回值 ，即 x = 20, y = 30
console.log(fn.next(20));   // one:20   {value: '3', done: false}
console.log(fn.next(30));   // two:30   {value: '50', done: true}`
```

使用场景：为不具备 Iterator 接口的对象提供了遍历操作。

利用for...of循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口（不具备 Symbol.iterator方法），无法使用for...of循环，通过 Generator 函数为它加上这个接口，即将 Generator 函数加到对象的Symbol.iterator属性上面，就可以用了。

```js
function* objectEntries() {
let propKeys = Object.keys(this);
for (let propKey of propKeys) {
yield [propKey, this[propKey]];
}
}
let jane = { first: 'Jane', last: 'Doe' };
jane[Symbol.iterator] = objectEntries;
for (let [key, value] of jane) {
console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

### 02 应用

#### A 生成器函数的声明和调用

生成器函数是 ES6 提供的一种 **异步编程解决方案**，语法行为与传统函数完全不同。

- `*` 的位置没有限制
- 使用 `function * gen()` 和 `yield` 可以声明一个生成器函数。生成器函数返回的结果是迭代器对象，调用迭代器对象的 `next` 方法可以得到 `yield` 语句后的值。
- 每一个 `yield` 相当于函数的暂停标记，也可以认为是一个分隔符，每调用一次 `next()`，生成器函数就往下执行一段。
- `next` 方法可以传递实参，作为 `yield` 语句的返回值

例如以下生成器函数中，3 个 `yield` 语句将函数内部分成了 4 段。

```js
function* generator() {
    console.log('before 111'); // 生成器第 1 段
    yield 111;
    console.log('before 222'); // 生成器第 1 段
    yield 222;
    console.log('before 333'); // 生成器第 1 段
    yield 333;
    console.log('after 333'); // 生成器第 1 段
}
let iter = generator();
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
/*
before 111
{ value: 111, done: false }
before 222
{ value: 222, done: false }
before 333
{ value: 333, done: false }
after 333
{ value: undefined【没有return就是undefined】, done: true }
*/
```

#### B 生成器函数的参数传递

```js
/*
params：生成器函数接收的实参值，时生成器函数执行时传递的值
	fn(10,20,30)
	params:[10,20,30]
itor.next(N):每一次执行next方法，传递的值会作为上一个yield的返回值 [所以第一次执行 传递的值没用]	
*/
const fn = function* fn(...params){
    yield 100;
    yield 200;
}
let itor = fn(10,20,30)
console.log(itor.next(''));=>{value:100,done:false}
...
```

```js
function* generator(arg) {
    console.log(arg); // 生成器第 1 段
    let one = yield 111;
    console.log(one); // 生成器第 2 段
    let two = yield 222;
    console.log(two); // 生成器第 3 段
    let three = yield 333; 
    console.log(three); // 生成器第 4 段
}

let iter = generator('aaa'); // 传给生成器第 1 段
console.log(iter.next());
console.log(iter.next('bbb')); // 传给生成器第 2 段，作为这一段开始的 yield 语句返回值
console.log(iter.next('ccc')); // 传给生成器第 3 段，作为这一段开始的 yield 语句返回值
console.log(iter.next('ddd')); // 传给生成器第 4 段，作为这一段开始的 yield 语句返回值
/*
aaa
{ value: 111, done: false }
bbb
{ value: 222, done: false }
ccc
{ value: 333, done: false }
ddd
{ value: undefined, done: true }
*/
```

#### C 生成器函数案例

案例1：1s后输出111，2s后输出222，3s后输出333

- 传统方式：嵌套太多，代码复杂，产生 **回调地狱**。

  ```js
  setTimeout(() => {
      console.log(111);
      setTimeout(() => {
          console.log(222);
          setTimeout(() => {
              console.log(333);
          }, 3000);
      }, 2000);
  }, 1000);Copy to clipboardErrorCopied
  ```

- 生成器实现：结构简洁明了

  ```js
  function one() {
      setTimeout(() => {
          console.log(111);
          iter.next();
      }, 1000);
  }
  
  function two() {
      setTimeout(() => {
          console.log(222);
          iter.next();
      }, 2000);
  }
  
  function three() {
      setTimeout(() => {
          console.log(333);
      }, 3000);
  }
  
  function* generator() {
      yield one();
      yield two();
      yield three();
  }
  
  let iter = generator();
  iter.next();Copy to clipboardErrorCopied
  ```

案例2：生成器函数模拟每隔1s获取商品数据

```js
function getUsers() {
    setTimeout(() => {
        let data = '用户数据';
        iter.next(data); // 传参给生成器函数的第 2 段，后面类似
    }, 1000);
}

function getOrders() {
    setTimeout(() => {
        let data = '订单数据';
        iter.next(data);
    }, 1000);
}

function getGoods() {
    setTimeout(() => {
        let data = '商品数据';
        iter.next(data);
    }, 1000);
}

function* generator() {
    let users = yield getUsers();
    console.log(users);
    let orders = yield getOrders();
    console.log(orders);
    let goods = yield getGoods();
    console.log(goods);
}

let iter = generator();
iter.next();
```

# d11.  **Promise**

## 01 Promise 的定义和使用

`Promise` 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。

一个 `Promise` 必然处于以下几种状态之一：

- 待定（`pending`）：初始状态，既没有被兑现，也没有被拒绝。
- 已兑现（`fulfilled`）：意味着操作成功完成。
- 已拒绝（`rejected`）：意味着操作失败。

`Promise` 的使用：

- Promise 构造函数：`new Promise((resolve, reject)=>{})`
- `Promise.prototype.then` 方法
- `Promise.prototype.catch` 方法

一个简单案例：

```js
let p = new Promise(function (resolve, reject) {
    // 使用 setTimeout 模拟请求数据库数据操作
    setTimeout(function () {
        // 这个异步请求数据库数据操作是否正确返回数据
        let isRight = true;
        if (isRight) {
            let data = '数据库中的数据';
            // 设置 Promise 对象的状态为操作成功
            resolve(data);
        } else {
            let err = '数据读取失败！'
            // 设置 Promise 对象的状态为操作失败
            reject(err);
        }
    }, 1000);
});
p.then(function (value) {
    console.log(value);
}, function (reason) {
    console.error(reason);
})Copy to clipboardErrorCopied
```

## 02 Promise 封装读取文件

```js
// 使用 nodejs 的 fs 读取文件模块
const fs = require('fs');

const p = new Promise(function (resolve, reject) {
    fs.readFile('./resources/为学.txt', (err, data) => {
        // err 是一个异常对象
        if (err) reject(err);
        resolve(data);
    })
})

p.then(function (value) {
    // 转为字符串输出
    console.log(value.toString());
}, function (reason) {
    console.log('读取失败!!');
})Copy to clipboardErrorCopied
```

## 03 Promise 封装 Ajax 请求

```js
const p = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('get', 'https://api.apiopen.top/getJoke');
    xhr.send();
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            if (xhr.status >= 200 && xhr.status < 300) {
                // 成功
                resolve(xhr.response);
            } else {
                // 失败
                reject(xhr.status);
            }
        }
    }
});

// 指定回调
p.then(function (value) {
    console.log(value);
}, function (reason) {
    console.error(reason);
})
```

## 04 Promise.prototype.then 方法

先复习一下一个 `Promise` 的三种状态：

- 待定（`pending`）：初始状态，既没有被兑现，也没有被拒绝。
- 已兑现（`fulfilled`）：意味着操作成功完成。
- 已拒绝（`rejected`）：意味着操作失败。

`Promise.prototype.then` 方法返回的结果依然是 `Promise` 对象，**对象状态由回调函数的执行结果决定**。

具体情况如下：

- 若 then方法没有返回值，则then方法返回的对象的状态值为成功(fulfilled)，返回结果值为undefined。

  ```js
  const p = new Promise((resolve, reject) => {
      setTimeout(() => {
          // resolve('用户数据')
          reject('出错了');
      }, 1000);
  })
  // 未设定返回值
  const res = p.then((value) => {
      console.log(value);
  }, (reason) => {
      console.warn(reason);
  })
  // 打印 then 方法的返回值
  console.log(res);Copy to clipboardErrorCopied
  ```

  打印的结果：

   如果回调函数中返回的结果是非`Promise`类型的属性，则then方法返回的对象，其状态为成功（fulfilled），返回结果值取决于then方法所执行的是哪个函数（resolve或reject）。

  ```js
  const p = new Promise((resolve, reject) => {
      setTimeout(() => {
          // resolve('用户数据')
          reject('出错了');
      }, 1000);
  })
   // 返回的非 Promise 对象
  const res = p.then((value) => {
      console.log(value);
      return '成功了！！';
  }, (reason) => {
      console.warn(reason);
      return '出错啦！！'
  })
  // 打印 then 方法的返回值
  console.log(res);
  ```

  打印结果：如果回调函数中返回的结果是Promise类型（return new Promise()），则then方法返回的Promise对象状态与该返回结果的状态相同，返回值也相同。

  ```js
  const p = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('用户数据')
          // reject('出错了');
      }, 1000);
  })
  const res = p.then((value) => {
      console.log(value);
      // 返回 Promise 对象
      return new Promise((resolve, reject) => {
          resolve('（1）成功了！！！');
          // reject('（1）出错了！！！')
      })
  }, (reason) => {
      console.warn(reason);
      return new Promise((resolve, reject) => {
          // resolve('（2）成功了！！！');
          reject('（2）出错了！！！')
      })
  })
  // 打印 then 方法的返回值
  console.log(res);
  ```

  打印结果：如果回调函数中返回的结果是throw语句抛出异常，则then方法的对象的状态值为rejected，返回结果值为throw抛出的字面量或者Error对象。

  ```js
  const p = new Promise((resolve, reject) => {
      setTimeout(() => {
          resolve('用户数据');
      }, 1000);
  });
  const res = p.then((value) => {
      console.log(value);
      return new Promise((resolve, reject) => {
          throw new Error('错误了！！');
      })
  });
  // 打印结果
  console.log(res);
  ```

  打印结果如下：

**链式调用**

`Promise.prototype.then` 方法返回的结果还是 `Promise` 对象，这意味着我们可以继续在该结果上使用 `then` 方法，也就是链式调用。

```js
const p = new Promise(resolve=>{}, reject=>{});
p.then(value=>{}, reason=>{})
.then(value=>{}, reason=>{})
.then(value=>{}, reason=>{})
```

**链式调用练习-多个文件读取**

```js
const fs = require('fs');

let p = new Promise((resolve, reject) => {
    fs.readFile('./resources/users.md', (err, data) => {
        // 传给下一轮文件读取操作
        resolve(data);
    })
});

p.then(value => {
    return new Promise((resolve, reject) => {
        // value 为第一次读取的文件数据，data 为第二次（当前）读取的数据
        fs.readFile('./resources/orders.md', (err, data) => {
            // 将上轮读取结果和本轮合并传到下一轮轮读取操作
            resolve([value, data]);
        });
    });
}).then(value => {
    return new Promise((resolve, reject) => {
        fs.readFile('./resources/goods.md', (err, data) => {
            // value 为上一轮传递过来的文件数据数组
            value.push(data);
            // 传给下一轮操作
            resolve(value);
        });
    });
}).then(value => {
    // 合并数组元素，输出
    console.log(value.join('\n'));
});
```

## 05 Promise.prototype.catch

`catch()` 方法返回一个 `Promise`，并且处理拒绝的情况。它的行为与调用 `Promise.prototype.then(undefined, onRejected)` 相同。

即：

```js
obj.catch(onRejected);Copy to clipboardErrorCopied
```

等同于：

```js
obj.then(undefined, onRejected);Copy to clipboardErrorCopied
```

语法：

```js
p.catch(onRejected);

p.catch(function(reason) {
   // 拒绝
});
```

举例：

```js
var p1 = new Promise(function (resolve, reject) {
    resolve('Success');
});

p1.then(function (value) {
    console.log(value); // "Success!"
    throw 'oh, no!';
}).catch(function (e) {
    console.log(e); // "oh, no!"
}).then(function () {
    console.log('有 catch 捕获异常，所以这句输出');
}, function () {
    console.log('没有 catch 捕获异常，这句将不会输出');
});Copy to clipboardErrorCopied
```

输出结果：

```js
Success
oh, no!
// 有 catch 捕获异常，所以这句输出
```

> 以上只是 Promise 的入门，更多还要进一步深入学习。

##  06 静态方法

#### Promise.resolve()/reject()

```js
Promise.resolve() //创建一个立即完成的Promise
```

```js
Promise.reject() //创建一个立即拒绝的Promise 得用catch读
//与 Promise.resolve() 不同，Promise.reject() 无论接收什么类型的参数，都会原封不动的向后传递
```

#### Promise.all

Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。

```js
Promise.all([...]) 
Promise.all([p1, p2, p3])
// 同时返回多个Promise的执行结果
// 所有 Promise 都成功时才解决，返回成功结果数组
// 任意失败则整体失败
```

##### **基于promise.all实现ajax得到串行和并行**

串行：请求是异步的，需要等待上一个请求成功，才能执行下一个请求

并行：同时发送多个请求 [http请求可以同时进行 但是js操作是一步步的 单线程] 等待所有请求成功 再去做其他事情

##### **JS实现Ajax并发请求控制**

```js
// tasks：数组，数组包含很多方法，每一个方法执行就是发送一个请求
function createRequest(task,pool){
	pool = pool || 5
    let results = [],
        together = new Array(pool).fill(null),
        index = 0;
    // 每一个工作区也用promise管理
    together = together.map(() => {
        return new Promise((resolve,reject) => {
            const run = function run(){
                let old_index = index,
                    task = tasks[index++];
                task().then(result => {
                    results[ole_index] = result;
                    run()
                }).catch(reason => {
                    reject(reason);
                });
            }
        })
    })
    return Promise.all(together).then(() => results)
}

createRequest(tasks,2).then(results => {
    // 整体成功 按顺序存储结果
	}).catch(reason =>{
    // 只要有一个失败，整体都失败
});
```

```js
function createRequest(task,pool，callback){
	if(typeof pool === "function"){
        callback = pool;
        pool= 5;
    }
	if(typeof pool !== "function") pool= 5;
   	if(typeof callback !== "function") callback= function(){};
    
    class TaskQueue {
    	running = 0; // 当前运行的任务数
    	queue = []; // 任务队列
    	results = []; // 任务结果
        
      	pushTask(task) {
            let self = this;
        	self.queue.push(task); // 将任务添加到队列
        	self.next(); // 尝试执行下一个任务
      	}
      	next() {
        let self = this;
        // 当运行的任务少于并发限制且队列中有任务时
        while (self.running < self.pool && self.queue.length) {
          self.running++; // 增加运行的任务数
          // 从队列中取出第一个任务并执行
          let task = self.queue.shift();
          task().then(result => {
            self.results.push(result); // 将任务结果添加到结果数组
          }).catch(error => {
            self.results.push({ error }); // 处理任务失败的情况
          }).finally(() => {
            self.running--; // 任务完成后减少运行的任务数
            self.next(); // 尝试执行下一个任务
          });
        }
        if(self.running === 0) callback(self.results)
      }
    }
    let TQ = new TaskQueue;
	tasks.forEach(task =>TQ.pushTask(task));
}

createRequest(tasks,2,results => {
    // 成功几个保存几个
});
```

##### **promise.all并发限制及async-pool应用**

并发限制是指每时刻并发执行的promise数量是固定的（5-7个）

> SPA单页面应用 请求非常多 并发量太高 阻塞 导致网络请求失败

```js
Promise.all(tasks.map(task =>task())).then(results => {  
})
// 限制同时并发两个
let results = [];
asyncPool(2, tasks,(task,next) => {
    task().then(result => {
        results.push(result);
		next;
	}),
},()=>{

})
```

##### **重写promise.all**

创建一个数组来存储每个 Promise 的结果，使用一个计数器来跟踪已经解决的 Promise 数量，遍历传入的 Promise 数组，为每个 Promise 添加 then 和 catch 处理程序。如果所有 Promise 都解决了，返回一个包含所有结果的 Promise。如果任意一个 Promise 被拒绝，返回一个被拒绝的 Promise。

```js
function PromiseAll(promises) {
  return new Promise((resolve, reject) => {
    let resolvedCount = 0;
    const results = new Array(promises.length);

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          resolvedCount++;
          results[index] = value;
          if (resolvedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(error => {
          reject(error);
        });
    });
  });
}
```

#### Promise.allSettled()/race()/any()

```js
Promise.allSettled([...]) 
   {status: 'fulfilled', value: 579}
   {status: 'rejected', reason: '哈哈'}
// 同时返回多个Promise的执行结果(无论成功或失败)
// 等待所有 Promise 完成（无论成功或失败），返回每个 Promise 的结果对象数组。
```

```js
Promise.race([...]) 
// 返回最先完成的 Promise（不考虑对错）
```

```js
Promise.any([...]) 
// 返回最先成功的Promise
```

> `Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**Promise的执行原理**

Promise在执行，then就相当于给Promise了回调函数，当Promise的状态从pending 变为 fulfilled时，then的回调函数会被放入到任务队列中。

```js
// 开启了一个定时器
// 定时器的作用是间隔一段时间后，将函数放入到任务队列中
setTimeout(() => {
     console.log(1)
}, 0)
```

# d12.  async&awit

> async/await 是基于 Promise 的语法糖，让异步代码看起来更像同步代码。async 函数返回一个 Promise 对象，await 可以在 async 函数内部等待一个 Promise 完成。

### 01 `async`

#### A 基本用法

`async`函数返回一个 Promise 对象，可以使用`then`方法添加回调函数。当函数执行的时候，一旦遇到`await`就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

下面是一个例子。

```js
async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName('goog').then(function (result) {
  console.log(result);
});
```

上面代码是一个获取股票报价的函数，函数前面的`async`关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个`Promise`对象。

下面是另一个例子，指定多少毫秒后输出一个值。

```js
function timeout(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}

asyncPrint('hello world', 50);
```

上面代码指定 50 毫秒以后，输出`hello world`。

由于`async`函数返回的是 Promise 对象，可以作为`await`命令的参数。所以，上面的例子也可以写成下面的形式。

```js
async function timeout(ms) {
  await new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}

asyncPrint('hello world', 50);
```

async 函数有多种使用形式。

```js
// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// 箭头函数
const foo = async () => {};
```

#### B 语法

`async`函数的语法规则总体上比较简单，难点是错误处理机制。

`async`作用：使用异步操作更加方便

##### 1 返回 Promise 对象

`async`函数返回一个 Promise 对象。

`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数。

`async`是`generator`的一个语法糖

```js
async function test() {
}
let result = test()
console.log(result)  //即便代码里test函数什么都没返回，我们依然打出了Promise对象
```

```js
async function f() {
  return 'hello world';
}

f().then(v => console.log(v))
// "hello world"
```

上面代码中，函数`f`内部`return`命令返回的值，会被`then`方法回调函数接收到。

`async`函数内部抛出错误，会导致返回的 Promise 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到。

```js
async function f() {
  throw new Error('出错了');
}

f().then(
  v => console.log('resolve', v),
  e => console.log('reject', e)
)
//reject Error: 出错了
```

##### 2 Promise 对象的状态变化

`async`函数返回的 Promise 对象，必须等到内部所有`await`命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到`return`语句或者抛出错误。也就是说，只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。

下面是一个例子。

```js
async function getTitle(url) {
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/<title>([\s\S]+)<\/title>/i)[1];
}
getTitle('https://tc39.github.io/ecma262/').then(console.log)
// "ECMAScript 2017 Language Specification"
```

上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行`then`方法里面的`console.log`。

### 02 `await` 命令

正常情况下，`await`命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。

```js
async function f() {
  // 等同于
  // return 123;
  return await 123;
}

f().then(v => console.log(v))
// 123
```

上面代码中，`await`命令的参数是数值`123`，这时等同于`return 123`。

这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助`await`命令就可以让程序停顿指定的时间。下面给出了一个简化的`sleep`实现。

```js
function sleep(interval) {
  return new Promise(resolve => {
    setTimeout(resolve, interval);
  })
}

// 用法
async function one2FiveInAsync() {
  for(let i = 1; i <= 5; i++) {
    console.log(i);
    await sleep(1000);
  }
}

one2FiveInAsync();
```

`await` 必须在 `async `函数里使用，不能单独使用

`await `的作用之一就是获取后面 `Promise` 对象成功状态传递出来的参数传给 ` then ` 函数。

```js
async function f() {
    //如果 await 命令后面的不是一个Promise实例对象，await 命令会自动把await后面转为一个Promise实例对象
    return await 'hello async';
}
// 因为返回的是一个Promise实例对象，所以可以用链式编程 
f().then(v => {console.log(v)}).catch(e => {console.log(e)});      //输出 hello async
```

如果 async 函数中有多个 await , 那么 then 函数 会等待所有的 await 指令运行完才去执行

```js
async function f(){
    let s = await 'hello world'
    let data = await s.split('');
    return data;
}
f().then(v => {console.log(v)}).catch(e => {console.log(e)});   
```

`await`命令后面的 Promise 对象如果变为`reject`状态，则`reject`的参数会被`catch`方法的回调函数接收到。

```js
async function f() {
  await Promise.reject('出错了');
}

f()
.then(v => console.log(v))
.catch(e => console.log(e))
// 出错了
```

注意，上面代码中，`await`语句前面没有`return`，但是`reject`方法的参数依然传入了`catch`方法的回调函数。这里如果在`await`前面加上`return`，效果是一样的。

任何一个`await`语句后面的 Promise 对象变为`reject`状态，那么整个`async`函数都会中断执行。

```js
async function f() {
  await Promise.reject('出错了');
  await Promise.resolve('hello world'); // 不会执行
}
```

上面代码中，第二个`await`语句是不会执行的，因为第一个`await`语句状态变成了`reject`。

有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个`await`放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个`await`都会执行。

```js
async function f() {
  try {
    await Promise.reject('出错了');
  } catch(e) {
  }
  return await Promise.resolve('hello world');
}

f()
.then(v => console.log(v))
// hello world
```

另一种方法是`await`后面的 Promise 对象再跟一个`catch`方法，处理前面可能出现的错误。

```js
async function f() {
  await Promise.reject('出错了')
    .catch(e => console.log(e));
  return await Promise.resolve('hello world');
}

f()
.then(v => console.log(v))
// 出错了
// hello world
```

### 03 错误处理

如果`await`后面的异步操作出错，那么等同于`async`函数返回的 Promise 对象被`reject`。

```js
async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error('出错了');
  });
}

f()
.then(v => console.log(v))
.catch(e => console.log(e))
// Error：出错了
```

上面代码中，`async`函数`f`执行后，`await`后面的 Promise 对象会抛出一个错误对象，导致`catch`方法的回调函数被调用，它的参数就是抛出的错误对象。

防止出错的方法，也是将其放在`try...catch`代码块之中。

```js
async function f() {
  try {
    await new Promise(function (resolve, reject) {
      throw new Error('出错了');
    });
  } catch(e) {
  }
  return await('hello world');
}
```

如果有多个`await`命令，可以统一放在`try...catch`结构中。

```js
async function main() {
  try {
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);

    console.log('Final: ', val3);
  }
  catch (err) {
    console.error(err);
  }
}
```

下面的例子使用`try...catch`结构，实现多次重复尝试。

```js
const superagent = require('superagent');
const NUM_RETRIES = 3;

async function test() {
  let i;
  for (i = 0; i < NUM_RETRIES; ++i) {
    try {
      await superagent.get('http://google.com/this-throws-an-error');
      break;
    } catch(err) {}
  }
  console.log(i); // 3
}

test();
```

上面代码中，如果`await`操作成功，就会使用`break`语句退出循环；如果失败，会被`catch`语句捕捉，然后进入下一轮循环。

### 04 使用注意点

第一点，前面已经说过，`await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中。

```js
async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}

// 另一种写法

async function myFunction() {
  await somethingThatReturnsAPromise()
  .catch(function (err) {
    console.log(err);
  });
}
```

第二点，多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。

```js
let foo = await getFoo();
let bar = await getBar();
```

上面代码中，`getFoo`和`getBar`是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有`getFoo`完成以后，才会执行`getBar`，完全可以让它们同时触发。

```js
// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
```

上面两种写法，`getFoo`和`getBar`都是同时触发，这样就会缩短程序的执行时间。

第三点，`await`命令只能用在`async`函数之中，如果用在普通函数，就会报错。

```js
async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 报错
  docs.forEach(function (doc) {
    await db.post(doc);
  });
}
```

上面代码会报错，因为`await`用在普通函数之中了。但是，如果将`forEach`方法的参数改成`async`函数，也有问题。

```js
function dbFuc(db) { //这里不需要 async
  let docs = [{}, {}, {}];

  // 可能得到错误结果
  docs.forEach(async function (doc) {
    await db.post(doc);
  });
}
```

上面代码可能不会正常工作，原因是这时三个`db.post()`操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用`for`循环。

```js
async function dbFuc(db) {
  let docs = [{}, {}, {}];

  for (let doc of docs) {
    await db.post(doc);
  }
}
```

另一种方法是使用数组的`reduce()`方法。

```js
async function dbFuc(db) {
  let docs = [{}, {}, {}];

  await docs.reduce(async (_, doc) => {
    await _;
    await db.post(doc);
  }, undefined);
}
```

上面例子中，`reduce()`方法的第一个参数是`async`函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用`await`等待它操作结束。另外，`reduce()`方法返回的是`docs`数组最后一个成员的`async`函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上`await`。

上面的`reduce()`的参数函数里面没有`return`语句，原因是这个函数的主要目的是`db.post()`操作，不是返回值。而且`async`函数不管有没有`return`语句，总是返回一个 Promise 对象，所以这里的`return`是不必要的。

如果确实希望多个请求并发执行，可以使用`Promise.all`方法。当三个请求都会`resolved`时，下面两种写法效果相同。

```js
async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) => db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
}

// 或者使用下面的写法

async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) => db.post(doc));

  let results = [];
  for (let promise of promises) {
    results.push(await promise);
  }
  console.log(results);
}
```

第四点，async 函数可以保留运行堆栈。

```js
const a = () => {
  b().then(() => c());
};
```

上面代码中，函数`a`内部运行了一个异步任务`b()`。当`b()`运行的时候，函数`a()`不会中断，而是继续执行。等到`b()`运行结束，可能`a()`早就运行结束了，`b()`所在的上下文环境已经消失了。如果`b()`或`c()`报错，错误堆栈将不包括`a()`。

现在将这个例子改成`async`函数。

```
const a = async () => {
  await b();
  c();
};
```

上面代码中，`b()`运行的时候，`a()`是暂停执行，上下文环境都保存着。一旦`b()`或`c()`报错，错误堆栈将包括`a()`。

### 05 ES13新增

在 JavaScript 中，await 运算符用于暂停执行，直到 Promise 被解决（履行或拒绝）。

以前，我们只能在 async 函数中使用此运算符 - 使用 async 关键字声明的函数。

```js
function setTimeoutAsync(timeout) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
// SyntaxError: await is only valid in async functions
await setTimeoutAsync(3000);
```

使用 ES13，现在我们可以：

```js
function setTimeoutAsync(timeout) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
// Waits for timeout - no error thrown
await setTimeoutAsync(3000);
```

**generator、promise 、async：**

- 解决回调地狱
- 使得异步操作显得更加方便

### 06 综合应用-读取文件

需求：先读取用户数据 user，然后读取订单数据 order，最后读取商品数据 goods。

对于这种异步操作很容易想到使用 `Promise`，代码如下：

```js
const fs = require('fs')

let p = new Promise((resolve, reject) => {
  fs.readFile('./files/user.md', (err, data) => {
    if (err) reject(err)
    resolve(data)
  })
})

p.then(value => {
  return new Promise((resolve, rejecet) => {
    fs.readFile('./files/order.md', (err, data) => {
      if (err) rejecet(err)
      resolve([value, data])
    })
  })
}, reason => {
  console.log(reason)
}).then(value => {
  return new Promise((resolve, reject) => {
    fs.readFile('./files/goods.md', (err, data) => {
      if (err) reject(err)
      value.push(data)
      resolve(value)
    })
  })
}, reason => {
  console.log(reason)
}).then(value => {
  console.log(value.join('\n'))
}, reason => {
  console.log(reason)
})Copy to clipboardErrorCopied
```

但是，使用 `Promise` 链式调用虽然避免了回调地狱，但这种链式调用过多难免引起代码复杂，看起来不直观。可以使用 `async` 和 `await` 方法优化，代码如下：

```js
const fs = require('fs')

function readUser() {
  return new Promise((resolve, reject) => {
    fs.readFile('./files/user.md', (err, data) => {
      if (err) reject(err)
      resolve(data)
    })
  })
}

function readOrder() {
  return new Promise((resolve, reject) => {
    fs.readFile('./files/order.md', (err, data) => {
      if (err) reject(err)
      resolve(data)
    })
  })
}

function readGoods() {
  return new Promise((resolve, reject) => {
    fs.readFile('./files/goods.md', (err, data) => {
      if (err) reject(err)
      resolve(data)
    })
  })
}

async function read() {
  let user = await readUser()
  let order = await readOrder()
  let goods = await readGoods()
  console.log([user, order, goods].join('\n'))
}

read()
```

这样，代码看起来很直观，就好像是同步代码一样，实际上是异步操作。

### 07 综合应用-封装ajax

```js
function sendAjax(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.open('get', url)
    xhr.send()
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(JSON.parse(xhr.response))
        }
        reject(xhr.status)
      }
    }
  })
}

async function main() {
  let res = await sendAjax('http://poetry.apiopen.top/sentences')
  let poem = res.result.name + '——' + res.result.from
  document.body.innerText = poem
}

main()
```

这里封装的ajax还不能体现 `async-await` 的作用所在，因为没有出现多个 ajax 请求。在又多个 ajax 请求并且后续的请求依赖于前一个请求的结果的时候，`async-await` 的优点就体现出来了。



# d13.  **Class类**

- 类是对象的模板
- 类决定了一个对象中有哪些属性和方法
- 使用class关键字来定义一个类

#### A. 用法

```js
class Person {
// 实例化的时候会立即被调用
// 可以直接在类中定义属性
// name = '孙悟空';
// age = 18;
    
// 构造函数
// 当我们通过new创建对象时，实际上就是在调用类的构造函数
constructor(name, age) {
    // 将参数赋值给对象中的属性
    // 在构造函数中，可以通过this来引用当前的对象
    // 在构造函数中定义属性
this.name = name;
this.age = age;
}
//等同于Person.prototype = function sayName(){}
sayName() {
return this.name;
}
sayAge() {
return this.age;
}
}
let p1 = new Person('shu', 18);
console.log(p1);
/*
*   类中的所有代码都会在严格模式下执行
*       严格模式下其中一个特点就是，函数的this不在是window，而是undefined
*   注意：
*       在类中方法的this不是固定的
*           以方法形式调用时，this就是当前的实例
*           以函数形式调用，this是undefined
*       在开发时，在有些场景下，我们希望方法中的this是固定的，不会因调用方式不同而改变
*           如果遇到上述需求，可以使用箭头函数来定义类中的方法
*           如果类中的方法是以箭头函数定义的，则方法中的this恒为当前实例，不会改变
* */
```

***\*技巧：通过 Objec.assign() 方法一次性向类中添加多个方法\****

```js
Object.assign(Person.prototype, {
sayName(){
return this.name;
}
sayAge(){
return this.age;
}
})
```

#### B. 类的继承

ES6 中直接使用 `extends `语法糖（更简洁高级的实现方式）来实现继承，同时可以重写父类的方法，直接在子类中重新写一次要重写的方法即可覆盖父类方法。

`super` 关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。

```js
// 将多个类中的重复代码提取出来
class Animal{
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayHello = () => {
        console.log('动物在叫');
    };
}

// 通过继承可以使得类中拥有其他类中的属性和方法
// 使用extends来继承一个类，继承后就相当于将该类的代码复制到了当前类中
// 当我们使用继承后，被继承的类就称为父类，继承父类的类 称为子类
class Dog extends Animal{
    /*
    *   子类继承父类后，将获得父类中所有的属性和方法，
    *       也可以创建同名的属性或方法来对父类进行重写
    * */
    sayHello = () => {
        console.log('汪汪汪！');
    };

}

class Snake extends Animal{
    // 当在子类中重写父类构造函数时，必须在子类构造函数中第一时间调用父类构造函数，否则会报错
    constructor(name, age, len) {
        super(name, age); // 调用父类构造函数
        this.len = len;
    }

    sayHello = () => {
        console.log('嘶嘶嘶~~');
    };
}

const dog = new Dog('旺财', 5);
const snake = new Snake('长虫', 4, 10);
// console.log(dog.name, dog.age);
console.log(snake.name, snake.age, snake.len);
```

**思考：如何让多个类混入一个类中？** 

```js
class Parent {
  someParentMethod () {
     console.log('Parent')
  }
}

class ChildOne extends Parent {
   someChildOneMethod () {
     console.log('someChildOneMethod')
  }
}

class ChildTwo extends Parent {
   someChildTwoMethod () {
     console.log('someChildTwoMethod')
   }
}


// define GrandChild as a Mix-in:
let GrandChild = Base => class extends Base {
  someGrandChildMethod() {
     console.log('someGrandChildMethod')
   }
};

//Then:
class GrandChildOne extends GrandChild(ChildOne) { }
class GrandChildTwo extends GrandChild(ChildTwo) { }

const grandChildOne = new GrandChildOne()
const grandChildTwo = new GrandChildTwo()

grandChildOne.someChildOneMethod();
grandChildTwo.someChildTwoMethod();
```



# d14.  ES6模块化

 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。

### 01 模块化的好处

模块化的优势有以下几点：

- 防止命名冲突
- 代码复用
- 高维护性

### 02 模块化规范产品

ES6 之前的模块化规范有：

- CommonJS => NodeJS、Browserify
- AMD => requireJS
- CMD => seaJS

### 03 ES6 模块化语法

模块功能主要由两个命令构成：`export` 和 `import`。

- `export` 命令用于规定模块的对外接口
- `import` 命令用于输入其他模块提供的功能

#### A 模块导出数据语法

1. 单个导出

   ```js
   // 单个导出
   export let uname = 'Rick';
   export let sayHello = function () {
       console.log('Hi, bro!');
   }
   ```

2. 合并导出

   ```js
   let uname = 'Rick';
   let sayHello = function () {
       console.log('Hi, bro!');
   }
   // 合并导出
   export { uname, sayHello };
   ```

3. 默认导出

   ```js
   // 默认导出 只能使用一次
   export default {
       uname: 'Rick',
       sayHello: function () {
           console.log('Hi, bro!');
       }
   }
   ```

#### B 模块导入数据语法

1. 通用导入方式

   ```js
   import * as m1 from './js/m1.js';
   import * as m2 from './js/m2.js';
   import * as m3 from './js/m3.js';
   ```

2. 解构赋值导入

   ```js
   import { uname, sayHello } from './js/m1.js';
   // 有重复名可以设置别名
   import { uname as uname2, sayHello as sayHello2 } from './js/m2.js';
   console.log(uname);
   // 配合默认导出
   import {default as m3} from "./src/js/m3.js";
   ```

3. 简便方式导入，针对默认暴露

   ```js
   import m3 from "./src/js/m3.js";
   ```

#### C ES6 使用模块化方式二

将文件导入都写进一个 app.js 文件中，然后在里面写入要导入的模块。app.js 中的内容如下：

```js
import * as m1 from './js/m1.js';
import * as m2 from './js/m2.js';
import * as m3 from './js/m3.js';

console.log(m1);
console.log(m2);
console.log(m3);
```

在 index.html 中引入 app.js 文件内容：

```html
<script src="./app.js" type="module"></script>
```

### 04 使用 babel 对模块化代码转换

有的浏览器不支持 ES6 语法，这时候就需要使用 babel 来将其转换成 ES5 等价语法。

```js
1. 安装工具
npm i babel-cli babel-preset-env browserify(webpack) -D
2. 编译
npx babel src/js -d dist/js --presets=babel-preset-env
3. 打包
npx browserify dist/js/app.js -o dist/bundle.js
```

### 05 ES6 模块化引入 npm 安装的包

```js
npm install jquery
import $ from 'jquery'
```

# d15.  ES11新特性

### 01 类的私有属性

ES11 提供了类的私有属性，在类的外部无法访问该属性。只有再类的内部能访问。

```js
class Person{
  //公有属性
  name;
  //私有属性
  #age;
  #weight;
  //构造方法
  constructor(name, age, weight){
    this.name = name;
    this.#age = age;
    this.#weight = weight;
  }

  intro(){
    console.log(this.name);
    console.log(this.#age);
    console.log(this.#weight);
  }
}

//实例化
const girl = new Person('晓红', 18, '45kg');

// 外部无法直接访问
// console.log(girl.name);
// console.log(girl.#age);
// console.log(girl.#weight);

girl.intro();
```

### 02 allSettled

该 `Promise.allSettled()` 方法返回一个在所有给定的 `promise` 都已经 `fulfilled` 或 `rejected` 后的 `promise`，并带有一个对象数组，每个对象表示对应的 `promise` 结果。`allSettled` 方法返回的 `Promise` 对象始终是成功（`fulfilled`）的。
使用场景：

- 有多个彼此不依赖的异步任务成功完成时使用。
- 想得到每个 `promise` 的结果时使用。

对比于 `Promise.all()`，`all()` 也接受一个 `Promise` 对象数组参数，只要有一个失败（`rejected`），那么返回的 `Promise` 对象就是失败（`rejected`）的。
使用场景：

- 传进去的 `Promise` 对象彼此依赖，且需要在其中任何一个失败的时候停止。

两个 `Promise` 都是成功的情况：

```js
let p1 = new Promise((resolve, reject) => {
  resolve('用户数据-1')
})

let p2 = new Promise((resolve, reject) => {
  resolve('订单数据-2')
})

let res1 = Promise.allSettled([p1, p2])
let res2 = Promise.all([p1, p2])
console.log(res1)
console.log(res2)
```

输出结果： ![es11-1](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/docs/es11-1.2fgw7vvkb0kk.png)

一个成功，一个失败：

```js
let p1 = new Promise((resolve, reject) => {
  resolve('用户数据-1')
})

let p2 = new Promise((resolve, reject) => {
  reject('失败了')
})

let res1 = Promise.allSettled([p1, p2])
let res2 = Promise.all([p1, p2])
console.log(res1)
console.log(res2)
```

打印结果： ![ES11-2](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/docs/ES11-2.17q27y7sy9mk.png)

### 03 matchAll

`matchAll()` 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。

```js
const regexp = /t(e)(st(\d?))/g;
const str = 'test1test2';

const array = [...str.matchAll(regexp)];

console.log(array[0]);
// expected output: Array ["test1", "e", "st1", "1"]

console.log(array[1]);
// expected output: Array ["test2", "e", "st2", "2"]
```

### 04 可选链

#### A 定义

可选链 `?.` 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。
原则：如果可选链 `?.` 前面的部分是 `undefined` 或者 `null`，它会停止运算并返回该部分。

```js
let user = {
  address: {
  }
}
console.log( user?.address?.street ); // undefined（不报错）
```

#### B 短路效应

短路效应：正如前面所说的，如果 `?.` 左边部分不存在，就会立即停止运算（“短路效应”）。所以，如果后面有任何函数调用或者副作用，它们均不会执行。
这有和 `&&` 的作用类似，但上述改用 `&&` 会显得代码冗余度高：

```js
console.log(user && user.address && user.address.street)
```

##### C 其它变体：?.()，?.

可选链 `?.` 不是一个运算符，而是一个特殊的语法结构。它还 **可以与函数和方括号一起使用**。
例如，将 `?.()` 用于调用一个可能不存在的函数（即使不存在也不报错）。

```js
function foo() {
  console.log('hello')
}
foo?.()
// hello
```

`?.[]` 允许从一个可能不存在的对象上安全地读取属性。（即使不存在也不报错）。

```js
let obj = {
  key: 123
}
console.log(obj?.['key'])
// 123
```

### 05 动态 import 导入

```js
const btn = document.getElementById('btn');
btn.onclick = function(){
  import('./hello.js').then(module => {
    module.hello();
}
```

### 06 BigInt

`BigInt` 是一种特殊的数字类型，它提供了对任意长度整数的支持。

创建 `bigint` 的方式有两种：在一个整数字面量后面加 `n` 或者调用 `BigInt` 函数，该函数从字符串、数字等中生成 `bigint`。

```js
let n1 = 123n
let n2 = 456n
let n3 = BigInt(789)
console.log(typeof n1) // bigint
console.log(n1+n2) // 579n
console.log(n2+n3) // 1245n
```

比较运算符：`<`  和 `>` ，使用它们来对`bigint` 和 `number `类型的数字进行比较没有问题：

```js
alert( 2n > 1n ); // true
alert( 2n > 1 ); // true
```

但是请注意，由于`bigint` 和 `number `属于不同类型，它们可能在进行` ==`比较时相等，但在进行`===`（严格相等）比较时不相等：

```js
alert( 1 == 1n ); // true
alert( 1 === 1n ); // false
```

### 07 globalThis

全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内置于语言或环境中。
在浏览器中，它的名字是 `window`，对 Node.js 而言，它的名字是 `global`，其它环境可能用的是别的名字。
ES11中 `globalThis` 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。所有主流浏览器都支持它。
使用场景： 假设我们的环境是浏览器，我们将使用 `window`。如果你的脚本可能会用来在其他环境中运行，则最好使用 `globalThis`。



 

 