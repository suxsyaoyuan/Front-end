# 数据结构

@codewhy

# d1 前言

解决问题方法的效率，根据数据的组织方式有关。

以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢?

这就是数据结构需要考虑的问题。

## 01 常见的数据结构

- 数组（Aarray）

- 栈（Stack）

- 链表（Linked List）

- 图（Graph）

- 散列表（Hash）

- 队列（Queue）

- 树（Tree）

- 堆（Heap）


## 02 算法

Algorithm 这个单词本意就是解决问题的办法/步骤逻辑。

数据结构的实现，离不开算法。

# d2 数组

几乎所有的编程语言都原生支持数组类型，因为数组是最简单的内存数据结构。 

数组通常情况下用于存储一系列同一种数据类型的值。 但在 JavaScript 里，数组中可以保存不同类型的值。但我们还是要遵守最佳实践，别这么做（大多数语言都没这个能力）。

> 常见语言的数组不能存放不同的数据类型
> 常见语言的数组容量不会自动改变(需要进行扩容操作)
> 常见的语言数组进行中间插入和删除操作性能比较低

## 01 创建和初始化数组

- `new Array()`

  ```js
  const daysOfWeek = new Array(
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  );
  ```

- `[]`
  
  ```js
  const daysOfWeek = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
  ];
  ```

## 02 数组长度和遍历数组

- 如果我们希望获取数组的长度, 有一个length属性

  ```javascript
  // 获取数组的长度
  alert(daysOfWeek.length)
  ```

- 也可以通过下标值来遍历数组:

  ```javascript
  // 普通for方式遍历数组
  for (var i = 0; i < daysOfWeek.length; i++) {
      alert(daysOfWeek[i])
  }
  
  // 通过foreach遍历数组
  daysOfWeek.forEach(function (value) {
      alert(value)
  })
  ```

- 我们来做一个练习:

  - 求菲波那切数列的前20个数字, 并且放在数组中.
  - 菲波那切数列数列第一个数字是1, 第二个数字也是1, 第三项是前两项的和

  ```javascript
  // 求菲波那切数列的前20个数字
  var fibonacci = []
  fibonacci[0] = 1
  fibonacci[1] = 1
  
  for (var i = 2; i < 20; i++) {
      fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]
  }
  
  alert(fibonacci)
  ```

## 03 数组常见操作

```js
// 初始化一个数组
var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 添加元素

- 添加一个元素到数组的最后位置 `array.push(item)`

  ```js
  // 添加一个元素到数组的最后位置
  // 方式一:
  numbers[numbers.length] = 10
  
  // 方式二:
  numbers.push(11)
  numbers.push(12, 13)
  
  alert(numbers)
  ```

- 在数组首位插入一个元素 `array.unshift(item)`

  ```js
  // 在数组首位插入一个元素
  // 方式一:
  for (var i = numbers.length; i > 0; i--) {
      numbers[i] = numbers[i-1]
  }
  numbers[0] = -1
  alert(numbers) // -1,0,1,2,3,4,5,6,7,8,9,10,11,12,13
  
  // 方式二:
  array.unshift(item)
  ```

- 在指定索引位置插入元素 `array.splice(index, 0, item)`
  > splice() 第二个参数为 0 时，表示插入数据。
  ```js
  let myArray = [1, 2, 3];
  // 在 索引 0 的位置，插入 A
  myArray.splice(0, 0, "A");
  console.log(myArray); //--> ['A', 1, 2, 3]
  ```

- 考虑上面代码实现的性能怎么呢?

  - 性能并不算非常高

  - 这也是数组和链表(后面我们会学习到)相对比的一个劣势: 在中间位置插入元素的效率比链表低。

### 删除元素

- 删除数组最后的元素 `array.pop()`

- 删除数组首位的元素 `array.shift()`

  ```js
  // 删除首位的元素
  for (var i = 0; i < numbers.length; i++) {
      numbers[i] = numbers[i+1]
  }
  numbers.pop()
  alert(numbers)
  
  numbers.shift()
  alert(numbers)
  ```

- 删除指定索引位置的元素 `array.splice(start, deleteCount)`
  例如：
  
  ```js
  let myArray2 = [1, 2, 3, 4, 5];
  // 删除索引 3 位置起，2 个元素
  myArray2.splice(3, 2);
  console.log(myArray2); //--> [1, 2, 3]
  ```

- 如果我们希望使用splice来插入数据呢?

  ```js
  // 插入指定位置元素
  numbers.splice(5, 0, 3, 2, 1)
  alert(numbers) // -4,-3,-2,-1,0,3,2,1,4,5,6,7,8,9,10,11,12,13
  
  /*
  代码解析:
  上面的代码会从索引为5的位置开始插入数据. 其他数据依次向后位移.
  第一个参数依然是索引值为5(第六个位置)
  第二个参数为0时表示不是删除数据, 而是插入数据.
  后面紧跟的是在这个位置要插入的数据, 可以是其他类型, 比如"a", "b", "c".
  */
  ```

### 修改元素

- 修改指定索引位置的元素 `array.splice(index, 1, item)`
  ```js
  let myArray3 = [1, 2, 3, 4, 5, 6];
  // 修改 索引 1 的位置的元素为 AA
  myArray2.splice(1, 1, "AA");
  console.log(myArray3); //--> [1, "AA", 3, 4, 5, 6]
  ```
- 修改指定索引位置的几个元素 `array.splice(index, number, item)`
  ```js
  let myArray4 = [1, 2, 3, 4, 5, 6, 7];
  // 在 索引 2 的位置起，修改两个元素为 AA BB
  myArray2.splice(2, 2, "AA", "BB");
  console.log(myArray3); //--> [1, 2, "AA", "BB", 5, 6, 7]
  ```

### 其他方法

我们先对常见的方法简单来看一下

| 方法名        | 方法描述                                                     |
| ------------- | ------------------------------------------------------------ |
| `concat`      | 连接2个或更多数组，并返回结果                                |
| `every`       | 对数组中的每一项运行给定函数，如果该函数对每一项都返回 `true`，则返回`true`, 否则返回`false` |
| `filter`      | 对数组中的每一项运行给定函数，返回该函数会返回 `true`的项组成的数组 |
| `forEach`     | 对数组中的每一项运行给定函数。这个方法没有返回值             |
| `join`        | 将所有的数组元素连接成一个字符串                             |
| `indexOf`     | 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1   |
| `lastIndexOf` | 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值     |
| `map`         | 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 |
| `reverse`     | 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个 |
| `slice`       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |
| `some`        | 对数组中的每一项运行给定函数，如果任一项返回 `true`，则结果为`true`, 并且迭代结束 |
| `sort`        | 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数   |
| `toString`    | 将数组作为字符串返回                                         |
| `valueOf`     | 和 `toString`类似，将数组作为字符串返回                      |

#### 数组合并

- 数组的合并非常简单, 使用concat即可(也可以直接+进行合并)

  ```javascript
  // 数组的合并
  var nums1 = [1, 2, 3]
  var nums2 = [100, 200, 300]
  var newNums = nums1.concat(nums2)
  alert(newNums) // 1,2,3,100,200,300
  
  newNums = nums1 + nums2
  alert(newNums) // 1,2,3,100,200,300
  ```

#### 迭代方法

- 为了方便操作数组, JS提供了很多迭代器方法, 我们来回顾一下

- every()方法

  - every()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false.
  - 如果函数中每一个元素都返回true, 那么结果为true, 有一个为false, 那么结果为false

- every()练习:

  - 判断一组元素中是否都包含某一个字符

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  
  // 判断数组的元素是否都包含a字符
  var flag = names.every(function (t) {
      return t.indexOf('a') != -1
  })
  alert(flag)
  ```

- some()方法

  - some()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false
  - 但是和every不同的是, 一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true

- some()练习

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  
  // 判断数组中是否包含有a字符的字符
  var flag = names.some(function (t) {
      alert(t)
      return t.indexOf("a") != -1
  })
  alert(flag)
  ```

- forEach()方法

  - forEach()方法仅仅是一种快速迭代数组的方式而已.
  - 该方法不需要返回值

- forEach的使用

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  
  // forEach的使用
  names.forEach(function (t) {
      alert(t)
  })
  ```

- filter()方法

  - filter()方法是一种过滤的函数
  - 首先会遍历数组中每一个元素传入到函数中
  - 函数的结果返回true, 那么这个元素会被添加到最新的数组中, 返回false, 则忽略该元素.
  - 最终会形成一个新的数组, 该数组就是filter()方法的返回值

- filter()的练习:

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  
  // 获取names中所有包含'a'字符的元素
  var newNames = names.filter(function (t) {
      return t.indexOf("a") != -1
  })
  alert(newNames)
  ```

- map()方法

  - map()方法提供的是一种映射函数.
  - 首先会遍历数组中每一个元素传入到函数中.
  - 元素会经过函数中的指令进行各种变换, 生成新的元素, 并且将新的元素返回.
  - 最终会将返回的所有元素形成一个新的数组, 该数组就是map()方法的返回值

- map()练习:

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  
  // 在names中所有的元素后面拼接-abc
  var newNames = names.map(function (t) {
      return t + "-abc"
  })
  alert(newNames)
  ```

#### reduce方法

- 我们单独拿出reduce方法, 因为这个方法相对来说难理解一点

- 首先, 我们来看这个方法需要的参数:

  ```javascript
  arr.reduce(callback[, initialValue])
  ```

- 参数

  - callback（一个在数组中每一项上调用的函数，接受四个函数：）
    - previousValue（上一次调用回调函数时的返回值，或者初始值）
    - currentValue（当前正在处理的数组元素）
    - currentIndex（当前正在处理的数组元素下标）
    - array（调用reduce()方法的数组）
  - initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）

- 有些晦涩难懂, 我们直接看例子

  - 求一个数字中数字的累加和

- 使用for实现:

  ```javascript
  // 1.定义数组
  var numbers = [1, 2, 3, 4]
  
  // 2.for实现累加
  var total = 0
  for (var i = 0; i < numbers.length; i++) {
      total += numbers[i]
  }
  alert(total) // 10
  ```

- 使用forEach简化for循环

  - 相对于for循环, forEach更符合我们的思维(遍历数组中的元素)

  ```javascript
  // 3.使用forEach
  var total = 0
  numbers.forEach(function (t) {
      total += t
  })
  alert(total)
  ```

- 使用reduce方法实现

  ```javascript
  // 4.使用reduce方法
  var total = numbers.reduce(function (pre, cur) {
      return pre + cur
  })
  alert(total)
  ```

- 代码解析:

  - pre中每次传入的参数是不固定的, 而是上次执行函数时的结果保存在了pre中
  - 第一次执行时, pre为0, cur为1
  - 第二次执行时, pre为1 (0+1, 上次函数执行的结果), cur为2
  - 第三次执行时, pre为3 (1+2, 上次函数执行的结果), cur为3
  - 第四次执行时, pre为6 (3+3, 上次函数执行的结果), cur为4
  - 当cur为4时, 数组中的元素遍历完了, 就直接将第四次的结果, 作为reduce函数的返回值进行返回.

- 似乎和forEach比较没有太大的优势呢?

  - 通过这个代码你会发现, 你不需要在调用函数前先定义一个变量, 只需要一个变量来接收方法最终的参数即可.
  - 但是这就是优势吗? 不是, 优势在于reduce方法有返回值, 而forEach没有.
  - 这算什么优势? 如果reduce方法有返回值, 那么reduce方法本身就可以作为参数直接传递给另外一个需要reduce返回值的作为参数的函数. 而forEach中你只能先将每次函数的结果保存在一个变量, 最后再将变量传入到参数中.
  - 没错, 这就是最近非常流行的函数式编程. 也是为了几乎每个可以使用函数式编程的语言都有reduce这个方法的原因.
  - 关于函数式编程, 不再本次课程的讨论之中, 只是看到了这个函数, 给大家延伸了一下而已.(后面有机会和大家分享函数式编程)

- initialValue还需要讲吗?

  - 其实就是第一次执行reduce中的函数时, pre的值.
  - 因为默认pre第一次执行时为0.

## 04 数组&Leetcode

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

> 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

### 1991 寻找数组的中心索引

给你一个下标从 **0** 开始的整数数组 `nums` ，请你找到 **最左边** 的中间位置 `middleIndex` （也就是所有可能中间位置下标最小的一个）。

> 思路：先求得数组中所有元素之和sum；遍历数组，取当前下标左边的元素之和left_sum，同时sum减去已遍历元素（右和），比较二者是否相等，相等则返回当前下标；遍历结束，代表没有中心索引，返回-1；

```jsx
var pivotIndex = function(nums) {
        let sum = 0; //总和
        for(let i=0;i<nums.length;i++){
            sum += nums[i];
        }

        let left_sum = 0;
        for(let i=0;i<nums.length;i++){
            sum -= nums[i]; //右和
            if(left_sum == sum){
                return i;
            }
            left_sum += nums[i];
        }
    return -1;
};
```

### 35 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```js
// 线性查找 O(n)
var searchInsert = function(nums, target) {
    for(let i=nums.length-1; i>=0; i--) {
        if (target === nums[i]) {
            return i;
        } else if (target > nums[i]) {
            return i + 1;
        }
    }
    return 0;
};
```

```js
var searchInsert = function (nums, target) { //O(log n)
// 初始化左边界、中间位置、右边界和结果
let left = 0, mid = 0, right = nums.length - 1;
// 使用二分搜索来查找插入位置  
	while (left + 1 < right) { 
        // 进入循环 当前查找区间存在（即 left 没有越过或等于 right），直到查找区间为空
		// 计算中间位置
		mid = left + ((right - left) >> 1);
		// >> 1 表示将操作数向右移动一个位，这等同于将其除以 2
		// mid = left + Math.floor((right - left) / 2); 所以，加上 left 的目的是确保 mid 表示的是相对于当前搜索范围的偏移量，而不是整个数组的偏移量。
		// 如果中间元素小于目标元素，则将左边界移到中间位置
        if (nums[mid] < target) { left = mid;} 
        // 否则，将右边界移到中间位置
        else { right = mid; }
     }
        // 这个循环会一直执行，直到查找区间为空或只包含一个元素（left + 1 < right 不再成立）。
    
        // 判断目标元素与左边界、右边界的关系，确定插入位置
   		// 目标元素小于或等于左边界元素，插入位置为左边界的位置
        if (target <= nums[left]) { return left; } 
    	// 目标元素大于左边界元素且小于或等于右边界元素，插入位置为右边界的位置
    	else if (target <= nums[right]) { return right; } 
    	// 目标元素大于右边界元素，插入位置为右边界的下一个位置
    	else { return right + 1;}
};
```

### 27 移除元素

一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

> 原地删除重复元素

```js
// 要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。
var removeElement = function(nums, val) {
    // 初始化两个指针，i指向当前位置，j用于覆盖等于val的元素 也就是非val元素应放置的位置
    let i = 0;
    let j = 0;
    // 遍历数组
    while (i < nums.length) {
        // 如果当前元素不等于val，进行覆盖操作并递增 k
        if (nums[i] !== val) {
            nums[j] = nums[i];
            j++;
        }
        // 移动i指针
        i++;
    }
    // 返回新长度
    return j;
};
```

```js
//时间复杂度：O(n)
//空间复杂度：O(1)
var removeElement = (nums, val) => {
    let k = 0;
    for(let i = 0;i < nums.length;i++){
        if(nums[i] != val){
            nums[k++] = nums[i] //先使用 k 的当前值然后再递增 k
        }
    }
    return k;
};
```

26 删除有序数组中的重复项

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

> 保留唯一元素并返回个数

```js
var removeDuplicates = function(nums) {
    // 边界情况处理
    if (nums.length === 0) {
        return 0;
    }
    // 记录不同元素的位置
    let k = 0;
    // 从第二个元素开始遍历数组
    for (let i = 1; i < nums.length; i++) {
        // 如果当前元素与前一个元素不相等
        if (nums[i] !== nums[k]) {
           // 将当前不同的元素放到下一个位置并递增指针 k（k先递增，然后再将nums[i]赋值给nums[k]）
           	nums[++k] = nums[i];
        }
    }
    // 返回新长度
    return k + 1;
};
```

### 844 [比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

> 通过 `processString` 函数，将输入的字符串经过文本编辑器处理，去除退格字符，得到处理后的字符串。然后，比较两个字符串经过处理后是否相等，返回相等与否的布尔值。
>
> 在 `processString` 函数中，通过遍历输入字符串，对于每个字符，如果是正常字符就将其压入栈，如果是退格字符（`#`），则尝试弹出栈顶元素。这样，最终栈中留下的字符就是去除退格后的结果。最后，通过 `stack.join('')` 将栈中的字符连接成字符串并返回。这样，得到的字符串就是经过文本编辑器处理后的结果，去除了退格字符。

```js
var backspaceCompare = function(s, t) {
    // 定义一个处理字符串的函数
    function processString(inputStr) {
        // 用数组模拟栈的数据结构
        const stack = []; 
        // 遍历输入的字符串
        for (const char of inputStr) {
            // 如果当前字符不是退格符，将其压入栈
            if (char !== '#') {
                stack.push(char); 
            } else if (stack.length > 0) {
                // 如果当前字符是退格符且栈不为空，弹出栈顶元素（模拟退格操作）
                stack.pop(); 
            }
        }
        return stack.join(''); // 将栈中的元素连接成字符串并返回
    }
    // 比较经过处理后的两个字符串是否相等
    return processString(s) === processString(t); 
};
```

283 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

> 该代码通过使用双指针，遍历数组，将遇到的非零元素与零元素进行交换，并同时更新零元素位置，最终实现将数组中的零元素移动到末尾，保持非零元素的相对顺序不变。

```js
var moveZeroes = function(nums) {
    // 通过双指针遍历数组，将非零元素与零元素交换
    let k = 0; //记录非零元素的位置
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            // 遇到非零元素时，将其与nums[k]位置的元素交换，然后递增k
            [nums[i], nums[k]] = [nums[k], nums[i]];
            k++;
        }
    }
};
```

977 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

> 使用两个指针（i 和 j）分别从数组的开头和结尾向中间遍历，计算并比较当前位置的元素的平方，将较大的平方值存储在结果数组的末尾，同时更新相应的指针。

```javascript
var sortedSquares = function(nums) {
    let n = nums.length;
    // 创建一个新数组 res，长度为 n，并用 0 填充
    let res = new Array(n).fill(0);
    // 初始化三个指针 i、j、k 分别指向数组开头、结尾以及结果数组的末尾
    let i = 0, j = n - 1, k = n - 1;
    // 使用 while 循环，直到 i 大于 j
    while (i <= j) {
        // 计算当前位置 i 和 j 处元素的平方，分别存储在 left 和 right 中
        let left = nums[i] * nums[i],right = nums[j] * nums[j];
        // 比较 left 和 right，将较大的值存储在结果数组 res 的末尾（从后向前填充），并更新相应指针
        if (left < right) {
            res[k--] = right;
            j--;
        } else {
            res[k--] = left;
            i++;
        }
    }
    // 返回排序后的平方数组 res
    return res;
};
```

![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

### 209 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

> 调整左右指针的位置，动态维护一个滑动窗口，使得窗口中的元素的和满足要求。

```javascript
var minSubArrayLen = function(target, nums) {
    let start=0, end=0;
    // 初始化变量 sum 用于存储当前子数组的和，len 为数组的长度，ans 为结果变量，初始值设为正无穷
    let sum = 0;
    let len = nums.length;
    let ans = Infinity;
    // 使用 while 循环，循环条件为 end 指针小于数组的长度
    while(end < len) {
        // 将当前元素加到 sum 中
        sum += nums[end];
        // 使用内部的 while 循环，当 sum 大于等于目标值时，更新结果 ans，并缩小子数组范围
        while (sum >= target) {
            ans = Math.min(ans, end - start + 1); 
            // 更新ans为当前子数组的长度end-start+1和当前ans的较小值
            sum -= nums[start]; 
            // 减去左边界的值
            start++; 
            // 移动左边界
        } 
        end++; // 移动右边界
    }
    // 返回最终结果，如果 ans 仍然为正无穷，说明没有找到满足条件的子数组，返回 0，否则返回 ans
    return ans === Infinity ? 0 : ans;
};
```

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

### [76 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)（）

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```

```

### 54 螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

> 通过循环，依次按照从左到右、从上到下、从右到左、从下到上的顺序遍历矩阵，将遍历得到的元素存储在结果数组 `result` 中。

```js
var spiralOrder = function(matrix) {
    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {
        return [];
    }
    let result = [];  // 用于存储顺时针螺旋遍历的结果
    let top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;

    while (top <= bottom && left <= right) {
        // 从左到右
        for (let i = left; i <= right; i++) {
            result.push(matrix[top][i]);
        }
        top++;
        // 从上到下
        for (let i = top; i <= bottom; i++) {
            result.push(matrix[i][right]);
        }
        right--;
        // 从右到左
        if (top <= bottom) {
            for (let i = right; i >= left; i--) {
                result.push(matrix[bottom][i]);
            }
            bottom--;
        }
        // 从下到上
        if (left <= right) {
            for (let i = bottom; i >= top; i--) {
                result.push(matrix[i][left]);
            }
            left++;
        }
    }
    return result;  // 返回按照顺时针螺旋遍历的矩阵元素结果
};
```

### 59 螺旋矩阵II

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

> 使用 `while` 循环，每次循环填充一圈的元素，包括从左到右、从上到下、从右到左、从下到上。从左到右填充一行，起始行为 `top`，列从 `left` 到 `right - 1`，每填充一个数字 `start` 就自增。从上到下填充一列，起始列为 `right`，行从 `top` 到 `bottom - 1`。从右到左填充一行，起始行为 `bottom`，列从 `right` 到 `left + 1`。从下到上填充一列，起始列为 `left`，行从 `bottom` 到 `top + 1`。在每一轮填充后，更新边界值，即缩小填充的范围。

```js
var generateMatrix = function(n) {
    let loop = Math.floor(n/2);
    let mid = n%2;
    let matrix = Array(n).fill(0).map(() => new Array(n).fill(0))
    top = 0;
    left = 0;
    right = n-1;
    bottom = n-1;
    count =1;
    //填中间
    if(mid === 1){
        matrix[loop][loop] = n*n
    }
    while(loop--){
        //填行
        for(let i = left; i <right; i++){
            matrix[top][i] = count;
            count ++
        }
        //填右边
        for(let i =top ;i<bottom; i++){
            matrix[i][right] = count;
            count ++
        }
        //填下面
        for(let i = right; i > left ; i--){
            matrix[bottom][i] = count;
            count ++
        }
        //填左边
        for(let i =bottom ;i>top; i--){
            matrix[i][left] = count;
            count ++
        }
        top++
        right --
        bottom -- 
        left++
    }
    return matrix
};
```

```js
var generateMatrix = function(n) {
    // 初始化起始位置
    let startX = startY = 0;   // 起始位置
    let loop = Math.floor(n/2);   // 旋转圈数
    let mid = Math.floor(n/2);    // 中间位置
    let offset = 1;    // 控制每一层填充元素个数
    let count = 1;     // 更新填充数字
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0)); // 初始化一个二维数组用于存储矩阵

 	// 开始螺旋填充
    while (loop--) {
        let row = startX, col = startY;
        // 上行从左到右（左闭右开）
        for (; col < n - offset; col++) {
            res[row][col] = count++;
        } 
        // res[0][0] = 1、res[0][1] = 2、res[0][2] = 3
        // 右列从上到下（左闭右开）
        for (; row < n - offset; row++) {
            res[row][col] = count++;
        } 
        // res[1][2] = 4、res[2][2] = 5
        // 下行从右到左（左闭右开）
        for (; col > startY; col--) {
            res[row][col] = count++;
        } 
        // res[2][2] = 6、res[2][1] = 7
        // 左列做下到上（左闭右开）
        for (; row > startX; row--) {
            res[row][col] = count++;
        } 
        // res[2][0] = 8、res[1][0] = 9
        // 更新起始位置
        startX++;
        startY++;

        // 更新偏移量
        offset += 1;
    }

    // 如果 n 为奇数，单独给矩阵中心位置赋值
    if (n % 2 === 1) {
        res[mid][mid] = count;
    }
    return res; // 返回生成的螺旋矩阵
};
```

### 48 旋转矩阵/图像

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？

```js
var rotate = function(matrix) {
    // 每一次有四个元素交换位置 找规律
    let length = matrix.length; 
    for (let i = 0; i < matrix.length/2; i++) { 
        // 遍历矩阵的每一层 只需要遍历到矩阵的中心
        for (let j = i; j < length - i -1; j++) { 
            // 遍历每一层中的每个元素 j表示当前处理的列 内层循环只会处理到该层的右边界前一个位置
            let temp = matrix[i][j]; 
            // 比如temp = matrix[0][0] 把第一行第一列元素提出来 
            matrix[i][j] = matrix[length - j-1][i]; 
            // matrix[0][0]=matrix[3][0] 第四行第一列放到第一行第一列 
            matrix[length - j -1][i] = matrix[length-i-1][length-j-1]; 
            // matrix[3][0]=matrix[3][3] 第四行第四列放到第四行第一列
            matrix[length-i-1][length-j-1] = matrix[j][length-i-1]; 
            // matrix[3][3]=matrix[0][3] 第四行第一列放到第四行第四列 
            matrix[j][length-i-1] = temp; 
            // matrix[0][3]=matrix[0][0]  把第一行第一列元素放到第一行第四列 
        }
    }
}
```

### 0108 零矩阵

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

```js
var setZeroes = function(matrix) {
    const rows = matrix.length; // 获取矩阵的行数
    const cols = matrix[0].length; // 获取矩阵的列数

    const zeroRows = {} // 用于记录需要清零的行的对象
    const zeroCols = {} // 用于记录需要清零的列的对象

     // 遍历矩阵，记录需要清零的行和列
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (matrix[i][j] === 0) {
                zeroRows[i] = true // 标记第i行需要清零
                zeroCols[j] = true // 标记第j列需要清零
            }
        }
    }

    // 再次遍历矩阵，将对应行和列的元素清零
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (zeroRows[i] || zeroCols[j]) {
                matrix[i][j] = 0; // 如果第i行或第j列需要清零，则将元素清零
            }
        }
    }
}
```

### 02 数组拆分

给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1到 n 的 min(ai, bi) 总和最大。

```js
var arrayPairSum = function(nums) {
    // 排序 然后把两个相邻元素中小的数相加 即nums[0]+nums[2]...
    nums.sort((a, b) => a - b);

    let maxSum = 0;
    // 取相邻元素的较小值相加
    for (let i = 0; i < nums.length; i += 2) {
        maxSum += nums[i];
    }
    return maxSum;
};
```

### 04 最大连续1的个数

给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。

```js
var findMaxConsecutiveOnes = function(nums) {
    // 遍历数组，在遇到元素为1时，增加计数器（count），在遇到元素为0时，更新最大连续1的个数（maxCount），并重置计数器。
    let count = 0;
    let maxCount = 0;

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            count++;
        } else {
            maxCount = Math.max(maxCount, count);
            count = 0; //重置
        }
    }
    // 处理末尾可能存在的连续 1
    maxCount = Math.max(maxCount, count);
    return maxCount;
};
```

### 02 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。

例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]；若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]；注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

```js
var findMin = function(nums) {
    // 如果数组为空，返回-1
    if (nums.length === 0) {
        return -1;
    }
    let start = 0;
    let end = nums.length - 1;

    // 找到中间位置 mid
    while (start + 1 < end) {
        let mid = start + Math.floor((end - start) / 2);
        // 如果 nums[mid] 小于等于 nums[end]，说明最小元素在 mid 的左侧或就是 mid，更新右指针为 mid
        if (nums[mid] <= nums[end]) {
            end = mid;
        } else {
            // 否则，最小元素在 mid 的右侧，更新左指针为 mid
            start = mid;
        }
    }
    // 比较 start 和 end 指针指向的值，返回最小元素
    if (nums[start] > nums[end]) {
        return nums[end];
    }

    return nums[start];
};
```

## 05 字符串&Leetcode

双指针法|反转系列| KMP

### 14 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

```js
var longestCommonPrefix = function(strs) {
    if (strs.length === 0) {
        return "";
    }
    // 循环遍历第一个字符串的每个字符
    for (let i = 0; i < strs[0].length; i++) {
        const char = strs[0][i]; //表示第一个字符串中的每个字符
        // 检查其他字符串的当前位置是否与第一个字符串相同
        for (let j = 1; j < strs.length; j++) { // j表示这个数组中的每个字符串
            // 如果其他字符串已经比较到末尾或者当前字符不匹配 说明已经找到公共前缀的末尾
            if (i === strs[j].length || strs[j][i] !== char) {
                // 返回找到的公共前缀部分 即strs[0]中从第一个字符开始到当前位置 i 为止的子字符串
                return strs[0].substring(0, i);
            }
        }
    }
    // 如果遍历完第一个字符串，没有出现不匹配的情况，说明它本身就是最长公共前缀
    return strs[0];
};
```

### 151 翻转字符串里的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

> 移除首尾空格、把字符串分割成单词数组、将每个单词反转、合并

```js
var reverseWords = function(s) {
    // 先去除首尾空格trim()，然后按照正则表达式 \s+（匹配一个或多个空格），把字符串分割成单词数组，再反转数组reverse()，然后合并成字符串join(' ')
    const wordsArray = s.trim().split(/\s+/);
    const reversedString = wordsArray.reverse().join(' ');
    return reversedString;
};
```

> 移除多余空格、将整个字符串反转、将每个单词反转

```js
 var reverseWords = function(s) {
   // 字符串转数组
   const strArr = Array.from(s);
   // 移除多余空格
   removeExtraSpaces(strArr);
   // 翻转
   reverse(strArr, 0, strArr.length - 1);

   let start = 0;

   for(let i = 0; i <= strArr.length; i++) {
     if (strArr[i] === ' ' || i === strArr.length) {
       // 翻转单词
       reverse(strArr, start, i - 1);
       start = i + 1;
     }
   }

   return strArr.join('');
};

// 删除多余空格
function removeExtraSpaces(strArr) {
  let slowIndex = 0;
  let fastIndex = 0;

  while(fastIndex < strArr.length) {
    // 移除开始位置和重复的空格
    if (strArr[fastIndex] === ' ' && (fastIndex === 0 || strArr[fastIndex - 1] === ' ')) {
      fastIndex++;
    } else {
      strArr[slowIndex++] = strArr[fastIndex++];
    }
  }

  // 移除末尾空格
  strArr.length = strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex;
}

// 翻转从 start 到 end 的字符
function reverse(strArr, start, end) {
  let left = start;
  let right = end;

  while(left < right) {
    // 交换
    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];
    left++;
    right--;
  }
}
```

### 344 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

> 定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。

```js
var reverseString = function(s) {
    let left = 0;
    let right = s.length - 1;

    while (left < right) {
        // 交换字符
        [s[left], s[right]] = [s[right], s[left]];
        left++;
        right--;
    }
};
```

```js
var reverseString = function(s) {
    reverse(s)
};

var reverse = function(s) {
    let l = -1, r = s.length;
    while(++l < --r) [s[l], s[r]] = [s[r], s[l]];
};
```

```js
var reverseWords = function(s) {
    // 先分割成单词，对于每个单词，转换为字符数组，然后反转字符数组，最后再将字符数组连接成一个字符串 最后将所有反转后的单词数组连接成一个字符串
    return s.split(' ').map(item => item.split('').reverse().join('')).join(' ');
};
```

### 541 反转字符串II

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

> 在遍历字符串的过程中，i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。

```js
var reverseStr = function(s, k) {
    const len = s.length;
    let resArr = s.split(""); 
    for(let i = 0; i < len; i += 2 * k) {  
        // 每隔 2k 个字符的前 k 个字符进行反转
        let l = i - 1, r = i + k > len ? len : i + k;
        // l指向当前区间的前一个位置 因为while(++l < --r)要先自增再交换 所以从-1开始 
        // 如果 i + k 大于字符串的长度 len，那么 r 就被设为 len，否则 r 的值为 i + k
        while(++l < --r) [resArr[l], resArr[r]] = [resArr[r], resArr[l]];
    }
    return resArr.join("");
}
```

### # 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

```js
function replaceDigits(s) {
    let result = '';

    for (let i = 0; i < s.length; i++) {
        if (isNaN(s[i])) {
            // 如果当前字符不是数字，则直接追加到结果字符串
            result += s[i];
        } else {
            // 如果当前字符是数字，则追加 "number" 到结果字符串
            result += 'number';
        }
    }

    return result;
}
```

### # 右旋字符串

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

```js
function rotateString(s, k) {
    // 确保 k 在有效范围内
    k = k % s.length;
    // 如果 k 为 0 或者字符串为空，直接返回原字符串
    if (k === 0 || s.length === 0) {
        return s;
    }
    // 将字符串分成两部分，分别进行翻转
    const firstPart = s.slice(0, s.length - k);
    const secondPart = s.slice(s.length - k);
    // 将翻转后的两部分拼接在一起
    const rotatedString = secondPart + firstPart;
    return rotatedString;
}
```

### 28 [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle)
};
```

```js
var strStr = function (haystack, needle) {
    if (needle.length === 0)
        return 0;

    const getNext = (needle) => {
        let next = [];
        let j = 0;
        next.push(j);

        for (let i = 1; i < needle.length; ++i) {
            while (j > 0 && needle[i] !== needle[j])
                j = next[j - 1];
            if (needle[i] === needle[j])
                j++;
            next.push(j);
        }

        return next;
    }

    let next = getNext(needle);
    let j = 0;
    for (let i = 0; i < haystack.length; ++i) {
        while (j > 0 && haystack[i] !== needle[j])
            j = next[j - 1];
        if (haystack[i] === needle[j])
            j++;
        if (j === needle.length)
            return (i - needle.length + 1);
    }

    return -1;
};
```

### 459 [重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

```js
var repeatedSubstringPattern = function(s) {
    let ss=(s+s).substring(1, s.length*2-1)
    return ss.indexOf(s) !== -1
};
```

```js
var repeatedSubstringPattern = function (s) {
    if (s.length === 0)
        return false;

    const getNext = (s) => {
        let next = [];
        let j = 0;

        next.push(j);

        for (let i = 1; i < s.length; ++i) {
            while (j > 0 && s[i] !== s[j])
                j = next[j - 1];
            if (s[i] === s[j])
                j++;
            next.push(j);
        }

        return next;
    }

    let next = getNext(s);

    if (next[next.length - 1] !== 0 && s.length % (s.length - next[next.length - 1]) === 0)
        return true;
    return false;
};
```

## 06 数组去重

### 1、new Set() + Array.from

Set对象：是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即Set中的元素是唯一的。Set本身是一个构造函数，用来生成 Set 数据结构。类似于数组，不是真正的数组，不能使用 length 方法。

Array.from() 方法：对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

注意：以上去方式对NaN和undefined类型去重也是有效的，是因为NaN和undefined都可以被存储在Set中，NaN之间被视为相同的值（尽管在js中：`NaN !== NaN`）

​	    对 {} 无效

```js
const arr = [9, 2, 9, '123', '123', true, NaN, true, false, false, undefined, undefined, NaN, {}, {}]
let arrNew = [...new set(arr)] //new set(arr)返回的是set的实例 要变为数组
let arrNew = Array.from(new set(arr))
```

### 2、双层循环

注意：此方法对NaN是无法进行去重的，因为进行比较时`NaN !== NaN；` 对 {} 无效

```js
function getDisArray(arr) {
    let newArr = [];
    let len = arr.length
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            if (arr[i] === arr[j]) {
                j++
            }
        }
        newArr.push(arr[i]);
    }
    return newArr
}
```

```js
// 利用两层循环+数组的splice方法
function getDisArray(arr) {
    let len = arr.length
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            if (arr[i] === arr[j]) {
                arr.splice(j, 1) //数组塌陷
                len-- // 减少循环次数提高性能
                j-- // 保证j的值自加后不变
            }
        }
    }
    return arr
}
```

### 3、forEach + indexOf/includes

新建一个空数组，遍历需要去重的数组，将数组元素存入新数组中，存放前判断数组中是否已经含有当前元素，没有则存入。此方法也无法对`NaN`去重。

注意：对NaN是无法进行去重的；对 {} 无效

```js
function getDisArray(arr) {
    const newArr = []
    arr.forEach(item => {
        if (newArr.indexOf(item) === -1) { // 找不到此元素
            newArr.push(item)
        }
        /*
        if (!newArr.includes(item)) {
            newArr.push(item)
        }        
        */
    })
    return newArr // 返回一个新数组
}
```

### 4、forEach + Map

注意：使用`Map()`也可对`NaN`去重，原因是Map进行判断时认为`NaN`是与`NaN`相等的，剩下所有其它的值是根据 `===` 运算符的结果判断是否相等；对 {} 不能检测

```js
function getDisArray(arr) {
    const map = new Map()
    const newArr = []
    arr.forEach(item => {
        if (!map.has(item)) { // has()用于判断map是否包为item的属性值
            map.set(item, true) // 使用set()将item设置到map中，并设置其属性值为true
            newArr.push(item)
        }
    })
    return newArr
}
```

### 5、forEach + 对象属性名不可重复

其实现思想和Map()是差不多的，主要是利用了对象的属性名不可重复这一特性。

注意：可以对 NaN 和 {} 去重

```js
function getDisArray(arr) {
    const newArr = []
    const obj = {}
    arr.forEach(item => {
        if (!obj[item]) {
            newArr.push(item)
            obj[item] = true
    	}
	})
	return newArr
}
```
## 07 数组扁平化

- Array.prototype.flat(Infinity)

  ```js
  arr = arr.flat(Infinity)
  ```

- 转换为字符串

  ```js
  arr = JSON.toString().split(',').map(item => parseFloat(item))
  arr = JSON.stringify(arr).replace(/(\[|\])/g).map(item => parseFloat(item))
  ```

- 循环验证是否为数组 some

  ```js
  while(arr.some(item => Array.isArray(item))){
      arr = [].concat(...arr)
  }
  ```

# d3 栈

> 栈也是一种非常常见的数据结构, 并且在程序中的应用非常广泛.

## 01 认识栈结构

> 我们先来简单认识一下栈结构, 它的特点和应用场景等.

#### 栈结构

- 数组

  - 我们知道数组是一种线性结构, 并且可以在数组的任意位置插入和删除数据.
  - 但是有时候, 我们为了实现某些功能, 必须对这种任意性加以限制.
  - 而栈和队列就是比较常见的受限的线性结构, 我们先来学习栈结构.

- 栈（stack），它是一种运算受限的线性表，后进先出(LIFO)

  - LIFO(last in first out)表示就是后进入的元素, 第一个弹出栈空间. 类似于自动餐托盘, 最后放上的托盘, 往往先把拿出去使用.
  - 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。
  - 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
  - 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

- 生活中类似于栈的

  - 自助餐的托盘, 最新放上去的, 最先被客人拿走使用.
  - 收到很多的邮件(实体的), 从上往下依次处理这些邮件. (最新到的邮件, 最先处理)
  - 注意: 不允许改变邮件的次序, 比如从最小开始, 或者处于最紧急的邮件, 否则就不再是栈结构了. 而是队列或者优先级队列结构.

- 栈结构的图解

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-9253975a5d43fdb0?imageMogr2/auto-orient/strip|imageView2/2/w/614/format/webp)

- 程序中什么是使用栈实现的呢?
  - 学了这么久的编程, 是否听说过, 函数调用栈呢?
  - 我们知道函数之间和相互调用: A调用B, B中又调用C, C中又调用D.
  - 那样在执行的过程中, 会先将A压入栈, A没有执行完, 所有不会弹出栈.
  - 在A执行的过程中调用了B, 会将B压入到栈, 这个时候B在栈顶, A在栈底.
  - 如果这个时候B可以执行完, 那么B会弹出栈. 但是B有执行完吗? 没有, 它调用了C.
  - 所以C会压栈, 并且在栈顶. 而C调用了D, D会压入到栈顶.
  - 所以当前的栈顺序是: 栈顶A->B->C->D栈顶
  - D执行完, 弹出栈. C/B/A依次弹出栈.
  - 所以我们有函数调用栈的称呼, 就来自于它们内部的实现机制. (通过栈来实现的)

> 递归 栈溢出

- 函数调用栈图解:

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-1f906fb3ac002dd6?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp)

#### 栈面试题

- 面试题目:【一边进一边出】

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-be2dd008beb7c478?imageMogr2/auto-orient/strip|imageView2/2/w/562/format/webp)

- 题目答案: C

  - A答案: 65进栈, 5出栈, 4进栈出栈, 3进栈出栈, 6出栈, 21进栈,1出栈, 2出栈
  - B答案: 654进栈, 4出栈, 5出栈, 3进栈出栈, 2进栈出栈, 1进栈出栈, 6出栈
  - D答案: 65432进栈, 2出栈, 3出栈, 4出栈, 1进栈出栈, 5出栈, 6出栈

## 02 栈结构实现

- 基于数组实现
- 基于链表实现

> 我们来实现一个类, 用于模拟栈中的操作.

#### 栈的创建

- 我们先来创建一个栈的类, 用于封装栈相关的操作

  ```javascript
  // 栈类
  function Stack() {
      // 栈中的属性
      var items = []
      // 栈相关的方法
  }
  ```

- 代码解析:

  - 我们创建了一个Stack构造函数, 用户创建栈的类.
  - 在构造函数中, 定义了一个变量, 这个变量可以用于保存当前栈对象中所有的元素.
  - 这个变量是一个数组类型. 我们之后无论是压栈操作还是出栈操作, 都是从数组中添加和删除元素.
  - 栈有一些相关的操作方法, 通常无论是什么语言, 操作都是比较类似的.

#### 栈的操作

- 栈常见有哪些操作呢?

  - `push(element)`:  添加一个新元素到栈顶位置.
  - `pop()`：移除栈顶的元素，同时返回被移除的元素。
  - `peek()`：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。
  - `isEmpty()`：如果栈里没有任何元素就返回`true`，否则返回`false`。
  - `clear()`：移除栈里的所有元素。
  - `size()`：返回栈里的元素个数。这个方法和数组的`length`属性很类似。

- 现在我们来实现这些方法:

- push方法

  - 注意: 我们的实现是将最新的元素放在了数组的末尾, 那么数组末尾的元素就是我们的栈顶元素

  ```javascript
  // 压栈操作
  this.push = function (element) {
      items.push(element)
  }
  ```

- pop方法

  - 注意: 出栈操作应该是将栈顶的元素删除, 并且返回.
  - 因此, 我们这里直接从数组中删除最后一个元素, 并且将该元素返回就可以了

  ```javascript
  // 出栈操作
  this.pop = function (element) {
      return items.pop()
  }
  ```

- peek方法

  - peek方法是一个比较常见的方法, 主要目的是看一眼栈顶的元素.
  - 注意: 和pop不同, peek仅仅的瞥一眼栈顶的元素, 并不需要将这个元素从栈顶弹出.

  ```javascript
  // peek操作
  this.peek = function () {
      return items[items.length - 1]
  }
  ```

- isEmpty方法

  - isEmpty方法用户判断栈中是否有元素.
  - 实现起来非常简单, 直接判断数组中的元素个数是为0, 为0返回true, 否则返回false

  ```javascript
  // 判断栈中的元素是否为空
  this.isEmpty = function () {
      return items.length == 0
  }
  ```

- size方法

  - size方法是获取栈中元素的个数.
  - 因为我们使用的是数组来作为栈的底层实现的, 所以直接获取数组的长度即可.(也可以使用链表作为栈的顶层实现)

  ```javascript
  // 获取栈中元素的个数
  this.size = function () {
      return items.length
  }
  ```

#### 完整代码

- 下面我们给出自定义栈的完整代码:

  - 注意: 这里我们为了将属性方法放在一起, 没有使用原型来封装方法.

  ```javascript
  // 栈类
  function Stack() {
      // 栈中的属性
      var items = []
  
      // 栈相关的方法
      // 压栈操作 给实例
      this.push = function (element) {
          items.push(element)
      }
      Stack.prototype.push = function(element){
          this.items.push(element)
      }  //可以共享 效率更高
  
      // 出栈操作
      this.pop = function () {
          return items.pop()
      }
      Stack.prototype.pop = function(){
          this.items.pop()
      }
  
      // peek操作
      this.peek = function () {
          return items[items.length - 1]
      }
      Stack.prototype.peek = function(){
          return this.items[this.items.length - 1]
      }
  
      // 判断栈中的元素是否为空
      this.isEmpty = function () {
          return items.length == 0
      }
      Stack.prototype.isEmpty  = function(){
   		return this.items.length == 0
      }
  
      // 获取栈中元素的个数
      this.size = function () {
          return items.length
      }
  	Stack.prototype.size  = function(){
   		return this.items.length
      }
      
      //toString
  	Stack.prototype.toString  = function(){
          var resultString = ''
   		for(var i =0;i<this.items.length;i++){
              resultString += this.items[i] + ''
          }
          return resultString
      }
      
  }
  ```

#### 栈的使用

- 我们来使用封装的栈, 模拟刚才的面试题

  - 我们做了一下A, 其他大家可以自己练习一下.
  - C是无法使用栈来模拟的, 因为不正确的是C

  ```javascript
  // 模拟面试题
  var stack = new Stack()
  
  // 情况下代码模拟
  stack.push(6)
  stack.push(5)
  stack.pop()     // 5
  stack.push(4)
  stack.pop()     // 4
  stack.push(3)
  stack.pop()     // 3
  stack.pop()     // 6
  stack.push(2)
  stack.push(1)
  stack.pop()     // 1
  stack.pop()     // 2
  ```

## 03 栈结构应用

> 我们已经学会了如何使用`Stack`类，现在就用它解决一些计算机科学中的问题。

#### 十进制转二进制

- 为什么需要十进制转二进制?

  - 现实生活中，我们主要使用十进制。
  - 但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。
  - 没有十进制和二进制相互转化的能力，与计算机交流就很困难。

- 如何实现十进制转二进制?

  - 要把十进制转化成二进制，我们可以将该十进制数字和2整除（二进制是满二进一），直到结果是0为止。

  - 举个例子，把十进制的数字10转化成二进制的数字，过程大概是这样：

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-30bb14e53bde4bea?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

- 如果我们希望使用代码来实现这个功能呢?

  ```javascript
  // 封装十进制转二进制的函数
  function dec2bin(decNumer) {
      // 定义栈对象 余数压入栈 
      var stack = new Stack()
      // 存余数
      var remainder;
  
      // 循环除法
      while (decNumer > 0) {
          // 将余数压入栈
          remainder = decNumer % 2
          stack.push(remainder)
          // 整除后结果 作为下一次运行的数字
          decNumer = Math.floor(decNumer / 2)
      }
  
      // 从栈中取出0和1
      var binayriStrng = ""
      while (!stack.isEmpty()) {
          binayriStrng += stack.pop()
      }
      return binayriStrng
  }
  ```

- 测试代码:

  ```javascript
  // 测试函数
  alert(dec2bin(10))
  alert(dec2bin(233))
  alert(dec2bin(1000))
  ```

# d4 队列

> 我们已经学习了一种受限的线性结构: 栈结构. 并且已经知道这种受限的数据结构对于解决某些特定问题, 会有特别的效果.
>
> 下面, 我们再来学习另外一个受限的数据结构: 队列. 它也是一种受限的线性结构.

## 01 认识队列

> 我们也先来认识一下队列, 看看它的特点和应用场景等.

- 队列(Queue)，它是一种运算受限的线性表，先进先出(FIFO First In First Out)

  - 队列是一种受限的线性结构
  - 受限之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作

- 生活中类似的队列结构

  - 生活中类似队列的场景就是非常多了, 比如在电影院, 商场, 甚至是厕所排队.
  - 优先排队的人, 优先处理. (买票, 结账, WC)

- 队列的图解

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-c0831650ed9943aa?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  img

- 队列在程序中的应用

  - 打印队列:
    - 有五份文档需要打印, 这些文档会按照次序放入到打印队列中.
    - 打印机会依次从队列中取出文档, 优先放入的文档, 优先被取出, 并且对该文档进行打印.
    - 以此类推, 直到队列中不再有新的文档.
  - 线程队列:
    - 在进行多线程开发时, 我们不可能无限制的开启新的线程.
    - 这个时候, 如果有需要开启线程处理任务的情况, 我们就会使用线程队列.
    - 线程队列会依照次序来启动线程, 并且处理对应的任务.

## 02 队列实现

> 我们来实现一个类, 用于模拟队列中的操作

#### 队列的创建

- 我们需要创建自己的类, 来表示一个队列

  ```javascript
  // 自定义队列
  function Queue() {
      var items = []
      // 队列操作的方法
  }
  ```

- 代码解析:

  - 我们创建了一个Queue构造函数, 用户创建队列的类.
  - 在构造函数中, 定义了一个变量, 这个变量可以用于保存当前队列对象中所有的元素. (和创建栈非常相似)
  - 这个变量是一个数组类型. 我们之后在队列中添加元素或者删除元素, 都是在这个数组中完成的.
  - 队列和栈一样, 有一些相关的操作方法, 通常无论是什么语言, 操作都是比较类似的.

#### 队列的操作

- 队列有哪些常见的操作呢?

  - `enqueue(element)`：向队列尾部添加一个（或多个）新的项。
  - `dequeue()`：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。
  - `front()`：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与`Stack`类的`peek`方法非常类似）。
  - `isEmpty()`：如果队列中不包含任何元素，返回`true`，否则返回`false`。
  - `size()`：返回队列包含的元素个数，与数组的`length`属性类似。

- 现在, 我们来实现这些方法. (其实已经比较简单了)

- enqueue方法

  ```javascript
  // enter queue方法
  this.enqueue = function (element) {
      items.push(element)
  }
  ```

- dequeue方法

  - 注意: 从队列中删除元素不可以删除最后一个元素了.
  - 因为, 先进入队列中的元素, 先从队列中取出. 因此, 应该删除第一个元素

  ```javascript
  // delete queue方法
  this.dequeue = function () {
      return items.shift()
  }
  ```

- front()方法

  ```javascript
  // 查看前端的元素
  this.front = function () {
      return items[0]
  }
  ```

- isEmpty方法

  ```javascript
  // 查看队列是否为空
  this.isEmpty = function () {
      return items.length == 0
  }
  ```

- size方法

  ```javascript
  // 查看队列中元素的个数
  this.size = function () {
      return items.length
  }
  ```

#### 完整的代码

- 我们来看一下队列完整的代码

  ```javascript
  // 自定义队列
  function Queue() {
      var items = []
  
      // 队列操作的方法
      // enter queue方法
      this.enqueue = function (element) {
          items.push(element)
      }
      Queue.prototype.enqueue  = function(element){
          return this.items.push(element)
      }
          
      // delete queue方法 fifo pop删除最后一个
      this.dequeue = function () {
          return items.shift()
      }
      
          Queue.prototype.dequeue  = function(){
          return this.items.shift()
      }
  
      // 查看前端的元素
      this.front = function () {
          return items[0]
      }
      
          Queue.prototype.front  = function(){
          return this.items[0]
      }
      // 查看队列是否为空
      this.isEmpty = function () {
          return items.length == 0
      }
      
          Queue.prototype.isEmpty  = function(){
          return this.items.length == 0
      }
  
      // 查看队列中元素的个数
      this.size = function () {
          return items.length
      }
      
          Queue.prototype.size  = function(){
          return this.items.length
      }
      
      //toString
  	Queue.prototype.toString  = function(){
          var resultString = ''
   		for(var i =0;i<this.items.length;i++){
              resultString += this.items[i] + ''
          }
          return resultString
      }
  }
  }
  ```

#### 队列的使用

- 我们来简单使用一下我们封装的Queue

  ```javascript
  // 创建队列对象
  var queue = new Queue()
  
  // 在队列中添加元素
  queue.enqueue("abc")
  queue.enqueue("cba")
  queue.enqueue("nba")
  
  // 查看一下队列前端元素
  alert(queue.front())
  
  // 查看队列是否为空和元素个数
  alert(queue.isEmpty())
  alert(queue.size())
  
  // 从队列中删除元素
  alert(queue.dequeue())
  alert(queue.dequeue())
  alert(queue.dequeue())
  ```

## 03 优先级队列

> 前面, 我们实现了一种普通的队列. 队列中元素的处理顺序和插入的顺序密切相关.
>
> 但是, 还有一种比较常见的场景是和插入顺序无关, 而和元素本身的优先级有关系的队列.
>
> 这种队列就是优先级队列.

#### 优先级队列的介绍

- 优先级队列的特点:
  - 我们知道, 普通的队列插入一个元素, 数据会被放在后端. 并且需要前面所有的元素都处理完成后才会处理前面的数据.
  - 但是优先级队列, 在插入一个元素的时候会考虑该数据的优先级.(和其他数据优先级进行比较)
  - 比较完成后, 可以得出这个元素正确的队列中的位置. 其他处理方式, 和队列的处理方式一样.
  - 也就是说, 如果我们要实现优先级队列, 最主要是要修改添加方法. (当然, 还需要以某种方式来保存元素的优先级)
- 优先级队列应用也非常广泛
  - 一个现实的例子就是机场登机的顺序
    - 头等舱和商务舱乘客的优先级要高于经济舱乘客。
    - 在有些国家，老年人和孕妇（或带小孩的妇女）登机时也享有高于其他乘客的优先级。
  - 另一个现实中的例子是医院的（急诊科）候诊室。
    - 医生会优先处理病情比较严重的患者。
    - 通常，护士会鉴别分类，根据患者病情的严重程度放号。
  - 计算机中, 我们也可以通过优先级队列来重新排序队列中任务的顺序
    - 比如每个线程处理的任务重要性不同, 我们可以通过优先级的大小, 来决定该线程在队列中被处理的次序.

#### 优先级队列的实现

- 实现优先级队列相对队列主要有两方面需要考虑:

  - 1. 封装元素和优先级放在一起(可以封装一个新的构造函数)
  - 1. 添加元素时, 将当前的优先级和队列中已经存在的元素优先级进行比较, 以获得自己正确的位置.

- 优先级队列代码实现:

  ```javascript
  // 封装优先级队列
  function PriorityQueue() {
      var items = []
  
      // 封装一个新的构造函数, 用于保存元素和元素的优先级
      function QueueElement(element, priority) {
          this.element = element
          this.priority = priority
      }
  
      // 添加元素的方法
      this.enqueue = function (element, priority) {
          // 1.根据传入的元素, 创建新的QueueElement
          var queueElement = new QueueElement(element, priority)
  
          // 2.获取传入元素应该在正确的位置
          if (this.isEmpty()) {
              items.push(queueElement)
          } else {
              var added = false
              for (var i = 0; i < items.length; i++) {
                  // 注意: 我们这里是数字越小, 优先级越高
                  if (items[i].priority > queueElement.priority) {
                      items.splice(i, 0, queueElement)  
                      added = true
                      break;
                  }
              }
              // 遍历完所有的元素, 优先级都大于新插入的元素时, 就插入到最后
              if (!added) {
                  items.push(queueElement)
              }
          }
      }
  ```
  
- 代码解析:

  - 封装了一个QueueElement, 将element和priority封装在一起.
  - 在插入新的元素时, 有如下情况下考虑:
    - 根据新的元素先创建一个新的QueueElement对象.
    - 如果元素是第一个被加进来的, 那么不需要考虑太多, 直接加入数组中即可.
    - 如果是后面加进来的元素, 需要和前面加进来的元素依次对比优先级.
    - 一旦优先级, 大于某个元素, 就将该元素插入到元素这个元素的位置. 其他元素会依次向后移动.
    - 如果遍历了所有的元素, 没有找到某个元素被这个新元素的优先级低, 直接放在最后即可.

#### 优先级队列的使用

- 我们来简单使用一下我们的优先级队列.

  ```javascript
  // 创建优先级队列对象
  var pQueue = new PriorityQueue()
  
  // 添加元素
  pQueue.enqueue("abc", 10)
  pQueue.enqueue("cba", 5)
  pQueue.enqueue("nba", 12)
  pQueue.enqueue("mba", 3)
  
  // 遍历所有的元素
  var size = pQueue.size()
  for (var i = 0; i < size; i++) {
      var item = pQueue.dequeue()
      alert(item.element + "-" + item.priority)
  }
  ```

## 04 队列实现击鼓传花

> 击鼓传花是一个常见的面试算法题. 使用队列可以非常方便的实现最终的结果.

#### 击鼓传花的规则

- 原游戏规则:
  - 班级中玩一个游戏, 所有学生围成一圈, 从某位同学手里开始向旁边的同学传一束花.
  - 这个时候某个人(比如班长), 在击鼓, 鼓声停下的一颗, 花落在谁手里, 谁就出来表演节目.
- 修改游戏规则:
  - 我们来修改一下这个游戏规则.
  - 几个朋友一起玩一个游戏, 围成一圈, 开始数数, 数到某个数字的人自动淘汰.
  - 最后剩下的这个人会获得胜利, 请问最后剩下的是原来在哪一个位置上的人?

#### 击鼓传花的实现

- 我们使用队列可以非常方便的实现这个代码.

- 封装函数

  ```javascript
  // 实现击鼓传花的函数
  function passGame(nameList, num) {
      // 1.创建一个队列, 并且将所有的人放在队列中
      // 1.1.创建队列
      var queue = new Queue()
      
      // 1.2.通过for循环, 将nameList中的人放在队列中
      for (var i = 0; i < nameList.length; i++) {
          queue.enqueue(nameList[i])
      }
  
      // 2.开始数数字 寻找最后剩下的人
      // 队列中只剩一个人才停止
      while (queue.size() > 1) {
          // 将前num-1中的人, 都从队列的前端取出放在队列的后端 
          for (var i = 0; i < num; i++) {
              queue.enqueue(queue.dequeue()) //从前面删除 将这个元素在加到队列末尾
          }
          // i=num 将第num个人, 从队列中移除
          queue.dequeue()
      }
  
      // 3.获取剩下的一个人
      alert(queue.size())
      var endName = queue.front()
      alert("最终留下来的人:" + endName)
  
      // 4.获取该人在队列中的位置
      return nameList.indexOf(endName)
  }
  ```
  
- 代码验证:

  ```javascript
  // 验证结果
  var names = ['John','Jack','Camila','Ingrid','Carl'];
  var index = passGame(names, 7) // 数到8的人淘汰
  alert("最终位置:" + index)
  ```
  
- 画图解析上面淘汰的过程

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-9a98df9bc67f6352?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

## 05 栈&队列&Leetcode

### 20 [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

> 不匹配的情况：第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false。
>
> 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false。
>
> 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false。

```js
var isValid = function(s) {
  let stack = []
  for (let i = 0; i < s.length; i++) {
    if (s[i] == '(') stack.push(')')
    else if (s[i] == '[') stack.push(']')
    else if (s[i] == '{') stack.push('}')
    // 通过 stack.pop() 弹出栈顶元素，然后将它与当前字符比较
    else if (s[i] != stack.pop()) return false
  }
  return stack.length == 0
};
```

```js
var isValid = function(s) {
    const stack = [], 
        map = {
            "(":")",
            "{":"}",
            "[":"]"
        };
    // 遍历输入字符串 s 中的每个字符
    for(const x of s) {
        // 如果当前字符在 map 对象中，即为开放的括号
        if(x in map) {
            // 将当前字符推入栈中
            stack.push(x);
            // 继续处理下一个字符
            continue;
        };
        // 如果当前字符不是开放括号，则为闭合括号
        // 弹出栈顶的开放括号，并检查其对应的闭合括号是否与当前字符匹配
        if(map[stack.pop()] !== x) 
            // 若不匹配，则表示括号不配对，返回 false
            return false;
    }
    return !stack.length;
};
```

### 1047 [删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

> 使用栈

![1047.删除字符串中的所有相邻重复项](https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif)

```js
var removeDuplicates = function(s) {  
    const result = []  // 创建一个空数组 result，用来存储去重后的字符
    for(const i of s){  // 遍历字符串 s 中的每个字符，将其存储在变量 i 中
        if(i === result[result.length-1]){  // 如果当前字符 i 与 result 数组的最后一个字符相同
            result.pop()  // 则移除 result 数组的最后一个字符，实现去重
        } else {  // 如果当前字符 i 与 result 数组的最后一个字符不同
            result.push(i)  // 则将当前字符 i 加入 result 数组，保留该字符
        }
    }
    return result.join('')  // 返回去重后的字符，通过 join 方法将数组 result 中的字符连接成字符串
};
```

> 双指针（模拟栈）

```js
// 原地解法（双指针模拟栈）
var removeDuplicates = function(s) {  
    let top = -1; // 指向栈顶元素的下标，初始值为 -1，表示空栈
    for(let i = 0; i < s.length; i++) {  // 遍历字符串 s 中的每个字符
        if(top === -1 || s[top] !== s[i]) { // 如果栈为空或者栈顶元素与当前字符不同
            s[++top] = s[i]; // 将当前字符入栈，并将 top 指向栈顶元素
        } else { // 如果栈不为空且栈顶元素与当前字符相同
            top--; // 则将栈顶元素推出栈，相当于移除重复的字符
        }
    }
    s.length = top + 1; // 栈顶元素下标 + 1 为栈的长度，将数组 s 的长度截取为栈的长度
    return s.join(''); // 将数组 s 中的字符连接成字符串并返回
};
```

### 150 [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

```js
var evalRPN = function (tokens) {
    const stack = [];
    for (const token of tokens) {
        if (isNaN(Number(token))) { // 非数字
            const n2 = stack.pop(); // 出栈两个数字
            const n1 = stack.pop();
            switch (token) { // 判断运算符类型，算出新数入栈
                case "+":
                    stack.push(n1 + n2);
                    break;
                case "-":
                    stack.push(n1 - n2);
                    break;
                case "*":
                    stack.push(n1 * n2);
                    break;
                case "/":
                    stack.push(n1 / n2 | 0);
                    break;
            }
        } else { // 数字
            stack.push(Number(token));
        }
    }
    return stack[0]; // 因没有遇到运算符而待在栈中的结果
};
```

```js
var evalRPN = function(tokens) {  
    const stack = []  // 创建一个空栈，用于存储操作数
    for (const i of tokens) {  // 遍历 tokens 数组中的每个元素
        if (!isNaN(-i)) stack.push(i)  // 如果当前元素是数字，则将其入栈
        else if (i === '+') stack.push(+stack.pop() + +stack.pop())  
        // 如果当前元素是加号，则从栈中弹出两个数转换为数字类型后相加，并将结果入栈
        else if (i === '-') stack.push(-stack.pop() + +stack.pop())  
        else if (i === '*') stack.push(+stack.pop() * stack.pop())  
        else if (i === '/') (stack.push(1/stack.pop() * stack.pop() | 0))  
    }
    return stack[0]  // 返回栈顶元素，即最终的计算结果
};
```

### 239 [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

```js
var maxSlidingWindow = function (nums, k) {
    class MonoQueue {
        queue;
        constructor() {
            this.queue = [];
        }
        enqueue(value) {
            let back = this.queue[this.queue.length - 1];
            while (back !== undefined && back < value) {
                this.queue.pop();
                back = this.queue[this.queue.length - 1];
            }
            this.queue.push(value);
        }
        dequeue(value) {
            let front = this.front();
            if (front === value) {
                this.queue.shift();
            }
        }
        front() {
            return this.queue[0];
        }
    }
    let helperQueue = new MonoQueue();
    let i = 0, j = 0;
    let resArr = [];
    while (j < k) {
        helperQueue.enqueue(nums[j++]);
    }
    resArr.push(helperQueue.front());
    while (j < nums.length) {
        helperQueue.enqueue(nums[j]);
        helperQueue.dequeue(nums[i]);
        resArr.push(helperQueue.front());
        i++, j++;
    }
    return resArr;
};
```

```js
var maxSlidingWindow = function(nums, k) {
    // 初始化一个空数组 res 用于存储结果
    const res = []
    // 初始化一个空的双端队列 deque
    const deque = []
    // 获取数组 nums 的长度
    const len = nums.length

    // 使用 for 循环遍历数组中的每个元素
    for (let i = 0; i < len; i++) {
        // 维持一个递减队列，确保队列的前端保存着当前窗口中的最大元素的索引
        // 如果队尾元素比将要入队的元素小，就要逐个出队，直到队列为空或队尾元素大于等于当前元素
        while(deque.length && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop()
        }
        // 将当前元素的索引推入双端队列
        deque.push(i)

        // 确保双端队列中的元素位于当前窗口范围内
        // 如果队列的前端元素超出窗口范围，则从队列前端删除元素
        while(deque.length && deque[0] <= i - k) {
            // 移除数组的第一个元素
            deque.shift()
        }

        // 如果当前索引大于等于 k - 1（表示当前窗口的大小至少为 k）
        // 则将当前窗口的最大元素（即双端队列的前端元素）推入结果数组 res 中
        if (i >= k - 1) {
            res.push(nums[deque[0]])
        }
    }
    // 返回结果数组 res
    return res
};

```

### 347 [前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

```js
// js 没有堆 需要自己构造
class Heap {
    constructor(compareFn) {
        this.compareFn = compareFn;
        this.queue = [];
    }

    // 添加
    push(item) {
        // 推入元素
        this.queue.push(item);

        // 上浮
        let index = this.size() - 1; // 记录推入元素下标
        let parent = Math.floor((index - 1) / 2); // 记录父节点下标

        while (parent >= 0 && this.compare(parent, index) > 0) { // 注意compare参数顺序
            [this.queue[index], this.queue[parent]] = [this.queue[parent], this.queue[index]];

            // 更新下标
            index = parent;
            parent = Math.floor((index - 1) / 2);
        }
    }

    // 获取堆顶元素并移除
    pop() {
        // 堆顶元素
        const out = this.queue[0];

        // 移除堆顶元素 填入最后一个元素
        this.queue[0] = this.queue.pop();

        // 下沉
        let index = 0; // 记录下沉元素下标
        let left = 1; // left 是左子节点下标 left + 1 则是右子节点下标
        let searchChild = this.compare(left, left + 1) > 0 ? left + 1 : left;

        while (searchChild !== undefined && this.compare(index, searchChild) > 0) { // 注意compare参数顺序
            [this.queue[index], this.queue[searchChild]] = [this.queue[searchChild], this.queue[index]];

            // 更新下标
            index = searchChild;
            left = 2 * index + 1;
            searchChild = this.compare(left, left + 1) > 0 ? left + 1 : left;
        }

        return out;
    }

    size() {
        return this.queue.length;
    }

    // 使用传入的 compareFn 比较两个位置的元素
    compare(index1, index2) {
        // 处理下标越界问题
        if (this.queue[index1] === undefined) return 1;
        if (this.queue[index2] === undefined) return -1;

        return this.compareFn(this.queue[index1], this.queue[index2]);
    }

}

const topKFrequent = function (nums, k) {
    const map = new Map();

    for (const num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
    }

    // 创建小顶堆
    const heap= new Heap((a, b) => a[1] - b[1]);

    // entry 是一个长度为2的数组，0位置存储key，1位置存储value
    for (const entry of map.entries()) {
        heap.push(entry);

        if (heap.size() > k) {
            heap.pop();
        }
    }

    // return heap.queue.map(e => e[0]);

    const res = [];

    for (let i = heap.size() - 1; i >= 0; i--) {
        res[i] = heap.pop()[0];
    }

    return res;
};
```

```js
var topKFrequent = function(nums, k) {
    // 创建一个空对象 map，用于存储每个元素及其出现的频率
    let map = {};
    // 遍历数组 nums，统计每个元素出现的频率并存储在 map 对象中
    for(let num of nums) {
        if(map[num]) map[num]++;
        else map[num] = 1;
    }
    
    // 创建一个空数组 resArr，用于存储元素及其对应的频率作为键值对的数组
    let resArr = [];
    // 遍历 map 对象，将键值对转换为数组，并存储在 resArr 数组中
    for(let key in map){
        resArr.push([parseInt(key), map[key]]);
    }
    // 对 resArr 数组按照元素频率进行降序排序
    resArr.sort((a, b) => b[1] - a[1]);
    // 初始化 index 变量为 k - 1，用于确定返回结果的索引范围
    let index = k - 1;
    // 若 index + 1 位置的元素频率与 index 位置的元素频率相同，则继续向后移动 index
    while(index + 1 < resArr.length && resArr[index][1] === resArr[index + 1][1])
        index++;
    
    // 创建一个空数组 res，用于存储返回结果
    let res = [], i = 0;
    // 将 resArr 数组中前 index + 1 个元素的键值对中的键（元素）存储到 res 数组中
    while(i <= index) {
        res.push(resArr[i][0]); 
        i++;
    }
    // 返回结果数组 res
    return res;
};
```

> 首先，通过遍历数组统计每个元素出现的频率，并使用 Map 对象进行存储。然后，将 Map 转换为数组，按照元素频率进行降序排序，并截取前 `k` 个元素。最后，返回这 `k` 个出现频率最高的元素组成的数组。

```js
var topKFrequent = function(nums, k) {
    // 创建一个新的 Map 对象 map，用于存储元素及其出现的频率
    let map = new Map();
    // 遍历数组 nums
    for(let i = 0; i < nums.length; i++){
        // 如果 map 中已经存在当前元素，则将其对应的频率加一
        if(map.has(nums[i])){
            let n = map.get(nums[i]);
            n++;
            map.set(nums[i], n);
        } else {
            // 如果 map 中不存在当前元素，则将其加入 map 中，并将其频率初始化为 1
            map.set(nums[i], 1);
        }
    }

    // 将 Map 对象转换为数组，并按照元素频率进行降序排序，然后取前 k 个元素
    let arr = Array.from(map)
        .sort((a, b) => b[1] - a[1])
        .slice(0, k);
    
    // 返回数组 arr 中的元素，即前 k 个出现频率最高的元素
    return arr.map(item => item[0]);
};
```

# d5 单向链表

> 我们先来认识一下链表, 看一下它大概的机制和原理, 以及和数组的对比.

## 01 认识链表

#### 链表和数组

- 数组:
  - 要存储多个元素，数组（或列表）可能是最常用的数据结构。
  - 我们之前说过, 几乎每一种编程语言都有默认实现数组结构, 这种数据结构非常方便，提供了一个便利的`[]`语法来访问它的元素。
  - 但是数组也有很多缺点:
    - 数组的创建通常需要申请一段连续的内存空间(一整块的内存), 并且大小是固定的(大多数编程语言数组都是固定的), 所以当当前数组不能满足容量需求时, 需要扩容. (一般情况下是申请一个更大的数组, 比如2倍. 然后将原数组中的元素复制过去)
    - 而且在数组开头或中间位置插入数据的成本很高, 需要进行大量元素的位移.（尽管我们已经学过的JavaScript的`Array`类方法可以帮我们做这些事，但背后的原理依然是这样）。
- 链表
  - 要存储多个元素, 另外一个选择就是使用链表.
  - 但不同于数组, 链表中的元素在内存中不必是连续的空间.
  - 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针或者链接)组成.
  - 相对于数组, 链表有一些优点:
    - 内存空间不是比是连续的. 可以充分利用计算机的内存. 实现灵活的内存动态管理.
    - 链表不必在创建时就确定大小, 并且大小可以无限的延伸下去.
    - 链表在插入和删除数据时, 时间复杂度可以达到O(1). 相对数组效率高很多.
  - 相对于数组, 链表有一些缺点:
    - 链表访问任何一个位置的元素时, 都需要从头开始访问.(无法跳过第一个元素访问任何一个元素).
    - 无法通过下标直接访问元素, 需要从头一个个访问, 直到找到对应的问题.

#### 什么是链表?

- 什么是链表呢?

  - 其实上面我们已经简单的提过了链表的结构, 我们这里更加详细的分析一下.

  - 链表类似于火车: 有一个火车头, 火车头会连接一个节点, 节点上有乘客, 并且这个节点会连接下一个节点, 以此类推.

  - 链表的火车结构:

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-d86fb9a276e1e453?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 链表的数据结构

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-60054021beaac344?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 给火车加上数据后的结构

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-066c59b695fcf2ed?imageMogr2/auto-orient/strip|imageView2/2/w/522/format/webp)

    img

## 02 链表封装

> 前面我们已经认识了链表结构, 现在通过代码来封装自己的链表吧.

#### 创建链表类

- 我们先来创建一个链表类

  ```javascript
  // 封装链表的构造函数
  function LinkedList() {
      // 封装一个Node类, 用于保存每个节点信息
      function Node(element) {
          this.element = element
          this.next = null
      }
  
      // 链表中的属性
      this.length = 0  // 链表的长度
      this.head = null // 链表的第一个节点
      
      // 链表中的方法
  }
  ```
  
- 代码解析:

  - 封装LinkedList的类, 用于表示我们的链表结构. (和Java中的链表同名, 不同Java中的这个类是一个双向链表, 后面我们会讲解双向链表)
  - 在LinkedList类中有一个Node类, 用于封装每一个节点上的信息.(和优先级队列的封装一样)
  - 链表中我们保存两个属性, 一个是链表的长度, 一个是链表中第一个节点.
  - 当然, 还有很多链表的操作方法. 我们放在下一节中学习.

#### 链表常见操作

- 我们先来认识一下, 链表中应该有哪些常见的操作
  - `append(element)`：向列表尾部添加一个新的项
  - `insert(position, element)`：向列表的特定位置插入一个新的项。
  - `remove(element)`：从列表中移除一项。
  - `indexOf(element)`：返回元素在列表中的索引。如果列表中没有该元素则返回`-1`。
  - `removeAt(position)`：从列表的特定位置移除一项。
  - `isEmpty()`：如果链表中不包含任何元素，返回`true`，如果链表长度大于0则返回`false`。
  - `size()`：返回链表包含的元素个数。与数组的`length`属性类似。
  - `toString()`：由于列表项使用了`Node`类，就需要重写继承自JavaScript对象默认的`toString`方法，让其只输出元素的值。
- 方法解读:
  - 整体你会发现操作方法和数组非常类似, 因为链表本身就是一种可以代替数组的结构.
  - 但是某些方法实现起来有些麻烦, 所以我们一个个来慢慢实现它们.

## 03 链表操作

#### 尾部追加数据/append

- 向链表尾部追加数据可能有两种情况:

  - 链表本身为空, 新添加的数据时唯一的节点.
  - 链表不为空, 需要向其他节点后面追加节点.

- append方法实现

  ```javascript
  // 链表尾部追加元素方法
  LinkedList.prototype.append = function (element) {
      // 1.根据新元素创建节点
      var newNode = new Node(element)
  
      // 2.判断原来链表是否为空
      if (this.head === null) { // 链表为空
          this.head = newNode
      } else { // 链表不为空
          // 2.1.定义变量, 保存当前找到的节点
          var current = this.head
          while (current.next) {
              current = current.next
          }
          // 2.2.找到最后一项, 将其next赋值为node
          current.next = newNode
      }
      // 3.链表长度增加1
      this.length++
  }
  ```
  
- 代码解读:

  - 首先需要做的是将element传入方法, 并根据element创建一个Node节点.

  - 场景一:  链表本身是空的, 比如这种情况下我们插入了一个15作为元素.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-379df36cd02a31dc?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 场景二: 链表中已经有元素了, 需要向最后的节点的next中添加节点.

    - 这个时候要向链表的尾部添加一个元素, 首先我们需要找到这个尾部元素.
    - 记住: 我们只有第一个元素的引用, 因此需要循环访问链表, 直接找到最后一个项.(见代码2.1)
    - 找到最后一项后, 最后一项的next为null, 这个时候不让其为null, 而是指向新创建的节点即可.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-632feb2d5e61f3f6?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 最后, 一定不要忘记将链表的length+1.

#### toString方法

- 我们先来实现一下链表的toString方法, 这样会方便测试上面的添加代码

  ```javascript
  // 链表的toString方法
  LinkedList.prototype.toString = function () {
      // 1.定义两个变量
      var current = this.head
      var listString = ""
  
      // 2.循环获取链表中所有的元素
      while (current) {
          listString += "," + current.element
          current = current.next
      }
  
      // 3.返回最终结果
      return listString.slice(1)
  }
  ```
  
- 方法解读:

  - 该方法比较简单, 主要是获取每一个元素
  - 还是从head开头, 因为获取链表的任何元素都必须从第一个节点开头.
  - 循环遍历每一个节点, 并且取出其中的element, 拼接成字符串.
  - 将最终字符串返回.

- 测试append方法

  ```javascript
  // 测试链表
  // 1.创建链表
  var list = new LinkedList()
  
  // 2.追加元素
  list.append(15)
  list.append(10)
  list.append(20)
  
  // 3.打印链表的结果
  alert(list)
  ```

#### 任意位置插入/insert

- 接下来实现另外一个添加数据的方法: 在任意位置插入数据.

  ```javascript
  // 根据下标删除元素
  LinkedList.prototype.insert = function (position, element) {
      // 1.检测越界问题: 越界插入失败
      if (position < 0 || position > this.length) return false
  
      // 2.创建新节点
      var newNode = new Node(element)
      
      // 3.判断是否列表是否在第一个位置插入
      if (position == 0) {
          newNode.next = this.head //新节点的next指向head指向的
          this.head = newNode //head指向新节点
      } else {
          let index = 0
          let current = this.head
          let previous = null
          while (index++ < position) {
              previous = current
              current = current.next
          }
          newNode.next = current
          previous.next = newNode
      }
      
      // 4.length+1
      this.length++
      
      return true
  }
  ```
  
- 代码解读:

  - 代码1的位置, 我们处理了越界问题, 基本传入位置信息时, 都需要进行越界的判断. 如果越界, 返回false, 表示数据添加失败. (因为位置信息是错误的, 所以数据肯定是添加失败的)

  - 代码2的位置, 我们定义了一些变量, 后续需要使用它们来保存信息.

  - 代码3的位置进行了判断, 这是因为添加到第一个位置和其他位置是不同的.

  - 添加到第一个位置:

    - 添加到第一个位置, 表示新添加的节点是头, 就需要将原来的头节点, 作为新节点的next
    - 另外这个时候的head应该指向新节点.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-aac2ba6ea3d96f2a?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 添加到其他位置:

    - 如果是添加到其他位置, 就需要先找到这个节点位置了.
    - 我们通过while循环, 一点点向下找. 并且在这个过程中保存上一个节点和下一个节点.
    - 找到正确的位置后, 将新节点的next指向下一个节点, 将上一个节点的next指向新的节点.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-a13a75528fd270ae?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-b15b9631aa1cf404?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 最后, 不要忘记length+1

  - 返回true, 表示元素插入成功了.

- 测试insert的方式插入数据:

  ```javascript
  // 4.测试insert方法
  list.insert(0, 100)
  list.insert(4, 200)
  list.insert(2, 300)
  alert(list) // 100,15,300,10,20,200
  ```

#### 位置移除数据/removeAt

- 移除数据有两种常见的方式:

  - 根据位置移除对应的数据
  - 根据数据, 先找到对应的位置, 再移除数据

- 我们这里先完成根据位置移除数据的方式

  ```javascript
  // 根据位置移除节点
  LinkedList.prototype.removeAt = function (position) {
      // 1.检测越界问题: 越界移除失败, 返回null
      if (position < 0 || position >= this.length) return null
  
      // 2.定义变量, 保存信息
      let current = this.head
      let previous = null
      let index = 0
      
      // 3.判断是否是移除第一项
      if (position === 0) {
          this.head = current.next //直接指向下一个
      } else {
          while (index++ < position) { //依次向后找
              previous = current
              current = current.next
          }
          previous.next = current.next //直接指向current下一个
      }
      
      // 4.length-1
      this.length--
      
      // 5.返回移除的数据
      return current.element
  }
  ```
  
- 代码解析:

  - 代码1部分, 还是越界的判断. (注意: 这里越界判断中的等于length也是越界的, 因为下标值是从0开始的)

  - 代码2部分还是定义了一些变量, 用于保存临时信息

  - 代码3部分进行判断, 因为移除第一项和其他项的方式是不同的

  - 移除第一项的信息:

    - 移除第一项时, 直接让head指向第二项信息就可以啦.
    - 那么第一项信息没有引用指向, 就在链表中不再有效, 后面会被回收掉.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-7dde4e9e60ef7c59?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 移除其他项的信息:

    - 移除其他项的信息操作方式是相同的.
    - 首先, 我们需要通过while循环, 找到正确的位置.
    - 找到正确位置后, 就可以直接将上一项的next指向current项的next, 这样中间的项就没有引用指向它, 也就不再存在于链表后, 会面会被回收掉.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-f1eeba113b5b8721?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-21b737fe5ae23894?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

- 测试removeAt方法

  ```javascript
  // 5.测试removeAt方法
  list.removeAt(0)
  list.removeAt(1)
  list.removeAt(3)
  alert(list) // 15, 10, 20
  ```

#### 获取元素位置/indexOf

- 我们来完成另一个功能: 根据元素获取它在链表中的位置

  ```javascript
  // 根据元素获取链表中的位置
  LinkedList.prototype.indexOf = function (element) {
      // 1.定义变量, 保存信息
      let current = this.head
      let index = 0
      
      // 2.找到元素所在的位置
      while (current) {
          if (current.element === element) {
              return index
          }
          index++
          current = current.next
      }
      // 3.来到这个位置, 说明没有找到, 则返回-1
      return -1
  }
  ```
  
- 代码解析:

  - 代码1的位置还是定义需要的变量.
  - 代码2的位置, 通过while循环获取节点
  - 通过节点获取元素和element进行对比, 如果和传入element相同, 表示找到, 直接返回index即可.
  - 如果没有找到, index++, 并且指向下一个节点.
  - 到最后都没有找到, 说明链表中没有对应的元素, 那么返回-1即可.

- indexOf方法测试

  ```javascript
  // 6.测试indexOf方法
  alert(list.indexOf(15)) // 0
  alert(list.indexOf(10)) // 1
  alert(list.indexOf(20)) // 2
  alert(list.indexOf(100)) // -1
  ```

#### 根据元素删除/remove

- 有了上面的indexOf方法, 我们可以非常方便实现根据元素来删除信息

  ```javascript
  // 根据元素删除信息
  LinkedList.prototype.remove = function (element) {
      var index = this.indexOf(element)
      if(index === -1) return;
      this.removeAt(index)
  }
  ```
  
- 代码解析:

  - 代码简单, 第一步获取元素所在位置(已经封装好), 根据位置移除元素(已经封装好)

- 代码测试:

  ```javascript
  // 7.测试remove方法
  list.remove(15)
  alert(list) // 10,20
  ```

#### 其他方法实现

- get(position)

  ```js
  get(position){
      if (position < 0 || position >= this.length) return null
      let index =0;
      let current = this.head
      while(index++ < position){
          current = current.next;
      }
      return current.element
  }
  ```

- update

  ```js
  update(position,element){
     this.remove(position)
     this.insert(position,element)
  }
  
  ```

- isEmpty方法

  ```javascript
  // 判断链表是否为空
  LinkedList.prototype.isEmpty = function () {
      return this.length == 0
  }
  ```
  
- size方法

  ```javascript
  // 获取链表的长度
  LinkedList.prototype.size = function () {
      return this.length
  }
  ```
  
- 获取第一个元素节点: (单向链表比较方便的操作)

  ```javascript
  // 获取第一个节点
  LinkedList.prototype.getFirst = function () {
      return this.head.element
  }
  ```
  
- 方法测试:

  ```javascript
  // 8.测试其他方法
  alert(list.isEmpty()) // false
  alert(list.size()) // 2
  alert(list.getFirst()) // 10
  ```

# d6 双向链表

## 01 认识双向链表

#### 双向链表介绍

- 单向链表:

  - 只能从头遍历到尾或者从尾遍历到头(一般从头到尾)
  - 也就是链表相连的过程是单向的. 实现的原理是上一个链表中有一个指向下一个的引用.
  - 单向链表有一个比较明显的缺点:
    - 我们可以轻松的到达下一个节点, 但是回到钱一个节点是很难的. 但是, 在实际开发中, 经常会遇到需要回到上一个节点的情况
    - 举个例子: 假设一个文本编辑用链表来存储文本. 每一行用一个String对象存储在链表的一个节点中. 当编辑器用户向下移动光标时, 链表直接操作到下一个节点即可. 但是当用于将光标向上移动呢? 这个时候为了回到上一个节点, 我们可能需要从first开始, 依次走到想要的节点上.

- 双向链表

  - 既可以从头遍历到尾, 又可以从尾遍历到头
  - 也就是链表相连的过程是双向的. 那么它的实现原理, 你能猜到吗?
  - 一个节点既有向前连接的引用, 也有一个向后连接的引用.
  - 双向链表可以有效的解决单向链表中提到的问题.
  - 双向链表有什么缺点呢?
    - 每次在插入或删除某个节点时, 需要处理四个节点的引用, 而不是两个. 也就是实现起来要困难一些
    - 并且相当于单向链表, 必然占用内存空间更大一些.
    - 但是这些缺点和我们使用起来的方便程度相比, 是微不足道的.

- 双向连接的图解:

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-c89f024c6db0ad30?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

  img

#### 双向链表的创建

- 我们来创建一个双向链表的类

  ```javascript
  // 创建双向链表的构造函数
  function DoublyLinkedList() {
      // 创建节点构造函数
      function Node(element) {
          this.element = element
          this.next = null
          this.prev = null // 新添加的
      }
  
      // 定义属性
      this.length = 0
      this.head = null
      this.tail = null // 新添加的
  
      // 定义相关操作方法
  }
  ```
  
- 代码解析:

  - 基本思路和单向链表比较相似, 都是创建节点结构函数以及定义一些属性和方法.
  - 只是Node中添加了一个this.prev属性, 该属性用于指向上一个节点.
  - 另外属性中添加了一个this.tail属性, 该属性指向末尾的节点

## 02 操作双向链表

> 双向链表的操作和单向链表的方法都是类似的.
>
> 只是在实现的过程中, 需要考虑更多节点之间的关系, 所以变得比单向链表复杂了一些.

#### 尾部追加数据

- 我们还是先来实现尾部追加数据的方法

  ```javascript
  // 在尾部追加数据
  DoublyLinkedList.prototype.append = function (element) {
      // 1.根据元素创建节点
      var newNode = new Node(element)
  
      // 2.判断列表是否为空列表
      if (this.head == null) {
          this.head = newNode
          this.tail = newNode
      } else {
          this.tail.next = newNode
          newNode.prev = this.tail
          this.tail = newNode
      }
      
      // 3.length+1
      this.length++
  }
  ```
  
- 代码解析:

  - 代码1部分不用多讲, 还是通过元素创建新的节点.
  - 代码2部分相比之前有一些复杂, 但是还是两种情况.
  - 情况一: 链表原来为空
    - 链表中原来如果没有数据, 那么直接让head和tail指向这个新的节点即可.
  - 情况二: 链表中已经存在数据
    - 因为我们是要将数据默认追加到尾部, 所以这个变得也很简单.
    - 首先tail中的next之前指向的是null. 现在应该指向新的节点newNode: this.tail.next = newNode
    - 因为是双向链表, 新节点的next/tail目前都是null. 但是作为最后一个节点, 需要有一个指向前一个节点的引用. 所以这里我们需要newNode.prev = this.tail
    - 因为目前newNod已经变成了最后的节点, 所以this.tail属性的引用应该指向最后: this.tail = newNode即可
  - 代码3部分不用多做解析, length需要+1

#### 正向反向遍历

- 链表的遍历

  - 之前我们在单向链表中实现了一个toString方法, 它是一种正向的遍历.
  - 现在, 为了用户使用方便, 我们实现三个方法
    - forwardString: 正向遍历转成字符串的方法
    - reverseString: 反向遍历转成字符串的方法
    - toString: 正向遍历转成字符串的方法

- 方法的相关实现:

  ```javascript
  // 正向遍历的方法
  DoublyLinkedList.prototype.forwardString = function () {
      var current = this.head
      var forwardStr = ""
      
      while (current) {
          forwardStr += "," + current.element
          current = current.next
      }
      
      return forwardStr.slice(1)
  }
  
  // 反向遍历的方法
  DoublyLinkedList.prototype.reverseString = function () {
      var current = this.tail
      var reverseStr = ""
      
      while (current) {
          reverseStr += "," + current.element
          current = current.prev
      }
      
      return reverseStr.slice(1)
  }
  
  // 实现toString方法
  DoublyLinkedList.prototype.toString = function () {
      return this.forwardString()
  }
  ```
  
- 完成上面的代码后, 测试append方法

  

  ```javascript
  // 1.创建双向链表对象
  var list = new DoublyLinkedList()
  
  // 2.追加元素
  list.append("abc")
  list.append("cba")
  list.append("nba")
  list.append("mba")
  
  // 3.获取所有的遍历结果
  alert(list.forwardString()) // abc,cba,nba,mba
  alert(list.reverseString()) // mba,nba,cba,abc
  alert(list) // abc,cba,nba,mba
  ```

#### 任意位置插入

- 向双向链表的任意位置插入数据会有一些复杂, 考虑的情况也会有一些多.

  ```javascript
  // 在任意位置插入数据
  DoublyLinkedList.prototype.insert = function (position, element) {
      // 1.判断越界的问题
      if (position < 0 || position > this.length) return false
  
      // 2.创建新的节点
      var newNode = new Node(element)
  
      // 3.判断插入的位置
      if (position === 0) { // 在第一个位置插入数据
          // 判断链表是否为空
          if (this.head == null) {
              this.head = newNode
              this.tail = newNode
          } else {
              this.head.prev = newNode
              newNode.next = this.head
              this.head = newNode
          }
      } else if (position === this.length) { // 插入到最后的情况
          // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?
          this.tail.next = newNode
          newNode.prev = this.tail
          this.tail = newNode
      } else { // 在中间位置插入数据
          // 定义属性
          var index = 0
          var current = this.head
          var previous = null
          
          // 查找正确的位置
          while (index++ < position) {
              previous = current
              current = current.next
          }
          
          // 交换节点的指向顺序
          newNode.next = current
          newNode.prev = previous
          current.prev = newNode
          previous.next = newNode
      }
      
      // 4.length+1
      this.length++
      
      return true
  }
  ```
  
- 代码深度解析, 代码比较复杂, 我们分成三种情况:

  - 情况一: 将元素插入到头部(position === 0)

    - 事实上, 将元素插入到头部是比较简单. 只是它有分成了两种情况.
    - 情况一: 列表为空. 那么直接让head/tail指向newNode即可
    - 情况二: 列表不为空, 这个时候需要修改原来head的prev指向新节点. 新节点的next指向原来的head. 并且head现在要指向newNode

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-2fb81a45c64af85c?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 情况二: 将元素插入到尾部(position === length)

    - 这种情况比较简答了, 因为我们在append方法中已经处理过了.
    - 注意: 这里不需要判断元素为空的情况, 因为在position === 0的时候, 我们已经处理过了. 所以到这里的时候, 肯定不为空.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-e8fa411165401231?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 情况三: 将元素插入到中间位置

    - 情况三是比较复杂一些的, 但是我们理清楚它的逻辑关系也就比较简单了.
    - 首先, 我们需要找到正确的插入位置. 通过while循环, 这个并不难, 因为我们在单向链表的时候已经找过了.
    - 查找正确的位置后, 需要进行插入操作.
    - 首先, 你的newNode的next/prev必然要指向前后的节点, 也就是current和previous
    - 其次, 而current的prev需要指向newNode, 而previous的next需要指向newNode.
    - 逻辑搞定, 并没有想象中的复杂, 详细看图解.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-80118e0faa4d5a85?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

- 测试一下该方法

  

  ```javascript
  // 4.insert方法测试
  list.insert(0, "100")
  list.insert(2, "200")
  list.insert(6, "300")
  alert(list) // 100,abc,200,cba,nba,mba,300
  ```

- 课下思考: 代码性能能否改进一点呢?

  - 如果我们position大于length/2, 是否从尾部开始迭代性能更高一些呢?
  - 对于初学者来说, 可以作为思考. 但是先搞定上面的内容吧.

#### 位置移除数据

- 我们继续来做下一个功能: 通过下标值删除某个元素

  

  ```javascript
  // 根据位置删除对应的元素
  DoublyLinkedList.prototype.removeAt = function (position) {
      // 1.判断越界的问题
      if (position < 0 || position >= this.length) return null
  
      // 2.判断移除的位置
      var current = this.head
      if (position === 0) {
          if (this.length == 1) {
              this.head = null
              this.tail = null
          } else {
              this.head = this.head.next
              this.head.prev = null
          }
      } else if (position === this.length -1) {
          current = this.tail
          this.tail = this.tail.prev
          this.tail.next = null
      } else {
          var index = 0
          var previous = null
  
          while (index++ < position) {
              previous = current
              current = current.next
          }
  
          previous.next = current.next
          current.next.prev = previous
      }
  
      // 3.length-1
      this.length--
  
      return current.element
  }
  ```

- 代码深度解析, 和插入一样, 可以分成三种情况:

  - 情况一: 删除头部的元素

    - 删除头部的元素也分成两种情况.
    - 情况一: 链表只有一个元素, 那么将head/tail直接设置为null即可
    - 情况二: 链表有多个元素, 这个时候删除头部的元素. head = head.next. head.prev = null

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-b6875b25736c4bad?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 情况二: 删除尾部的元素

    - 删除尾部的元素和删除头部有多个元素的情况比较相似. (也不需要考虑个数为1的情况, 因为上一种情况已经考虑了)
    - 将tail设置为tail的prev. tail的next设置为null即可.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-b1d1e23842e96634?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

  - 情况三: 删除中间位置的元素

    - 这种情况就需要先找到正确的位置, 还是使用while循环.
    - 将previous的next直接设置成current的next, 将current.next的prev设置成previous即可

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-efdaaafa21eca5e7?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

    img

- 测试removeAt方法

  

  ```javascript
  // 5.removeAt方法测试
  alert(list.removeAt(0)) // 100
  alert(list.removeAt(1)) // 200
  alert(list.removeAt(4)) // 300
  alert(list) // abc,cba,nba,mba
  ```

#### 获取元素位置

- 下面完成下一个功能: 根据元素获取再链表中的位置

  

  ```javascript
  // 根据元素获取在链表中的位置
  DoublyLinkedList.prototype.indexOf = function (element) {
      // 1.定义变量保存信息
      var current = this.head
      var index = 0
  
      // 2.查找正确的信息
      while (current) {
          if (current.element === element) {
              return index
          }
          index++
          current = current.next
      }
  
      // 3.来到这个位置, 说明没有找到, 则返回-1
      return -1
  }
  ```

- 代码解析:

  - 这个代码的实现和单向链表一样, 不再解释.

- 代码测试:

  

  ```javascript
  // 6.indexOf方法测试
  alert(list.indexOf("abc")) // 0
  alert(list.indexOf("cba")) // 1
  alert(list.indexOf("nba")) // 2
  alert(list.indexOf("mba")) // 3
  ```

#### 根据元素删除

- 有了上面的indexOf方法, 我们可以非常方便实现根据元素来删除信息

  

  ```javascript
  // 根据元素删除
  DoublyLinkedList.prototype.remove = function (element) {
      var index = this.indexOf(element)
      return this.removeAt(index)
  }
  ```

- 代码解析:

  - 和单向链表一样, 不再解释.

- 测试代码:

  

  ```javascript
  // 7.remove方法测试
  alert(list.remove("abc")) // abc
  alert(list) // cba,nba,mba
  ```

#### 其他方法实现

- 其他四个方法, 放在一起了

  

  ```javascript
  // 判断是否为空
  DoublyLinkedList.prototype.isEmpty = function () {
      return this.length === 0
  }
  
  // 获取链表长度
  DoublyLinkedList.prototype.size = function () {
      return this.length
  }
  
  // 获取第一个元素
  DoublyLinkedList.prototype.getHead = function () {
      return this.head.element
  }
  
  // 获取最后一个元素
  DoublyLinkedList.prototype.getTail = function () {
      return this.tail.element
  }
  ```

- 代码解析：比较简单, 不再给出解释了.

- 代码测试:

  ```javascript
  // 8.测试最后四个方法
  alert(list.getHead())
  alert(list.getTail())
  alert(list.isEmpty())
  alert(list.size())
  ```

## 03 链表&Leetcode

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png)

```javascript
class ListNode {
  val;
  next = null;
  constructor(value) {
    this.val = value;
    this.next = null;
  }
}
```

#### 203 [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

> 这段代码通过创建一个辅助节点 `ret`，将其连接到原链表的头部，然后使用 `cur` 变量遍历链表。在遍历过程中，如果当前节点的下一个节点的值等于指定的 `val`，则直接跳过下一个节点，实现删除操作；否则，将当前节点移动到下一个节点。最终返回经过删除操作后的链表头部。

```js
var removeElements = function(head, val) {
    const ret = new ListNode(0, head);
    let cur = ret;
    while(cur.next) {
        if(cur.next.val === val) {
            cur.next =  cur.next.next;
            continue;
        }
        cur = cur.next;
    }
    return ret.next;
};
```

> 首先，创建一个新的 `ListNode` 作为 `headNode`，其 `next` 属性指向原始链表的头部。然后，通过变量 `node` 迭代遍历链表，当发现下一个节点的值等于指定的 `val` 时，将当前节点的 `next` 指针跳过下一个节点，实现节点的删除。如果不等于 `val`，则移动到下一个节点。

```js
var removeElements = function(head, val) {
    var headNode=new ListNode()
    headNode.next=head
    var node=headNode
    while(node.next){
        if(node.next.val===val){
            node.next=node.next.next
        }else{
            node=node.next
        }
    }
    return headNode.next
};
```

#### 707 [设计链表](https://leetcode.cn/problems/design-linked-list/)

```js
class LinkNode {
    constructor(val, next) {
        this.val = val;
        this.next = next;
    }
}

/**
 * Initialize your data structure here.
 * 单链表 储存头尾节点 和 节点数量
 */
var MyLinkedList = function() {
    this._size = 0;
    this._tail = null;
    this._head = null;
};

/**
 * Get the value of the index-th node in the linked list. If the index is invalid, return -1. 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.getNode = function(index) {
    if(index < 0 || index >= this._size) return null;
    // 创建虚拟头节点
    let cur = new LinkNode(0, this._head);
    // 0 -> head
    while(index-- >= 0) {
        cur = cur.next;
    }
    return cur;
};
MyLinkedList.prototype.get = function(index) {
    if(index < 0 || index >= this._size) return -1;
    // 获取当前节点
    return this.getNode(index).val;
};

/**
 * Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function(val) {
    const node = new LinkNode(val, this._head);
    this._head = node;
    this._size++;
    if(!this._tail) {
        this._tail = node;
    }
};

/**
 * Append a node of value val to the last element of the linked list. 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function(val) {
    const node = new LinkNode(val, null);
    this._size++;
    if(this._tail) {
        this._tail.next = node;
        this._tail = node;
        return;
    }
    this._tail = node;
    this._head = node;
};

/**
 * Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function(index, val) {
    if(index > this._size) return;
    if(index <= 0) {
        this.addAtHead(val);
        return;
    }
    if(index === this._size) {
        this.addAtTail(val);
        return;
    }
    // 获取目标节点的上一个的节点
    const node = this.getNode(index - 1);
    node.next = new LinkNode(val, node.next);
    this._size++;
};

/**
 * Delete the index-th node in the linked list, if the index is valid. 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function(index) {
    if(index < 0 || index >= this._size) return;
    if(index === 0) {
        this._head = this._head.next;
        // 如果删除的这个节点同时是尾节点，要处理尾节点
        if(index === this._size - 1){
            this._tail = this._head
        }
        this._size--;
        return;
    }
    // 获取目标节点的上一个的节点
    const node = this.getNode(index - 1);    
    node.next = node.next.next;
    // 处理尾节点
    if(index === this._size - 1) {
        this._tail = node;
    }
    this._size--;
};

// MyLinkedList.prototype.out = function() {
//     let cur = this._head;
//     const res = [];
//     while(cur) {
//         res.push(cur.val);
//         cur = cur.next;
//     }
// };
/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

> 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。首先要把 cur->next 节点用tmp指针保存一下，接下来改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

```js
// 双指针：
var reverseList = function(head) {
    if(!head || !head.next) return head;
    let temp = null, pre = null, cur = head;
    while(cur) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    // temp = cur = null;
    return pre;
};
```

```js
// 递归：
var reverse = function(pre, head) {
    if(!head) return pre;
    const temp = head.next;
    head.next = pre;
    pre = head
    return reverse(pre, temp);
}

var reverseList = function(head) {
    return reverse(null, head);
};

// 递归2
var reverse = function(head) {
    if(!head || !head.next) return head;
    // 从后往前翻
    const pre = reverse(head.next);
    head.next = pre.next;
    pre.next = head;
    return head;
}

var reverseList = function(head) {
    let cur = head;
    while(cur && cur.next) {
        cur = cur.next;
    }
    reverse(head);
    return cur;
};
```

#### 24 [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```js
var swapPairs = function (head) {
  let ret = new ListNode(0, head); // 创建一个虚拟头结点，值为0，next指向传入的链表头
  let cur = ret;

  // 遍历链表，直到没有足够的节点可以进行交换
  while (cur.next && cur.next.next) {
    let temp3 = cur.next.next.next; // 保存节点3
    let temp1 = cur.next; // 保存节点1
	
    cur.next = cur.next.next //虚拟头节点指向2
    cur.next.next = temp1 //2指向1
    temp1.next = temp3 //1指向3
    cur = cur.next.next //移动到34前 2位置
  }

  return ret.next; // 返回从虚拟头结点的下一个节点开始的修改后的链表
};
```

#### 19 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

> 找到倒数第n个节点（要找到删除节点的前一个节点来操作）：先让快指针走n步，然后快慢指针一起走，直到快指针走到链表末尾，此时慢指针刚好在删除节点前一个位置。

```js
var removeNthFromEnd = function(head, n) {
    let ret = new ListNode(0, head),
        slow = fast = ret;
    // 让slow指针停在删除节点的前一个节点位置
    while(n--) fast = fast.next;
    while (fast.next !== null) {
        fast = fast.next; 
        slow = slow.next
    };
    // 移除
    slow.next = slow.next.next;
    return ret.next;
};
```

#### 0207 [链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

> 利用两个指针分别遍历两个链表，通过交替移动指针来消除两个链表长度的差异。如果链表有相交点，两个指针最终会在交点处相遇；如果没有相交点，两个指针会同时到达链表末尾，此时返回 `null`。

```js
var getIntersectionNode = function (headA, headB) {
  if (headA === null || headB === null) return null;
  let pA = headA;
  let pB = headB;

  while (pA !== pB) {
    // 如果 pA 不为 null，则将 pA 移动到下一个节点；否则，将 pA 重定向到链表 B 的头
    pA = pA ? pA.next : headB;
    // 如果 pB 不为 null，则将 pB 移动到下一个节点；否则，将 pB 重定向到链表 A 的头
    pB = pB ? pB.next : headA;
  }
  return pA
  // 如果两个链表有交点，那么在某一时刻 `pA` 和 `pB` 将相遇于交点 `C`。这是因为它们从各自的头节点出发，在第一次相遇点之前走过的距离是相等的，而在第一次相遇点后，它们共同走过的距离也是相等的。
};
```

> 首先，通过 `getListLen` 函数分别计算链表A和链表B的长度。然后，比较两个链表的长度，确保 `curA` 指向较长的链表，同时记录两个链表的长度。通过长度差，使 `curA` 和 `curB` 在同一起点上，即末尾位置对齐。最后，遍历两个链表，直到找到交点或到达两个链表的末尾。如果找到交点，则返回该交点；否则返回 `null`。

```js
// 定义一个函数，用于获取链表的长度
var getListLen = function(head) {
    let len = 0, cur = head;
    while (cur) {
        len++;
        cur = cur.next;
    }
    return len;
}

// 定义一个函数，用于找到两个链表的交点
var getIntersectionNode = function(headA, headB) {
    // 初始化两个指针和两个链表的长度
    let curA = headA, curB = headB,
        lenA = getListLen(headA),   // 获取链表A的长度
        lenB = getListLen(headB);

    // 确保curA指向较长的链表，lenA为其长度
    if (lenA < lenB) {
    // 注意：交换变量时需要加分号，否则下面两条语句会被解释为一条语句: [curA, curB] = [lenB, lenA]
        [curA, curB] = [curB, curA];
        [lenA, lenB] = [lenB, lenA];
    }

    // 计算长度差
    let i = lenA - lenB;

    // 将curA和curB移动到相同的起点（末尾位置对齐）
    while (i-- > 0) {
        curA = curA.next;
    }

    // 遍历curA 和 curB，遇到相同则直接返回
    while (curA && curA !== curB) {
        curA = curA.next;
        curB = curB.next;
    }

    // 返回交点，如果没有交点则返回null
    return curA;
};
```

#### 142 [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

```js
var detectCycle = function(head) {
    if(!head || !head.next) return null;
    // 初始化慢指针 slow 和快指针 fast，分别指向链表的第二个节点和第三个节点
    let slow =head.next, fast = head.next.next;
    // 判断链表中是否存在环
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        // 若快慢指针相遇，说明链表存在环，将慢指针 slow 指向链表头部
        if(fast == slow) {
            slow = head;
            // 再次遍历链表，直到快慢指针相遇，相遇点即为环的起始节点
            while (fast !== slow) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};
```

# d7 集合set

几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。

## 01 集合特点

集合通常是由一组**无序的**、**不能重复的**元素构成。

数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。

集合是特殊的数组：
- 特殊之处在于里面的元素没有顺序，也不能重复。
- 没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。

## 02 封装集合

ES6 中的 `Set` 就是一个集合类，这里我们重新封装一个 `Set` 类，了解集合的底层实现。

#### 集合常见的操作

- `add(value)` 向集合添加一个新的项。
- `remove(value)` 从集合移除一个值。
- `has(value)` 如果值在集合中，返回 `true`，否则返回` false`。
- `clear()` 移除集合中的所有项。
- `size()` 返回集合所包含元素的数量。与数组的 `length` 属性类似。
- `values()` 返回一个包含集合中所有值的数组。
- 还有其他的方法，用的不多，这里不做封装。

#### 代码实现

```js
// 集合结构的封装
class Set {
  // 属性    
  constructor() {
    this.items = {};
  }
    
  //方法
  // has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false
  has(value) {
    return this.items.hasOwnProperty(value);
  }

  // add(value) 往集合中添加 value
  add(value) {
    if (this.has(value)) return false;
    this.items[value] = value;
    return true;
  }

  // remove(value) 删除集合中指定的 value
  remove(value) {
    // 如果集合不存在该 value，返回 false
    if (!this.has(value)) return false;
    delete this.items[value];
    return true;
  }

  // clear() 清空集合中所有 value
  clear() {
    this.items = {};
  }

  // size() 获取集合中的 value 个数
  size() {
    return Object.keys(this.items).length;
  }

  // values() 获取集合中所有的 value
  values() {
    return Object.keys(this.items);
  }
}
```

#### 代码测试

```js
const set = new Set();

// add() 测试
set.add("abc");
set.add("abc");
set.add("123");
set.add("zxc");
console.log(set); //--> {items: {123: "123", abc: "abc", zxc: "zxc"}}

// has() 测试
console.log(set.has("123")); //--> true
console.log(set.has("456")); //--> false

// remove() 测试
set.remove("abc");
console.log(set); //--> {items: {123: "123", zxc: "zxc"}}

// size() 测试
console.log(set.size()); //--> 2

// values() 测试
console.log(set.values()); //--> ["123", "zxc"]

// clear() 测试
set.clear();
console.log(set.values()); //--> []
```

## 03 集合间的操作

- 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
- 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
- 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。
- 子集：验证一个给定集合是否是另一个集合的子集。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4utjffapm1w0.png)

#### 并集的实现

首先创建一个新的集合，遍历集合1中所有的值，并且添加到新集合中，遍历集合2中所有的值，并且添加到新集合中，将最终的新集合返回。

```js
// union() 求两个集合的并集
union(otherSet) {
    // 1、创建一个新集合
    let unionSet = new Set();

    // 2、将当前集合1（this）的所有 value，添加到新集合（unionSet）中
    for (let value of this.values()) {
        unionSet.add(value);
    }

    // 3、将 otherSet 集合2的所有 value，添加到新集合（unionSet）中
    for (let value of otherSet.values()) {
        unionSet.add(value); // add() 已经有重复判断
    }

    return unionSet;
}
```

#### 交集的实现

首先创建一个新的集合，遍历集合1中所有的值，判断是否该元素在集合2中，同时在集合2中，将该元素添加到新集合中，将最终的新集合返回。

```js
// intersection() 求两个集合的交集
intersection(otherSet) {

    // 1、创建一个新集合
    let intersectionSet = new Set();

    // 2、从当前集合1中取出每一个 value，判断是否在 otherSet 集合2中存在
    for (let value of this.values()) {
        if (otherSet.has(value)) {
            intersectionSet.add(value);
        }
    }

    return intersectionSet;
}
```

#### 差集的实现

首先创建一个新的集合，遍历集合1中所有的值，判断是否该元素在集合2中，不存在于集合2中，将该元素添加到新集合中，将最终的新集合返回。

```js
// difference() 差集
difference(otherSet) {

    // 1、创建一个新集合
    let differenceSet = new Set();

    // 2、从当前集合1中取出每一个 value，判断是否在 otherSet 集合2中存在，不存在的即为差集
    for (let value of this.values()) {
        if (!otherSet.has(value)) {
            differenceSet.add(value);
        }
    }

    return differenceSet;
}
```

#### 子集的实现

判断集合1是否大于集合2中，那么肯定不是集合2的子集，不大于的情况下：判断集合1中的元素是否在集合2中存在，全存在，那么是集合2的子集。

```js
// subset() 子集
subset(otherSet) {

    // 从当前集合1中取出每一个 value，判断是否在 otherSet 集合2中存在，有不存在的返回 false
    // 遍历完所有的，返回 true
    for (let value of this.values()) {
        if (!otherSet.has(value)) {
            return false;
        }
    }
    return true;
}
```

# d8 字典map

## 01 字典特点

字典存储的是**键值对**，主要特点是**一一对应**。

比如保存一个人的信息
- 数组形式：`[19，"Tom", 1.65]`，可通过下标值取出信息。
- 字典形式：`{"age": 19, "name": "Tom", "height": 165}`，可以通过 `key` 取出 `value`。

此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。

## 02 字典和映射的关系

有些编程语言中称这种映射关系为**字典**，如 Swift 中的 `Dictonary`，Python 中的 `dict`。

有些编程语言中称这种映射关系为 **Map**，比如 Java 中的 `HashMap` 和 `TreeMap` 等。

字典和数组：字典通过key来所有对应的value，数组通过下标。

字典和对象：JS中对象本身就是一种字典。

## 03 字典常见的操作

- `set(key,value)` 向字典中添加新元素。
- `remove(key)` 通过使用键值来从字典中移除键值对应的数据值。
- `has(key)` 如果某个键值存在于这个字典中，则返回 `true`，反之则返回 `false`。
- `get(key)` 通过键值查找特定的数值并返回。
- `clear()` 将这个字典中的所有元素全部删除。
- `size()` 返回字典所包含元素的数量。与数组的 `length` 属性类似。
- `keys()` 将字典所包含的所有键名以数组形式返回。
- `values()` 将字典所包含的所有数值以数组形式返回。

## 04 字典封装

#### 代码实现

```js
// 字典结构的封装
export default class Map {
  constructor() {
    this.items = {};
  }

  // has(key) 判断字典中是否存在某个 key
  has(key) {
    return this.items.hasOwnProperty(key);
  }

  // set(key, value) 在字典中添加键值对
  set(key, value) {
    this.items[key] = value;
  }

  // remove(key) 在字典中删除指定的 key
  remove(key) {
    // 如果集合不存在该 key，返回 false
    if (!this.has(key)) return false;
    delete this.items[key];
  }

  // get(key) 获取指定 key 的 value，如果没有，返回 undefined
  get(key) {
    return this.has(key) ? this.items[key] : undefined;
  }

  // 获取所有的 key
  keys() {
    return Object.keys(this.items);
  }

  // 获取所有的 value
  values() {
    return Object.values(this.items);
  }

  // size() 获取字典中的键值对个数
  size() {
    return this.keys().length;
  }

  // clear() 清空字典中所有的键值对
  clear() {
    this.items = {};
  }
}
```

#### 代码测试

```js
const map = new Map();

// set() 测试
map.set("name", "XPoet");
map.set("age", 18);
map.set("email", "i@xpoet.cn");
console.log(map); // {items: {name: "XPoet", age: 18, email: "i@xpoet.cn"}}

// has() 测试
console.log(map.has("name")); //--> true
console.log(map.has("address")); //--> false

// remove() 测试
map.remove("name");
console.log(map); // {age: 18, email: "i@xpoet.cn"}

// get() 测试
console.log(map.get("age")); //--> 18

// keys() 测试
console.log(map.keys()); //--> ["age", "email"]

// values() 测试
console.log(map.values()); //--> [18, "i@xpoet.cn"]

// size() 测试
console.log(map.size()); //--> 2
```

# d9 哈希表

## 01   认识哈希表

哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。

哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：

- 哈希表可以提供非常快速的 **插入-删除-查找** 操作。
- 无论多少数据，插入和删除值都只需接近常量的时间，即 **O(1)** 的时间复杂度。实际上，只需要几个机器指令即可完成。
- 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。
- 哈希表相对于树来说编码要简单得多。

哈希表同样存在不足之处：

- 哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。
- 通常情况下，哈希表中的 `key` 是不允许重复的，不能放置相同的 `key`，用于保存不同的元素。

哈希表是什么？

- 哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。
- 哈希表的结构就是数组，但它**神奇之处在于对下标值的一种变换**，这种变换我们可以称之为**哈希函数**，通过哈希函数可以获取 HashCode。

通过以下案例了解哈希表：

- 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。

- 案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。

也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。

### 哈希化

为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。

有了编码系统后，将字母转化为数字也有很多种方案：

- 方案一：数字相加。

例如 cats 转化为数字：`3 + 1 + 20 + 19 = 43`，那么就把 43 作为 cats 单词的下标值储存在数组中；

但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。

- 方案二：幂的连乘。

我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。
比如： `6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3`；这样单词也可以用该种方式来表示：`cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337`。

虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。

两种方案总结：

- 第一种方案（让数字相加求和）产生的数组下标太少。
- 第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。

现在需要一种压缩方法，把幂的连乘方案系统中得到的**巨大整数范围压缩到可接受的数组范围中**。可以通过**取余**操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。

### 哈希表的一些概念

- **哈希化**

  将**大数字**转化成**数组范围内下标**的过程，称之为哈希化。

- **哈希函数**

  我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。

- **哈希表**

  对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。

### 地址的冲突

在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。

解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。

#### 链地址法（拉链法）

如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5irlba213e00.png)

这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。

总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。

#### 开放地址法

开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.52qzixg5w4s0.png)

根据探测空白单元格位置方式的不同，可分为三种方法：

- 线性探测
- 二次探测
- 再哈希法

##### 线性探测

- 当插入 13 时：

经过哈希化（对 10 取余）之后得到的下标值 index=3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置+1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index=4 的位置就是合适的位置。

- 当查询 13 时：

  - 首先 13 经过哈希化得到 index=3，如果 index=3 的位置存放的数据与需要查询的数据 13 相同，就直接返回；
    不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。
  - 查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。

- 当删除 13 时：

  - 删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。
  - 通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。

线性探测存在的问题：

- 线性探测存在一个比较严重的问题，就是聚集。

- 如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。

- 聚集会影响哈希表的性能，无论是插入/查询/删除都会影响。

- 比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.47l36021j8m0.png)

##### 二次探测

上文所说的线性探测存在的问题：

- 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；

  二次探测是在线性探测的基础上进行了优化：

- 线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；

- 二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。

- 二次探测存在的问题：

  当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。

##### 再哈希法

在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。

- 二次探测的步长是固定的：1，4，9，16 依次类推。
- 现在需要一种方法：产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样。
- 这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。
- 再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。

第二次哈希化需要满足以下两点：

- 和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；
- 不能输出为 0，否则每次探测都是原地踏步的死循环；

优秀的哈希函数：

- stepSize = constant - （key % constant）；
- 其中 constant 是质数，且小于数组的容量；
- 例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为 0；

哈希化的效率

哈希表中执行插入和搜索操作效率是非常高的。

- 如果没有发生冲突，那么效率就会更高；
- 如果发生冲突，存取时间就依赖后来的探测长度；
- 平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。

#### 装填因子

- 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；
- 装填因子 = 总数据项 / 哈希表长度；
- 开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；
- 链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；

#### 不同探测方式性能的比较

- 线性探测

  可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。

  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2pcxv1f720o0.png)

- 二次探测和再哈希化的性能

  二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。

  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.f06tizypf6g.png)

- 链地址法的性能

  可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。

  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.45s3ntwwjia0.png)

### 哈希函数

哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法。

性能高的哈希函数应具备以下两个优点：

- 快速的计算；
- 均匀的分布；

#### 快速计算

霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4kz61djvvau0.png)

求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。

- 变换之前：

  - 乘法次数：n(n+1)/2 次；
  - 加法次数：n 次；

- 变换之后：

  - 乘法次数：n 次；
  - 加法次数：n 次；

如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。

#### 均匀分布

在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。

Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) & (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。

## 02 封装哈希表

### 哈希表常见操作

- `put(key, value)` 插入或修改操作。
- `get(key)` 获取哈希表中特定位置的元素。
- `remove(key)` 删除哈希表中特定位置的元素。
- `isEmpty()` 如果哈希表中不包含任何元素，返回 `trun`，如果哈希表长度大于 0 则返回 `false`。
- `size()` 返回哈希表包含的元素个数。
- `resize(value)` 对哈希表进行扩容操作。

### 哈希函数的简单实现

首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。

```js
hashFn(string, limit = 7) {

  // 自己采用的一个质数（无强制要求，质数即可）
  const PRIME = 31;

  // 1、定义存储 hashCode 的变量
  let hashCode = 0;

  // 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值
  for (let item of string) {
    hashCode = PRIME * hashCode + item.charCodeAt();
  }

  // 3、对 hashCode 取余，并返回
  return hashCode % limit;
}
```

哈希函数测试

```js
console.log(hashFn("123")); //--> 5
console.log(hashFn("abc")); //--> 6
```

### 哈希表的实现

#### 创建哈希表类

封装的哈希表的数据结构模型：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.7h3eahcbrvs0.png)

首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。

```js
class HashTable {
  constructor() {
    this.storage = []; // 哈希表存储数据的变量
    this.count = 0; // 当前存放的元素个数
    this.limit = 7; // 哈希表长度（初始设为质数 7）
  }
}
```

#### put(key,value)

哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 `[key, value]` 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2a81gwdznn8k.png)

实现思路：

- 首先，根据 key 获取索引值 index，目的为将数据插入到 storage 的对应位置；
- 然后，根据索引值取出 bucket，如果 bucket 不存在，先创建 bucket，随后放置在该索引值的位置；
- 接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。
- 最后，进行新增数据操作。

代码实现

```js
// put(key, value) 往哈希表里添加数据
put(key, value) {

  // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）
  const index = hashFn(key, this.limit);

  // 2、根据 index 取出对应的 bucket
  let bucket = this.storage[index];

  // 3、判断是否存在 bucket
  if (bucket === undefined) {
    bucket = [];  // 不存在则创建
    this.storage[index] = bucket;
  }

  // 4、判断是插入数据操作还是修改数据操作
  for (let i = 0; i < bucket.length; i++) {
    let tuple = bucket[i]; // tuple 的格式：[key, value]
    if (tuple[0] === key) { // 如果 key 相等，则修改数据
      tuple[1] = value;
      return; // 修改完 tuple 里数据，return 终止不再往下执行。
    }
  }

  // 5、bucket 新增数据
  bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value]
  this.count++;

  // 判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
  if (this.count / this.limit > this.loadFactor) {
    this.resize(this.getPrime(this.limit * 2));
  }

}
```

#### get(key)

实现思路：

- 首先，根据 key 通过哈希函数获取它在 `storage` 中对应的索引值 `index`。
- 然后，根据索引值获取对应的 `bucket`。
- 接着，判断获取到的 `bucket` 是否为 `null`，如果为 `null`，直接返回 `null`。
- 随后，线性遍历 `bucket` 中每一个 `key` 是否等于传入的 `key`。如果等于，直接返回对应的 `value`。
- 最后，遍历完 `bucket` 后，仍然没有找到对应的 `key`，直接 `return null` 即可。

代码实现

```js
// 根据 get(key) 获取 value
get(key) {

  const index = hashFn(key, this.limit);
  const bucket = this.storage[index];

  if (bucket === undefined) {
    return null;
  }

  for (const tuple of bucket) {
    if (tuple[0] === key) {
      return tuple[1];
    }
  }
  return null;
}
```

#### remove(key)

实现思路：

- 首先，根据 key 通过哈希函数获取它在 `storage` 中对应的索引值 `index`。
- 然后，根据索引值获取对应的 `bucket`。
- 接着，判断获取到的 `bucket` 是否为 `null`，如果为 `null`，直接返回 `null`。
- 随后，线性查找 `bucket`，寻找对应的数据，并且删除。
- 最后，依然没有找到，返回 `null`。

```js
// remove(key) 删除指定 key 的数据
remove(key) {

  const index = hashFn(key, this.limit);
  const bucket = this.storage[index];

  if (bucket === undefined) {
    return null;
  }

  // 遍历 bucket，找到对应位置的 tuple，将其删除
  for (let i = 0, len = bucket.length; i < len; i++) {
    const tuple = bucket[i];
    if (tuple[0] === key) {
      bucket.splice(i, 1); // 删除对应位置的数组项
      this.count--;
        
      // 根据装填因子的大小，判断是否要进行哈希表压缩
      if (this.limit > 7 && this.count / this.limit < this.minLoadFactor) {
        this.resize(this.getPrime(Math.floor(this.limit / 2)));
      }
        
      return tuple;
    }
  }
}
```

#### isEmpty()

```js
isEmpty() {
  return this.count === 0;
}
```

#### size()

```js
size() {
  return this.count;
}
```

## 03 哈希表的扩容与压缩

为什么需要扩容？

- 前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子(loadFactor)可以大于 1，所以这个哈希表可以无限制地插入新数据。

- 但是，随着数据量的增多，storage 中每一个 `index` 对应的 `bucket` 数组（链表）就会越来越长，这就会造成哈希表效率的降低。

什么情况下需要扩容？

- 常见的情况是 `loadFactor > 0.75` 的时候进行扩容。

如何进行扩容？

- 简单的扩容可以直接扩大两倍（关于质数，之后讨论）。
- 扩容之后所有的数据项都要进行同步修改。

实现思路：

- 首先，定义一个变量，比如 oldStorage 指向原来的 `storage`。
- 然后，创建一个新的容量更大的数组，让 `this.storage` 指向它。
- 最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 `this.storage` 指向的新数组中。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.7xrayvjwh2w.png)

### resize() 的实现

装填因子 = 哈希表中数据 / 哈希表长度，即 `loadFactor = count / HashTable.length`。

resize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。

```js
// 重新调整哈希表大小，扩容或压缩
resize(newLimit) {

  // 1、保存旧的 storage 数组内容
  const oldStorage = this.storage;

  // 2、重置所有属性
  this.storage = [];
  this.count = 0;
  this.limit = newLimit;

  // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage
  for (const bucket of oldStorage) {
    if (bucket) {
      for (const b of bucket) {
        this.put(b[0], b[1]);
      }
    }

  }
}
```

- 通常情况下当装填因子 `laodFactor > 0.75` 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。

  ```js
  // 判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
  if (this.count / this.limit > this.loadFactor) {
    this.resize(this.getPrime(this.limit * 2));
  }
  ```

* 当装填因子 `laodFactor < 0.25` 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。

  ```js
  // 根据装填因子的大小，判断是否要进行哈希表压缩
  if (this.limit > 7 && this.count / this.limit < this.minLoadFactor) {
    this.resize(this.getPrime(Math.floor(this.limit / 2)));
  }
  ```

### 选择质数作为哈希表容量

#### 质数判断

> 1 不是质数

- 方法一：针对质数的特点：只能被 1 和 number 整除，不能被 2 ~ (number-1)整除。遍历 2 ~ (num-1) 。

  这种方法虽然能实现质数的判断，但是效率不高。

  ```js
  function isPrime(number) {
    if (number <= 1) return false;
    for (let i = 2; i < number; i++) {
      if (number % i === 0) {
        return false;
      }
    }
    return true;
  }
  ```

  - 方法二：只需要遍历 2 ~ num 的平方根即可。该方法性能较好。

  ```js
  function isPrime(number) {
    if (number <= 1 || number === 4) return false;
    // 获取平方根
    const temp = parseInt(Math.sqrt(number));
    // 循环判断
    for (let i = 2; i < temp; i++) {
      if (number % i === 0) {
        return false;
      }
    }
    return true;
  }
  ```

#### 实现扩容或压缩后的哈希表容量为质数

实现思路：

2 倍扩容或压缩之后，通过循环调用 `isPrime` 判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，`14 + 1 = 15` 不是质数，`15 + 1 = 16` 不是质数，`16 + 1 = 17` 是质数，停止循环，由此得到质数 17。

- 首先需要为 HashTable 类添加判断质数的 `isPrime` 方法和获取质数的 `getPrime` 方法：

  ```js
  // getPrime(number) 根据传入的 number 获取最临近的质数
  getPrime(number) {
    while (!isPrime(number)) {
      number++;
    }
    return number;
  }
  ```

- 修改添加元素的 `put` 方法和删除元素的 `remove` 方法中关于数组扩容的相关操作：

  在 `put` 方法中添加如下代码：

  ```js
  // 判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
  if (this.count / this.limit > this.loadFactor) {
    this.resize(this.getPrime(this.limit * 2));
  }
  ```

  在 `remove` 方法中添加如下代码：

  ```js
  // 根据装填因子的大小，判断是否要进行哈希表压缩
  if (this.limit > 7 && this.count / this.limit < this.minLoadFactor) {
    this.resize(this.getPrime(Math.floor(this.limit / 2)));
  }
  ```

## 04 哈希表完整实现

```js
class HashTable {
  constructor() {
    this.storage = []; // 哈希表存储数据的变量
    this.count = 0; // 当前存放的元素个数
    this.limit = 7; // 哈希表长度（初始设为质数 7）

    // 装填因子(已有个数/总个数)
    this.loadFactor = 0.75;
    this.minLoadFactor = 0.25;
  }

  // getPrime(number) 根据传入的 number 获取最临近的质数
  getPrime(number) {
    while (!isPrime(number)) {
      number++;
    }
    return number;
  }

  // put(key, value) 往哈希表里添加数据
  put(key, value) {
    // 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）
    const index = hashFn(key, this.limit);

    // 2、根据 index 取出对应的 bucket
    let bucket = this.storage[index];

    // 3、判断是否存在 bucket
    if (bucket === undefined) {
      bucket = []; // 不存在则创建
      this.storage[index] = bucket;
    }

    // 4、判断是插入数据操作还是修改数据操作
    for (let i = 0; i < bucket.length; i++) {
      let tuple = bucket[i]; // tuple 的格式：[key, value]
      if (tuple[0] === key) {
        // 如果 key 相等，则修改数据
        tuple[1] = value;
        return; // 修改完 tuple 里数据，return 终止，不再往下执行。
      }
    }

    // 5、bucket 新增数据
    bucket.push([key, value]); // bucket 存储元组 tuple，格式为 [key, value]
    this.count++;

    // 判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
    if (this.count / this.limit > this.loadFactor) {
      this.resize(this.getPrime(this.limit * 2));
    }
  }

  // 根据 get(key) 获取 value
  get(key) {
    const index = hashFn(key, this.limit);
    const bucket = this.storage[index];

    if (bucket === undefined) {
      return null;
    }

    for (const tuple of bucket) {
      if (tuple[0] === key) {
        return tuple[1];
      }
    }
    return null;
  }

  // remove(key) 删除指定 key 的数据
  remove(key) {
    const index = hashFn(key, this.limit);
    const bucket = this.storage[index];

    if (bucket === undefined) {
      return null;
    }

    // 遍历 bucket，找到对应位置的 tuple，将其删除
    for (let i = 0, len = bucket.length; i < len; i++) {
      const tuple = bucket[i];
      if (tuple[0] === key) {
        bucket.splice(i, 1); // 删除对应位置的数组项
        this.count--;

        // 根据装填因子的大小，判断是否要进行哈希表压缩
        if (this.limit > 7 && this.count / this.limit < this.minLoadFactor) {
          this.resize(this.getPrime(Math.floor(this.limit / 2)));
        }

        return tuple;
      }
    }
  }

  isEmpty() {
    return this.count === 0;
  }

  size() {
    return this.count;
  }

  // 重新调整哈希表大小，扩容或压缩
  resize(newLimit) {
    // 1、保存旧的 storage 数组内容
    const oldStorage = this.storage;

    // 2、重置所有属性
    this.storage = [];
    this.count = 0;
    this.limit = newLimit;

    // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage
    for (const bucket of oldStorage) {
      if (bucket) {
        for (const b of bucket) {
          this.put(b[0], b[1]);
        }
      }
    }
  }
}
```

## 05 哈希表&Leetcode

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

### 242 [有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

> 将两个字符串转换成字符数组，对字符数组进行排序，然后将排序后的字符数组连接成字符串，最后比较两个字符串是否相等。

```js
var isAnagram = function (s, t) {
    return s.split('').sort().join('') === t.split('').sort().join('')
};
```

> 然后，它使用哈希表 `char_count` 记录字符串 `s` 中每个字符出现的次数。接着，遍历字符串 `s`，将每个字符的出现次数存储到哈希表中。然后，遍历字符串 `t`，对于每个字符，如果哈希表中不存在相应的字符，或者字符出现的次数已经为 0，则说明 `t` 不是 `s` 的字母异位词，返回 `false`。最后，如果成功遍历完字符串 `t`，说明 `t` 是 `s` 的字母异位词，返回 `true`。

```js
var isAnagram = function(s, t) {
  if(s.length !== t.length) return false;
  // 初始化一个哈希表 char_count，用于记录字符串 s 中每个字符出现的次数
  let char_count = new Map();
  
  // 遍历字符串 s，统计每个字符出现的次数，并存储到哈希表 char_count 中
  for(let item of s) {
    char_count.set(item, (char_count.get(item) || 0) + 1) ;
     // 将字符 item 在字符串 s 中的出现次数加 1，并将更新后的计数值存储到哈希表中
  }
    
  // 遍历字符串 t
  for(let item of t) {
    // 如果哈希表中不存在当前字符，说明 t 不是 s 的字母异位词，直接返回 false
    if(!char_count.get(item)) return false;
    // 将哈希表中对应字符的计数减一
    char_count.set(item, char_count.get(item)-1);
  }
  
  // 遍历结束，说明 t 是 s 的字母异位词，返回 true
  return true;
};
```

```js
var isAnagram = function(s, t) {
    if(s.length !== t.length) return false;
    const resSet = new Array(26).fill(0);
    const base = "a".charCodeAt(); // 索引
    for(const i of s) {
        resSet[i.charCodeAt() - base]++;
    }
    for(const i of t) {
        if(!resSet[i.charCodeAt() - base]) return false;
        resSet[i.charCodeAt() - base]--;
    }
    return true;
};
```

### 49 [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

```js
var groupAnagrams = function(strs) {
    const anagrams = {};
    // 遍历字符串数组 strs
    for (let word of strs) {
        // 将当前单词转换为字符数组，并按照字母顺序排序，再将其连接成字符串
        const sortedWord = word.split('').sort().join('');
        // 如果排序后的字符串已经在哈希表 anagrams 中存在，则将当前单词添加到对应的异位词组中
        if (sortedWord in anagrams) {
            anagrams[sortedWord].push(word);
        } else {
            // 如果排序后的字符串在哈希表中不存在，则新建一个键，并将当前单词作为第一个元素存储
            anagrams[sortedWord] = [word];
        }
    }
    // 返回哈希表 anagrams 中的值，即所有字母异位词组的数组形式
    return Object.values(anagrams);
}
```

### 349 [两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```js
var intersection = function(nums1, nums2) {  
    // 根据数组大小交换操作的数组，确保nums1是较长的数组  
    if(nums1.length < nums2.length) {  
        const _ = nums1; // 使用临时变量_暂存nums1  
        nums1 = nums2;   // 将nums2赋值给nums1  
        nums2 = _;       // 将暂存的nums1（即原nums2）赋值给nums2  
    }
    
    // 使用nums1数组的元素创建一个Set对象，用于快速查找元素是否存在  
    const nums1Set = new Set(nums1);  
    // 创建一个空的Set对象，用于存储交集中的元素  
    const resSet = new Set();
    // 逆序遍历nums2数组  
    for(let i = nums2.length - 1; i >= 0; i--) {  
        // 如果nums2中的当前元素存在于nums1Set中  
        if(nums1Set.has(nums2[i])) {  
            // 将该元素添加到结果集resSet中  
            resSet.add(nums2[i]);  
        }  
    }  
    // 将结果集resSet转换为数组并返回  
    return Array.from(resSet);  
};
```

### 350 [两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

```js
var intersect = function(nums1, nums2) {  
    // 如果 nums1 的长度大于 nums2 的长度，则交换两个数组以确保 nums1 较短
    if (nums1.length > nums2.length) {  
        return intersect(nums2, nums1);  
    }  
    
    // 使用 Map 数据结构来存储 nums1 中的每个元素及其出现的次数
    const map = new Map();  
    for (let num of nums1) {  
        // 将 num 作为键，其在 nums1 中出现的次数作为值，并存储到 map 中
        map.set(num, (map.get(num) || 0) + 1);  
    }  
    
    // 初始化一个空数组 intersection 来存储 nums1 和 nums2 之间的交集
    const intersection = [];  
    
    // 遍历 nums2，检查其中的元素是否在 map 中存在，并且其出现的次数大于 0
    for (let num of nums2) {  
        if (map.has(num) && map.get(num) > 0) {  
            // 如果满足条件，将该元素添加到 intersection 数组中
            intersection.push(num);  
            // 将该元素在 map 中的出现次数减 1
            map.set(num, map.get(num) - 1);  
            // 如果该元素在 map 中的出现次数减为 0，则从 map 中删除该元素
            if (map.get(num) === 0) {  
                map.delete(num);  
            }  
        }  
    }  
    
    // 返回 intersection 数组，其中包含 nums1 和 nums2 的交集
    return intersection;  
}  
```

### 202 [快乐数](https://leetcode.cn/problems/happy-number/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

```js
var isHappy = function (n) {
    // 创建一个 Map 数据结构，用于记录每次计算过程中的数值
    let m = new Map()

    // 定义一个函数，用于计算数值的各位数字的平方和
    const getSum = (num) => {
        let sum = 0
        while (n) {
            // 对当前数值的各位数字进行平方并求和
            sum += (n % 10) ** 2
            // 将当前数值除以 10，向下取整，以获取下一个各位数字
            n = Math.floor(n / 10)
        }
        return sum
    }

    // 进入无限循环，直到出现以下情况之一：1. 计算出现重复数字；2. 计算结果为 1
    while (true) {
        // 如果当前数值已经出现过，说明陷入了无限循环，因此不是快乐数
        if (m.has(n)) return false
        // 如果计算结果为 1，则该数是快乐数
        if (n === 1) return true
        // 将当前数值存入 Map 中，表示已经出现过
        m.set(n, 1) 
        // 根据计算函数获取下一个数值，继续判断是否为快乐数
        n = getSum(n)
    }
}
```

```js
// 方法二：使用环形链表的思想 说明出现闭环 退出循环
var isHappy = function(n) {
    if (getN(n) == 1) return true;
    let a = getN(n), b = getN(getN(n));
    // 如果 a === b 
    while (b !== 1 && getN(b) !== 1 && a !== b) {
        a = getN(a);
        b = getN(getN(b));
    }
    return b === 1 || getN(b) === 1 ;
};
```

```js
// 方法三：使用Set()更简洁
var getSum = function (n) {
    let sum = 0;
    while (n) {
        sum += (n % 10) ** 2;
        n =  Math.floor(n/10);
    }
    return sum;
}
var isHappy = function(n) {
    // 创建一个 Set 对象，用于记录每次计算过程中的数值，确保数值是唯一的
    let set = new Set();
    // 进入循环，直到出现以下情况之一：1. 计算结果为 1；2. 在循环中出现重复的数值
    while (n !== 1 && !set.has(n)) {
        // 将当前数值存入 Set 中，确保数值唯一
        set.add(n);
        // 根据计算函数获取下一个数值，继续判断是否为快乐数
        n = getSum(n);
    }
    // 如果循环结束时 n 等于 1，表示是快乐数；否则不是快乐数
    return n === 1;
};
```

### 1 [两数之和](https://leetcode.cn/problems/two-sum/)

> - 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
> - set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

![过程一](https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png)

> 在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

```js
var twoSum = function (nums, target) {
	const map = {};
    for(let i = 0; i<nums.length; i++) {
        map[nums[i]] = i;
    } 
    
    for(let i = 0; i < nums.length; i++) {
        const r = target - nums[i];
        if (map[r] != null && map[r] != i) {
            return [i, map[r]];
        }
    }
    return []
};
```

```js
var twoSum = function (nums, target) {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {  // 遍历当前元素，并在map中寻找是否有匹配的key
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;   // 如果没找到匹配对，就把访问过的元素和下标加入到map中
  }
  return [];
};
```

### 383 [赎金信](https://leetcode.cn/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

```js
var canConstruct = function(ransomNote, magazine) {
    const strArr = new Array(26).fill(0),  // 记录每个字符的出现次数
        base = "a".charCodeAt(); // 记录索引
    for(const s of magazine) {   // 遍历杂志中的每个字符，记录 magazine里各个字符出现次数
        strArr[s.charCodeAt() - base]++;
    }
    // 只要发现杂志中有足够的字符来构建勒索信，就将相应字符在记录次数的数组中减1，最终如果成功遍历了整个勒索信，就返回true
    for(const s of ransomNote) { // 遍历勒索信中的每个字符，对应的字符个数做--操作
        const index = s.charCodeAt() - base; // 计算字符在数组中的索引
        if(!strArr[index]) return false;  // 如果没记录过直接返回false
        strArr[index]--;
    }
    return true;
};
```

```js
var canConstruct = function(ransomNote, magazine) {
    //ransomNote要能够由magazine的字符组成，magazine的字符串长度必须比ransomNote长
    //使用map数据结构存放magazine中的字符及出现的次数
    //再遍历ransomNote，每次从map中获取的字符对应数量-1，若获取的字符数量小于等于0，则返回false
    if(ransomNote.length>magazine.length) return false;
    let map=new Map();
    for(let item of magazine){
        map.set(item,(map.get(item)||0)+1);
    }
    for(let item of ransomNote){
        if(!map.get(item)||map.get(item)<=0){
            return false;
        }
        map.set(item,map.get(item)-1);
    }
    return true;
};
```

### 454 [四数相加 II](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

> 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。定义int变量count，用来统计 a+b+c+d = 0 出现的次数。在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。最后返回统计值 count 就可以了。

```js
var fourSumCount = function(nums1, nums2, nums3, nums4) {
    const twoSumMap = new Map(); // const twoSumCount = {};
    let count = 0;
    
    // 统计nums1和nums2数组元素之和，和出现的次数，放到map中
    for(const n1 of nums1) {
        for(const n2 of nums2) {
            const sum = n1 + n2;
            twoSumMap.set(sum, (twoSumMap.get(sum) || 0) + 1)
            // twoSumCount[sum] = (twoSumCount[sum] || 0) + 1;
        }
    }
    
    // 找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来
    for(const n3 of nums3) {
        for(const n4 of nums4) {
            const sum = n3 + n4;
            count += (twoSumMap.get(0 - sum) || 0)
            // count += (twoSumCount[0 - sum] || 0);
        }
    }

    return count;
};
```

### 15 [三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

```js
var threeSum = function (nums) {
    if (nums.length <= 2) {
        return []
    }
    let res = []
    // 将输入数组按升序排序
    nums.sort((a, b) => a - b)
    // 将输入数组按升序排序
    for (let i = 0; i < nums.length; i++) {
        // 如果当前元素大于0，则无需继续，直接返回结果
        if (nums[i] > 0) break
        // 如果当前元素大于0，则无需继续，直接返回结果
        if (i > 0 && nums[i] == nums[i - 1]) continue
        
        let j = i + 1
        let k = nums.length - 1
        while (j < k) {
            let sum = nums[i] + nums[j] + nums[k]
            if (sum == 0) {
                res.push([nums[i], nums[j], nums[k]])
                // 跳过重复元素
                while (j < k && nums[j] == nums[j + 1]) j++
                while (j < k && nums[k] == nums[k - 1]) k--
                // 移动指针到下一个唯一元素
                j++
                k--
            } else if (sum < 0) {
                j++
            } else {
                k--
            }
        }
    }
    return res
};
```

### 18 [四数之和](https://leetcode.cn/problems/4sum/)

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

```js
var fourSum = function(nums, target) {
    const len = nums.length;
    if(len < 4) return [];
    nums.sort((a, b) => a - b);
    const res = [];
    for(let i = 0; i < len - 3; i++) {
        // 去重i
        if(i > 0 && nums[i] === nums[i - 1]) continue;
        for(let j = i + 1; j < len - 2; j++) {
            // 去重j
            if(j > i + 1 && nums[j] === nums[j - 1]) continue;
            let l = j + 1, r = len - 1;
            while(l < r) {
                const sum = nums[i] + nums[j] + nums[l] + nums[r];
                if(sum < target) { l++; continue}
                if(sum > target) { r--; continue}
                res.push([nums[i], nums[j], nums[l], nums[r]]);
		
		// 对nums[left]和nums[right]去重
                while(l < r && nums[l] === nums[++l]);
                while(l < r && nums[r] === nums[--r]);
            }
        } 
    }
    return res;
};
```



# d10 二叉树

## 01 树结构

#### 真实的树：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.6pnzzxbinjs0.png)

#### 树的特点：

- 树一般都有一个根，连接着根的是树干；
- 树干会发生分叉，形成许多树枝，树枝会继续分化成更小的树枝；
- 树枝的最后是叶子；

现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转 `180°` 的树。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4mrygbtnd6w0.png)

#### 树结构对比于数组/链表/哈希表有哪些优势呢？

数组：

- 优点：可以通过下标值访问，效率高；
- 缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；

链表：

- 优点：数据的插入和删除操作效率都很高；
- 缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。

哈希表：

- 优点：哈希表的插入/查询/删除效率都非常高；
- 缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。

树结构：

- 优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。

总的来说：每种数据结构都有自己特定的应用场景。

树结构：

- 树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n = 0 时，称为空树。

- 对于任意一棵非空树（n > 0），它具备以下性质：
  - 数中有一个称为根（Root）的特殊节点，用 **r** 表示；
  - 其余节点可分为 m（m > 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）。

#### 树的常用术语：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3t0ypfn5leo0.png)

- 节点的度（Degree）：节点的子树个数，比如节点 B 的度为 2；
- 树的度：树的所有节点中最大的度数，如上图树的度为 2；
- 叶节点（Leaf）：度为 0 的节点（也称为叶子节点），如上图的 H，I 等；
- 父节点（Parent）：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；
- 子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；
- 兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；
- 路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A->H 的路径长度为 3；
- 节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；
- 树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4；

#### 树结构的表示方式

##### 最普通的表示方法：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4v9sayu9zu60.png)

如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。 

这种方法缺点在于我们无法确定某一结点的引用数。

##### 儿子-兄弟表示法：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3o34yy6h0420.png)

这种表示方法可以完整地记录每个节点的数据，比如：

```js
//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}
```

这种表示法的优点在于每一个节点中引用的数量都是确定的。

##### 儿子-兄弟表示法旋转

以下为儿子-兄弟表示法组成的树结构：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.6tucreh71ok0.png)

将其顺时针旋转 45° 之后：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4blmsiyhevg0.png)

这样就成为了一棵二叉树，由此我们可以得出结论：任何树都可以通过二叉树进行模拟。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。

## 02 二叉树

### 二叉树的概念

如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；

### 二叉树的组成

- 二叉树可以为空，也就是没有节点；
- 若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；

### 二叉树的五种形态

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.15ycsg4fqoio.png)

上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。

### 二叉树的特性

- 一个二叉树的第 i 层的最大节点树为：2^(i-1)^，i >= 1；

- 深度为 k 的二叉树的最大节点总数为：2^k^ - 1 ，k >= 1；

- 对任何非空二叉树，若 n0 表示叶子节点的个数，n2表示度为 2 的非叶子节点个数，那么两者满足关系：n0= n2 + 1；

  如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n~0~ = n~2~ + 1 的规律。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.syjwffjltmo.png)

### 特殊的二叉树

#### 完美二叉树

完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.223b2axrocf4.png)

#### 完全二叉树

完全二叉树（Complete Binary Tree）:

- 除了二叉树最后一层外，其他各层的节点数都达到了最大值；
- 并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；
- 完美二叉树是特殊的完全二叉树；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5y4rglrp8qk0.png)

在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。

### 二叉树的数据存储

常见的二叉树存储方式为数组和链表：

#### 使用数组

- 完全二叉树：按从上到下，从左到右的方式存储数据。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.29w4k62b51og.png)

| 节点 |  A   |  B   |  C   |  D   |  E   |  F   |  G   |  H   |  I   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 序号 |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |

使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 _ 2，右子节点的序号等于父节点序号 _ 2 + 1 。

- 非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4jgiq6r2xee0.png)

| 节点 |  A   |  B   |  C   |  ^   |  ^   |  F   |  ^   |  ^   |  ^   |  ^   |  ^   |  ^   |  M   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 序号 |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |

#### 使用链表

二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2mlscfad5420.png)

## 03 二叉搜索树

二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。

二叉搜索树是一棵二叉树，可以为空。

如果不为空，则满足以下性质：

- 条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；
- 条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；
- 条件 3：左、右子树本身也都是二叉搜索树；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.1lhxcdph4vpc.png)

如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。

总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。

### 二叉搜索树应用举例

下面是一个二叉搜索树：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3l21fsg6qbc0.png)

若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。

- 第 1 次：将 10 与根节点 9 进行比较，由于 10 > 9，所以 10 下一步与根节点 9 的右子节点 13 比较；
- 第 2 次：由于 10 < 13，所以 10 下一步与父节点 13 的左子节点 11 比较；
- 第 3 次：由于 10 < 11，所以 10 下一步与父节点 11 的左子节点 10 比较；
- 第 4 次：由于 10 = 10，最终查找到数据 10 。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5x9xyvmbxy80.png)

同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2gqz4t2jekw0.png)

其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。

### 二叉搜索树的封装

二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5vdbb5to1n40.png)

所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。

```js
// 节点类
class Node {
  constructor(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}
```

### 二叉搜索树的常见操作：

- `insert(key)` 向树中插入一个新的键。
- `search(key)` 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 `false`。
- `preOrderTraverse` 通过先序遍历方式遍历所有节点。
- `inOrderTraverse` 通过中序遍历方式遍历所有节点。
- `postOrderTraverse` 通过后序遍历方式遍历所有节点。
- `min` 返回树中最小的值/键。
- `max` 返回树中最大的值/键。
- `remove(key)` 从树中移除某个键。

#### 插入数据

实现思路：

- 首先根据传入的 key 创建节点对象。
- 然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。
- 若存在根节点则重新定义一个内部方法 `insertNode()` 用于查找插入点。

insert(key) 代码实现

```js
// insert(key) 插入数据
insert(key) {
  const newNode = new Node(key);

  if (this.root === null) {
    this.root = newNode;
  } else {
    this.insertNode(this.root, newNode);
  }

}
```

insertNode() 的实现思路:

根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。

- 当 newNode.key < node.key 向左查找:

  - 情况 1：当 node 无左子节点时，直接插入：

  - 情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。

- 当 newNode.key >= node.key 向右查找，与向左查找类似：

  - 情况 1：当 node 无右子节点时，直接插入：

  - 情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。

insertNode(root, node) 代码实现

```js
insertNode(root, node) {

  if (node.key < root.key) { // 往左边查找插入

    if (root.left === null) {
      root.left = node;
    } else {
      this.insertNode(root.left, node);
    }

  } else { // 往右边查找插入

    if (root.right === null) {
      root.right = node;
    } else {
      this.insertNode(root.right, node);
    }

  }

}
```

#### 遍历数据  

这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：

- 先序遍历；
- 中序遍历；
- 后序遍历；

还有层序遍历，使用较少。

##### 先序遍历

先序遍历的过程为：

首先，遍历根节点；
然后，遍历其左子树；
最后，遍历其右子树；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.69ooahvtbbo0.png)

如上图所示，二叉树的节点遍历顺序为：A -> B -> D -> H -> I -> E -> C -> F -> G。【递归就是函数调用栈，会弹出而完成的函数】

代码实现：

```js
// 先序遍历（根左右 DLR）
// 外部调用
preorderTraversal() {
  const result = [];
  this.preorderTraversalNode(this.root, result); //把root传进来
  return result;
}

// 内部方法 遍历节点 从根节点开始遍历
preorderTraversalNode(node, result) {
  if (node === null) return result;
   // 处理经过的节点
  result.push(node.key);
   // 处理经过节点的左子节点 
  this.preorderTraversalNode(node.left, result);
   // 处理经过节点的右子节点    
  this.preorderTraversalNode(node.right, result);
}
```

##### 中序遍历

实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。

首先，遍历其左子树；
然后，遍历根（父）节点；
最后，遍历其右子树；

过程图解：【18-20-25图错了】

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.762l4sxdr7o0.png)

输出节点的顺序应为：3 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14 -> 15 -> 18 -> 20 -> 25 。

代码实现：

```js
// 中序遍历（左根右 LDR）
inorderTraversal() {
  const result = [];
  this.inorderTraversalNode(this.root, result);
  return result;
}

inorderTraversalNode(node, result) {
  if (node === null) return result;
  this.inorderTraversalNode(node.left, result);
  result.push(node.key);
  this.inorderTraversalNode(node.right, result);
}
```

##### 后序遍历

实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。

首先，遍历其左子树；
然后，遍历其右子树；
最后，遍历根（父）节点；

过程图解：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5lqmen4jds80.png)

输出节点的顺序应为：3 -> 6 -> 5 -> 8 -> 10 -> 9 -> 7 -> 12 -> 14 -> 13 -> 18 -> 25 -> 20 -> 15 -> 11 。

代码实现：

```js
// 后序遍历（左右根 LRD）
postorderTraversal() {
  const result = [];
  this.postorderTraversalNode(this.root, result);
  return result;
}

postorderTraversalNode(node, result) {
  if (node === null) return result;
  this.postorderTraversalNode(node.left, result);
  this.postorderTraversalNode(node.right, result);
  result.push(node.key);
}
```

##### 总结

以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。

#### 查找数据

##### 查找最大值或最小值

在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3h3yfhyqgi00.png)

代码实现：

```js
// min() 获取二叉搜索树最小值
min() {
  if (!this.root) return null;
  let node = this.root;
  while (node.left !== null) {
    node = node.left;
  }
  return node.key;
}

// max() 获取二叉搜索树最大值
max() {
  if (!this.root) return null;
  let node = this.root;
  while (node.right !== null) {
    node = node.right;
  }
  return node.key;
}
```

##### 查找特定值

查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key < key 则向左查找，若 node.key >  key 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。

代码实现：

```js
// search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false
search(key) {
  return this.searchNode(this.root, key);
}

// 通过递归实现
searchNode(node, key) {
  if (node === null) return false;
  if (key < node.key) {
    return this.searchNode(node.left, key);
  } else if (key > node.key) {
    return this.searchNode(node.right, key);
  } else {
    return true;
  }
}

// 通过 while 循环实现
search2(key) {
  let node = this.root;

  while (node !== null) {
    if (key < node.key) {
      node = node.left;
    } else if (key > node.key) {
      node = node.right;
    } else {
      return true;
    }
  }

  return false;

}
```

#### 删除数据

实现思路：

第一步：先找到需要删除的节点，若没找到，则不需要删除；

首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。

```js
let currentNode = this.root;
let parentNode = null;
let isLeftChild = true;

// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild
while (currentNode.key !== key) {
  parentNode = currentNode;

  // 小于，往左查找
  if (key < currentNode.key) {
    isLeftChild = true;
    currentNode = currentNode.left;
  } else {
    // 否则往右查找
    isLeftChild = false;
    currentNode = currentNode.right;
  }

  // 找到最后都没找到相等的节点，返回 false
  if (currentNode === null) {
    return false;
  }
}
```

第二步：删除找到的指定节点，后分 3 种情况：

- 删除的是叶子节点；
- 删除的是只有一个子节点的节点；
- 删除的是有两个子节点的节点；

##### 删除的是叶子节点

删除的是叶子节点分两种情况：

- 叶子节点也是根节点

  当该叶子节点为根节点时，如下图所示，此时 current == this.root，直接通过：this.root = null，删除根节点。

  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.1j9353rx9b7k.png)

- 叶子节点不为根节点

  当该叶子节点不为根节点时也有两种情况，如下图所示

  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3r99a6ocvug0.png)

  若 current = 8，可以通过：parent.left = null，删除节点 8；

  若 current = 10，可以通过：parent.right = null，删除节点 10；

  代码实现：

  ```js
  // 1、删除的是叶子节点的情况
  if (currentNode.left === null && currentNode.right === null) {
    if (currentNode === this.root) {
      this.root = null;
    } else if (isLeftChild) {
      parentNode.left = null;
    } else {
      parentNode.right = null;
    }
  }
  ```

##### 删除的是只有一个子节点的节点

有六种情况：

当 current 存在左子节点时（current.right == null）：

- 情况 1：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.left，删除根节点 11；

- 情况 2：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.left，删除节点 5；

- 情况 3：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.left，删除节点 9；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.27lwqd0qfnpc.png)

```js
// 2、删除的是只有一个子节点的节点
} else if (currentNode.right === null) { // currentNode 只存在左节点
  //-- 2.1、currentNode 只存在<左节点>的情况
  //---- 2.1.1、currentNode 等于 root
  //---- 2.1.2、parentNode.left 等于 currentNode
  //---- 2.1.3、parentNode.right 等于 currentNode

  if (currentNode === this.root) {
    this.root = currentNode.left;
  } else if (isLeftChild) {
    parentNode.left = currentNode.left;
  } else {
    parentNode.right = currentNode.left;
  }
```

当 current 存在右子节点时（current.left = null）：

- 情况 4：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.right，删除根节点 11。

- 情况 5：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.right，删除节点 5；

- 情况 6：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.right，删除节点 9；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3edzg72fx7y0.png)

代码实现：

```js
} else if (currentNode.left === null) { // currentNode 只存在右节点
  //-- 2.2、currentNode 只存在<右节点>的情况
  //---- 2.1.1 currentNode 等于 root
  //---- 2.1.1 parentNode.left 等于 currentNode
  //---- 2.1.1 parentNode.right 等于 currentNode

  if (currentNode === this.root) {
    this.root = currentNode.right;
  } else if (isLeftChild) {
    parentNode.left = currentNode.right;
  } else {
    parentNode.right = currentNode.right;
  }
```

##### 删除的是有两个子节点的节点

这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4g0geeyv6ya0.png)

**删除节点 9**

在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：

- 方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；
- 方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.73rduwimfvo0.png)

**删除节点 7**

在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：

- 方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；
- 方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2h9hjd5bhwo0.png)

**删除节点 15**

在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：

- 方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；
- 方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4f5tzwdvueq0.png)

相信你已经发现其中的规律了！

规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。

若用 current 表示需要删除的节点，则合适的节点指的是：

- current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；
- current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；

###### 前驱&后继

在二叉搜索树中，这两个特殊的节点有特殊的名字：

- 比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；
- 比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.71vg0g9z7io0.png)

查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；

查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。

下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。

代码实现：

```js
  // 3、删除的是有两个子节点的节点
  } else {

    // 1、找到后续节点
    let successor = this.getSuccessor(currentNode);

    // 2、判断是否为根节点
    if (currentNode === this.root) {
      this.root = successor;
    } else if (isLeftChild) {
      parentNode.left = successor;
    } else {
      parentNode.right = successor;
    }

    // 3、将后续的左节点改为被删除的左节点
    successor.left = currentNode.left;
  }
}
-------
// 获取后续节点，即从要删除的节点的右边开始查找最小的值
getSuccessor(delNode) {

  // 定义变量，保存要找到的后续
  let successorParent = delNode; (后继父节点15)
  let successor = delNode; (后继15)
  let current = delNode.right; (找到20) 


  // 循环查找 current 的右子树节点
  while (current !== null) {
    successorParent = successor; (让后继父节点等于后继15 => 再一次 让后继父节点等于后继20)
    successor = current; (后继等于找到的20 => 后继等于找到的18）
    current = current.left;(然后再找20的左子树18  => 然后再找18的左子树 为null 进行下面步骤)
  }

  // 判断寻找到的后续节点是否直接就是要删除节点的 right
  if (successor !== delNode.right) {
    successorParent.left = successor.right;(后继父节点20的左节点指向后继18的右节点19)
    successor.right = delNode.right;(让后继18的右节点指向15的右节点 20)
  }
  return successor;
}
```

##### 完整实现

```js
// 删除节点
remove(key) {

  let currentNode = this.root;
  let parentNode = null;
  let isLeftChild = true;

  // 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild
  while (currentNode.key !== key) {

    parentNode = currentNode;

    // 小于，往左查找
    if (key < currentNode.key) {
      isLeftChild = true;
      currentNode = currentNode.left;

    } else {  // 否则往右查找
      isLeftChild = false;
      currentNode = currentNode.right;
    }

    // 找到最后都没找到相等的节点，返回 false
    if (currentNode === null) {
      return false;
    }

  }


  // 1、删除的是叶子节点的情况
  if (currentNode.left === null && currentNode.right === null) {

    if (currentNode === this.root) {
      this.root = null;
    } else if (isLeftChild) {
      parentNode.left = null;
    } else {
      parentNode.right = null;
    }


    // 2、删除的是只有一个子节点的节点
  } else if (currentNode.right === null) { // currentNode 只存在左节点
    //-- 2.1、currentNode 只存在<左节点>的情况
    //---- 2.1.1、currentNode 等于 root
    //---- 2.1.2、parentNode.left 等于 currentNode
    //---- 2.1.3、parentNode.right 等于 currentNode

    if (currentNode === this.root) {
      this.root = currentNode.left;
    } else if (isLeftChild) {
      parentNode.left = currentNode.left;
    } else {
      parentNode.right = currentNode.left;
    }

  } else if (currentNode.left === null) { // currentNode 只存在右节点
    //-- 2.2、currentNode 只存在<右节点>的情况
    //---- 2.1.1 currentNode 等于 root
    //---- 2.1.1 parentNode.left 等于 currentNode
    //---- 2.1.1 parentNode.right 等于 currentNode

    if (currentNode === this.root) {
      this.root = currentNode.right;
    } else if (isLeftChild) {
      parentNode.left = currentNode.right;
    } else {
      parentNode.right = currentNode.right;
    }


    // 3、删除的是有两个子节点的节点
  } else {

    // 1、找到后续节点
    let successor = this.getSuccessor(currentNode);

    // 2、判断是否为根节点
    if (currentNode === this.root) {
      this.root = successor;
    } else if (isLeftChild) {
      parentNode.left = successor;
    } else {
      parentNode.right = successor;
    }

    // 3、将后续的左节点改为被删除的左节点
    successor.left = currentNode.left;
  }
}

// 获取后续节点，即从要删除的节点的右边开始查找最小的值
getSuccessor(delNode) {

  // 定义变量，保存要找到的后续
  let successor = delNode;
  let current = delNode.right;
  let successorParent = delNode;

  // 循环查找 current 的右子树节点
  while (current !== null) {
    successorParent = successor;
    successor = current;
    current = current.left;
  }

  // 判断寻找到的后续节点是否直接就是要删除节点的 right
  if (successor !== delNode.right) {
    successorParent.left = successor.right;
    successor.right = delNode.right;
  }
  return successor;
}
```

## 04 平衡树

二叉搜索树的缺陷：

当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.1nkd51rg5dz4.png)

当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.154bnlgtd5z4.png)

非平衡树：

- 比较好的二叉搜索树，它的数据应该是左右均匀分布的。
- 但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。
- 对于一棵平衡二叉树来说，插入/查找等操作的效率是 O(log n)。
- 而对于一棵非平衡二叉树来说，相当于编写了一个**链表**，查找效率变成了 O(n)。

树的平衡性：

为了能以较快的时间 O(log n)来操作一棵树，我们需要保证树总是平衡的：

- 起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；
- 这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；

常见的平衡树：

- AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。
- 红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入/删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。

### 红黑树

![img](https://upload-images.jianshu.io/upload_images/1102036-910b098459879227.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-e0e3ef8f2cb1504b.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 红黑树的变换

![img](https://upload-images.jianshu.io/upload_images/1102036-0f28363cfe43eb97.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-5c8f593fa574507b.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-c028a698d3f6ae86.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-7bd517969d78ea39.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-05efb34fa44d4162.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-1df9dd65cb0c88c2.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

### 红黑树的案例
![img](https://upload-images.jianshu.io/upload_images/1102036-d791cd8b5c6066d7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-5163c2303984aca3.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-cf9e6b85213d5c52.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-d763141e7a188d48.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-c621cc745ec51e4d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-cf78539acf806248.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-88877b186cc160bd.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-daec955db3e90471.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://upload-images.jianshu.io/upload_images/1102036-baf8867a3ff8d0d1.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

## 05 二叉树&Leetcode

![二叉树大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219190809451.png)

### 102 [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```javascript
var levelOrder = function(root) {
    //二叉树的层序遍历
    let res = [], queue = [];
    queue.push(root);
    if(root === null) {
        return res;
    }
    while(queue.length !== 0) {
        //记录当前层级节点数
        let length = queue.length;
        //存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            let node = queue.shift(); //取出队列中的节点
            curLevel.push(node.val);  //存入 curLevel 数组
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        res.push(curLevel);
    }
    return res;
};
```

### 107 [二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```js
var levelOrderBottom = function(root) {
    let res = [], queue = [];
    queue.push(root);
    while(queue.length && root!==null) {
        // 存放当前层级节点数组
        let curLevel = [];
        // 计算当前层级节点数量
        let length = queue.length;
        while(length--) {
            let node = queue.shift();
            curLevel.push(node.val); // 把当前层节点存入curLevel数组
            // 把下一层级的左右节点存入queue队列
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
	    // 从数组前头插入值，避免最后反转数组，减少运算时间
        res.unshift(curLevel);
    }
    return res;
};
```

### 104 [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

```js
var maxDepth = function(root) {
    if (root == null) return 0;
    const leftMaxDepth = maxDepth(root.left);
    const rightMaxDepth = maxDepth(root.right);
    return 1 + Math.max(leftMaxDepth, rightMaxDepth);
};
```

```js
var maxDepth = function(root) {
    if(!root) return 0
    let count = 0
    const queue = [root]
    while(queue.length) {
        let len = queue.length
        /* 层数+1 */
        count++
        while(len--) {
            let node = queue.shift();
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
    }
    return count
};
```

### 111 [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

```js
var minDepth = function(root) {
    if(!root) return 0;
    // 到叶子节点 返回 1
    if(!root.left && !root.right) return 1;
    // 只有右节点时 递归右节点
    if(!root.left) return 1 + minDepth(root.right);
    // 只有左节点时 递归左节点
    if(!root.right) return 1 + minDepth(root.left);
    return 1 + Math.min(minDepth(root.left), minDepth(root.right));
};
```

```js
var minDepth = function(root) {
    if(!root) return 0;
    const queue = [root];
    let dep = 0;
    while(true) {
        let len = queue.length;
        dep++;
        while(len--){
            const node = queue.shift();
            // 到第一个叶子节点 返回 当前深度 
            if(!node.left && !node.right) return dep;
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
    }
};
```

### 110 [平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是 平衡二叉树。

> 还是用递归三部曲 + 后序遍历 左右中 当前左子树右子树高度相差大于1就返回-1

```js
// 递归
var isBalanced = function(root) {
    // 1. 确定递归函数参数以及返回值
    const getDepth = function(node) {
        // 2. 确定递归函数终止条件
        if(node === null) return 0;
        // 3. 确定单层递归逻辑
        let leftDepth = getDepth(node.left); //左子树高度
        // 当判定左子树不为平衡二叉树时,即可直接返回-1
        if(leftDepth === -1) return -1;
        let rightDepth = getDepth(node.right); //右子树高度
        // 当判定右子树不为平衡二叉树时,即可直接返回-1
        if(rightDepth === -1) return -1;
        if(Math.abs(leftDepth - rightDepth) > 1) {
            return -1;
        } else {
            return 1 + Math.max(leftDepth, rightDepth);
        }
    }
    return !(getDepth(root) === -1);
};
```

### 236 [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

> 使用递归的方法
> 需要从下到上，所以使用后序遍历

```js
 var lowestCommonAncestor = function (root, p, q) {
    // 确定递归终止条件
    if (root === null || root === p || root === q)
        return root
	// 递归单层逻辑
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if (left && right) {
        return root
    }
	if(left === null) {
        return right;
    }
    return left;
};
```

### 124 [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

```js
var maxPathSum = function (root) {
    let maxSum = Number.MIN_SAFE_INTEGER
    function maxGain(node) {
       if (root == null) return 0;
       const left = maxGain(node.left) // 递归计算左子树的最大路径和
       const right = maxGain(node.right)
       // 更新 maxSum，比较以下几种情况的最大值：当前节点的值、包含左右子树的路径和、包含左子树的路径和、包含右子树的路径和
       maxSum = Math.max(maxSum, node.val, node.val + left + right, node.val + left, node.val + right)
       // 返回当前节点作为路径终点时的最大收益，考虑当前节点单独取值、与左子树的路径和、与右子树的路径和三种情况的最大值
       // return在 maxGain 函数中，我们需要返回以当前节点为根的子树中的最大路径和，而不是包含当前节点的最大路径和。因此，我们不能直接返回 maxSum，因为 maxSum 可能是以当前节点为根的整个树的最大路径和，而不是当前节点为根的子树的最大路径和。
       return Math.max(node.val, node.val + left, node.val + right)
    }
    maxGain(root) // 从根节点开始计算最大路径和
    return maxSum
};
```

### 103 [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

```js
function zigzagLevelOrder(root) {
    if (!root) return [];
    const result = [];
    const queue = [root];
    // 用于记录当前层级的奇偶性，初始为0
    let level = 0;
    
    // 当队列不为空时进行循环
    while (queue.length) {
        // 获取当前层级节点的数量
        const levelSize = queue.length;
        // 用于存储当前层级节点值的数组
        const currentLevel = [];
        // 遍历当前层级的节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            // 根据当前层级的奇偶性，决定节点值的顺序
            if (level % 2 === 0) {
                currentLevel.push(node.val);
            } else {
                currentLevel.unshift(node.val);
            }
            // 将节点的左右子节点加入队列中，以便遍历下一层级
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        // 将当前层级节点值的数组加入结果数组中
        result.push(currentLevel);
        // 切换到下一个层级，奇偶性加1
        level++;
    }
    
    // 返回最终结果数组
    return result;
}
```

### 98 [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

> 中序递增 转换成数组

```js
var isValidBST = function (root) {
    let pre = null;
    const inOrder = (root) => {
        if (root === null)  return true;
        // 递归遍历左子树
        let left = inOrder(root.left); 
		// 如果前一个节点不为空且大于等于当前节点的值，说明不满足BST的性质，返回false
        if (pre !== null && pre.val >= root.val)  return false;
        // 更新pre为当前节点
        pre = root;
 		// 递归遍历右子树
        let right = inOrder(root.right);
        return left && right;
    }
    return inOrder(root);
};
```

### 701 [二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

```js
var insertIntoBST = function(root, val) {
    if(root===null) return new TreeNode(val)
    // 如果要插入的值小于当前节点的值，则递归地插入到左子树中
    if(root.val>val) {
        root.left = insertIntoBST(root.left,val)
    // 如果要插入的值大于当前节点的值，则递归地插入到右子树中
    } else if(root.val<val) {
        root.right=insertIntoBST(root.right,val)
    }
    return root
};
```

# d11 图

## 01 图的概念

在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。

### 什么是图？

- 图是一种与树有些相似的数据结构。

  - 实际上，在数学的概念上，树是图的一种。
  - 我们知道树可以用来模拟很多现实的数据结构，比如：家谱/公司组织架构等等。

- 那么图长什么样子呢？或者什么样的数据使用图来模拟更合适呢？

  - 人与人之间的关系网
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4cdhxz0ereu0.png)

  - 互联网中的网络关系
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4ljxyy69a1s0.png)

  - 广州地铁图
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.46k2cvwmthw0.png)

- 那么，什么是图呢?

  - 我们会发现，上面的结点（其实图中叫顶点 Vertex）之间的关系，是不能使用树来表示（几叉树都不可以）。
  - 这个时候，我们就可以使用**图**来模拟它们。

- 图通常有什么特点呢？
  - 一组顶点：通常用 V (Vertex) 表示顶点的集合
  - 一组边：通常用 E (Edge) 表示边的集合
  - 边是顶点和顶点之间的连线
  - 边可以是有向的，也可以是无向的。（比如 A --- B，通常表示无向。 A --> B，通常表示有向）

### 图的术语

#### 术语

- 我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。
- 但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。
- 这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。
- 下面这是个抽象出来的图
  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.rr153grdbc0.png)

- 顶点

  - 顶点刚才我们已经介绍过了，表示图中的一个结点。
  - 比如地铁站中某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人。

- 边

  - 边表示顶点和顶点之间的连线。
  - 比如地铁站中两个站点之间的直接连线, 就是一个边。
  - 注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。

- 相邻顶点

  - 由一条边连接在一起的顶点称为相邻顶点。
  - 比如 `0 - 1` 是相邻的，`0 - 3` 是相邻的。`0 - 2` 是不相邻的。

- 度

  - 一个顶点的度是相邻顶点的数量
  - 比如 0 顶点和其他两个顶点相连，0 顶点的度是 2
  - 比如 1 顶点和其他四个顶点相连，1 顶点的度是 4

- 路径

  - 路径是顶点 `v1`，`v2`...，`vn` 的一个连续序列, 比如上图中 `0 1 5 9` 就是一条路径。
  - 简单路径: 简单路径要求不包含重复的顶点. 比如 `0 1 5 9` 是一条简单路径。
  - 回路：第一个顶点和最后一个顶点相同的路径称为回路。比如 `0 1 5 6 3 0`。

- 无向图

  - 上面的图就是一张无向图，因为所有的边都没有方向。
  - 比如 `0 - 1` 之间有边，那么说明这条边可以保证 `0 -> 1`，也可以保证 `1 -> 0`。

- 有向图

  - 有向图表示的图中的边是有方向的。
  - 比如 `0 -> 1`，不能保证一定可以 `1 -> 0`，要根据方向来定。

#### 无权图和带权图

- 无权图

  - 我们上面的图就是一张无权图（边没有携带权重）
  - 我们上面的图中的边是没有任何意义的，不能说 `0 - 1` 的边，比 `4 - 9` 的边更远或者用的时间更长。

- 带权图
  - 带权图表示边有一定的权重
  - 这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。
  - 我们来看一张有向和带权的图
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3q0nj5eq5p80.png)

### 现实建模

- 对交通流量建模

  - 顶点可以表示街道的十字路口，边可以表示街道.。
  - 加权的边可以表示限速或者车道的数量或者街道的距离。
  - 建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。

- 对飞机航线建模

  - 航空公司可以用图来为其飞行系统建模。
  - 将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。
  - 加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。
  - 建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。
    

## 02 图的表示

我们知道一个图包含很多顶点，另外包含顶点和顶点之间的连线（边），这两个都是非常重要的图信息，因此都需要在程序中体现出来。

### 顶点表示

- 顶点的表示相对简单

  - 上面的顶点，我们抽象成了 1 2 3 4，也可以抽象成 A B C D。在后面的案例中，我们使用 A B C D。
  - 那么这些 A B C D 我们可以使用一个数组来存储起来(存储所有的顶点)。
  - 当然，A B C D 有可能还表示其他含义的数据(比如村庄的名字)，这个时候，可以另外创建一个数组，用于存储对应的其他数据。

- 边的表示略微复杂
  - 因为边是两个顶点之间的关系，所以表示起来会稍微麻烦一些。
  - 下面是变常见的表示方式。

### 邻接矩阵

- 概述

  - 邻接矩阵让每个节点和一个整数向关联, 该整数作为数组的下标值.
  - 我们用一个二维数组来表示顶点之间的连接.
  - 演示
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.66y7l5b21nw0.png)

- 图片解析

  - 在二维数组中，0 表示没有连线，1 表示有连线。
  - 通过二维数组，我们可以很快的找到一个顶点和哪些顶点有连线。（比如 A 顶点, 只需要 遍历第一行即可）
  - 另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。

- 邻接矩阵的问题

  - 如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。

    - 也就是 A -> D 是 1 的时候，对称的位置 D -> 1 一定也是 1。
    - 那么这种情况下会造成空间的浪费，解决办法需自己去研究下。

  - 邻接矩阵还有一个比较严重的问题就是如果图是一个稀疏图
    - 那么矩阵中将存在大量的 0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。
    - 而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。

### 邻接表

- 概述

  - 邻接表由图中每个顶点以及和顶点相邻的顶点列表组成。
  - 这个列表有很多中方式来存储：数组/链表/字典(哈希表)都可以。
  - 演示
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3mu1hv8a84u0.png)

- 图片解析

  - 其实图片比较容易理解
  - 比如我们要表示和 A 顶点有关联的顶点（边），A 和 B/C/D 有边，那么我们可以通过 A 找到 对应的数组/链表/字典，再取出其中的内容就可以啦。

- 邻接表的问题
  - 邻接表计算“出度”是比较简单的（出度：指向别人的数量, 入度: 指向自己的数量）
  - 邻接表如果需要计算有向图的“入度”，那么是一件非常麻烦的事情。
  - 它必须构造一个“逆邻接表”，才能有效的计算“入度”。而临街矩阵会非常简单。

## 03 图的封装

### 创建图类

- 先来创建 Graph 类，定义了两个属性：
  - `vertexes` 用于存储所有的顶点，使用一个数组来保存。
  - `adjList` adj 是 adjoin 的缩写，邻接的意思。adjList 用于存储所有的边，这里采用邻接表的形式。

```js
class Graph {
  constructor() {
    this.vertexes = []; // 存储顶点
    this.adjList = new Dictionay(); //存储边信息
  }
}
```

### 添加方法

- 添加顶点：可以向图中添加一些顶点。
  - 将添加的顶点放入到数组中。
  - 另外，给该顶点创建一个数组`[]`，该数组用于存储顶点连接的所有的边.（回顾邻接表的实现方式）

```js
// 添加顶点
addVertex(val) {
    // 添加点
    this.vertexes.push(val)
    // 添加点的关系  采用邻接矩阵法 结构用Map
    this.adjList.set(val, [])
}
```

- 添加边：可以指定顶点和顶点之间的边。
  - 添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。
  - 根据顶点 v 取出对应的数组，将 w 加入到它的数组中。
  - 根据顶点 w 取出对应的数组，将 v 加入到它的数组中。
  - 因为这里实现的是无向图，所以边是可以双向的。

```js
// 添加边
addEdge(val1, val2) {
    // 添加边需要传入两个顶点, 因为边是两个顶点之间的边, 边不可能单独存在.
    // 这里实现的是无向图, 所以这里不考虑方向问题
    this.adjList.get(val1).push(val2)
    this.adjList.get(val2).push(val1)
}
```

toString 方法：为了能够正确的显示图的结果，就是拿出二维数组的每一项。

```js
// 输出图结构
toString() {
    let res = ''
    for (let i = 0; i < this.vertexes.length; i++) {
        res += this.vertexes[i] + "->"
        let adj = this.adjList.get(this.vertexes[i])
        for (let j = 0; j < adj.length; j++) {
            res += adj[j] + ""
        }
        res += "\n"
    }
    return res
}
```

### 测试代码

```js
// 测试代码
let graph = new Graph();

// 添加顶点
let myVertexes = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];
for (let i = 0; i < myVertexes.length; i++) {
  graph.addVertex(myVertexes[i]);
}

// 添加边
graph.addEdge("A", "B");
graph.addEdge("A", "C");
graph.addEdge("A", "D");
graph.addEdge("C", "D");
graph.addEdge("C", "G");
graph.addEdge("D", "G");
graph.addEdge("D", "H");
graph.addEdge("B", "E");
graph.addEdge("B", "F");
graph.addEdge("E", "I");
```

## 04 图的遍历

和其他数据结构一样，需要通过某种算法来遍历图结构中每一个数据。这样可以保证，在我们需要时，通过这种算法来访问某个顶点的数据以及它对应的边。

### 遍历的方式

图的遍历思想：

图的遍历算法的思想在于必须访问每个第一次访问的节点，并且追踪有哪些顶点还没有被访问到。有两种算法可以对图进行遍历

- 广度优先搜索(Breadth-First Search, 简称 BFS)

- 深度优先搜索(Depth-First Search, 简称 DFS)

  > 两种遍历算法，都需要明确指定第一个被访问的顶点。

遍历的注意点：

- 完全探索一个顶点要求我们便查看该顶点的每一条边。
- 对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。
- 为了保证算法的效率：每个顶点至多访问两次。

两种算法的思想：

- BFS 基于队列，入队列的顶点先被探索。

- DFS 基于栈，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。

  > 为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态。(或者两种颜色也可以)。
  >
  > 初始化颜色代码：

  ```js
  // 初始化顶点的颜色
  _initializeColor() {
      // 白色: 表示该顶点还没有被访问.
      // 灰色: 表示该顶点被访问过, 但并未被探索过.
      // 黑色: 表示该顶点被访问过且被完全探索过.
      let colors = []
      for (let i = 0; i < this.vertexes.length; i++) {
          colors[this.vertexes[i]] = "white"
      }
      return colors
  }
  ```

### 广度优先搜索(BFS)

#### 广度优先搜索算法的思路

广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。

#### 图解 BFS

![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3vz7fx7tgvs0.png)

#### 广度优先搜索的实现

1. 创建一个队列 Q
2. 将 v 标注为被发现的(灰色), 并将 v 将入队列 Q
3. 如果 Q 非空, 执行下面的步骤：
   - 将 v 从 Q 中取出队列
   - 将 v 标注为被发现的灰色
   - 将 v 所有的未被访问过的邻接点（白色），加入到队列中
   - 将 v 标志为黑色

#### 广度优先搜索的代码

```js
// 广度优先搜索
bfs(handle) {
    // 1.初始化颜色
    let color = this._initializeColor()
    // 2. 创建队列
    let queue = new Queue
    // 3. 将传入的顶点放入队列
    queue.enqueue(this.vertexes[0])
    // 4.依赖队列操作数据   队列不为空时一直持续
    while (!queue.isEmpty()) {
        // 4.1 拿到队头
        let qVal = queue.dequeue()
        //  4.2 拿到队头所关联（相连）的点并设置为访问中状态（灰色）
        let qAdj = this.adjList.get(qVal)
        color[qVal] = "gray"
        // 4.3 将队头关联的点添加到队尾
        // 这一步是完成bfs的关键，依赖队列的先进先出的特点。
        for (let i = 0; i < qAdj.length; i++) {
            let a = qAdj[i]
            if (color[a] === "white") {
                color[a] = "gray"
                queue.enqueue(a)
            }
        }
        // 4.5设置访问完的点为黑色。
        color[qVal] = "black"
        if (handle) [
            handle(qVal)
        ]
    }
}
```

测试代码

```js
// 调用广度优先算法
let result = "";
graph.bfs(graph.vertexes[0], function (v) {
  result += v + " ";
});
console.log(result); // A B C D E F G H I
```

### 深度优先搜索(DFS)

深度优先搜索的思路：

深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了。接着原路回退并探索下一条路径。

图解 DFS：
![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.1bjimck65r8g.png)

深度优先搜索算法的实现：

- 广度优先搜索算法我们使用的是队列，这里可以使用栈完成，也可以使用递归。
- 方便代码书写，我们还是使用递归(递归本质上就是函数栈的调用)

深度优先搜索算法的代码：

```js
// 深度优先搜索
dfs(handle) {
    // 1.初始化颜色
    let color = this._initializeColor()
    // 2. 遍历所有顶点，开始访问
    for (let i = 0; i < this.vertexes.length; i++) {
        if (color[this.vertexes[i]] === "white") {
            this._dfsVisit(this.vertexes[i], color, handle)
        }
    }
}
// dfs的递归方法  这里直接使用函数的调用栈
_dfsVisit(val, color, handle) {
    // 1. 将颜色设置为访问中
    color[val] = "gray"
    // 2. 执行相应的回调
    if (handle) {
        handle(val)
    }
    // 3. 拿与该点相邻的点，对每个点操作
    let adj = this.adjList.get(val)
    for (let i = 0; i < adj.length; i++) {
        let w = adj[i]
        // 如果相邻点未未访问状态，开始访问。
        if (color[w] === "white") {
            this._dfsVisit(w, color, handle)
        }
    }
    // 4. 处理完后设置为访问过点。
    color[val] = "black"
}
```

测试代码

```js
// 调用深度优先算法
result = "";
graph.dfs(function (v) {
  result += v + " ";
});
// 输出深度优先
console.log(result); //A B E I F C D G H
```

递归的代码较难理解一些，这副图来帮助理解过程：
![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.6z6nkgmevxo0.png) 

# d12 排序算法

[十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)](https://www.cnblogs.com/onepixel/p/7674659.html)

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

> 排序算法有很多: 冒泡排序/选择排序/插入排序/归并排序/计数排序(counting sort)/基数排序(radix sort)/希尔排序/堆排序/桶排序.
>
> 我们这里不一一列举它们的实现思想, 而是选择几个简单排序和高级排序.
>
> 简单排序: 冒泡排序 - 选择排序 - 插入排序
>
> 高级排序: 希尔排序 - 快速排序

## 01 排序介绍

> 我们先对排序有个简单的认识, 然后开始介绍几种简单排序.

- 一旦我们将数据放置在某个数据结构中存储起来后(比如数组), 就可能根据需求对数据进行不同方式的排序
  - 比如对姓名按字母排序
  - 对学生按年龄排序
  - 对商品按照价格排序
  - 对城市按照面积或者人口数量排序
  - 对恒星按照大小排序
  - 等等
- 由于排序非常重要而且可能非常耗时, 所以它已经成为一个计算机科学中广泛研究的课题, 而且人们已经研究出一套成熟的方案来实现排序.
  - 但是, 我们学习已有的排序方法是非常有必要的.

### 如何排序?

- 需求: 对一组身高不等的10个人进行排序
- 人来排序:
  - 如果是人来排序事情会非常简单, 因为人只要扫过去一眼就能看出来谁最高谁最低.
  - 然后让最低(或者最高)的站在前面, 其他人依次后移.
  - 按照这这样的方法. 依次类推就可以了.
- 计算机来排序:
  - 计算机有些笨拙, 它只能执行指令. 所以没办法一眼扫过去.
  - 计算机也很聪明, 只要你写出了正确的指令, 可以让它帮你做无数次类似的事情而不用担心出现错误.
  - 并且计算机排序也无需担心数据量的大小.(想象一样, 让人排序10000个, 甚至更大的数据项你还能一眼扫过去吗?)
  - 人在排序时不一定要固定特有的空间, 他们可以相互推推嚷嚷就腾出了位置, 还能互相前后站立.
  - 但是计算机必须有严密的逻辑和特定的指令.
- 计算机排序的特点:
  - 计算机不能像人一样, 一眼扫过去这样通览所有的数据.
  - 它只能根据计算机的比较操作原理, 在同一个时间对两个队员进行比较.
  - 在人类看来很简单的事情, 计算机的算法却不能看到全景, 因此它只能一步步解决具体问题和遵循一些简单的规则.
- 简单算法的主要操作:
  - 比较两个数据项.
  - 交换两个数据项, 或者复制其中一项.
  - 但是, 每种算法具体实现的细节有所不同.

### 创建列表

- 在开始排序前, 我们先来创建一个列表封装我们的数据项.

  ```javascript
  // 封装ArrayList
  function ArrayList() {
      // 属性
      this.array = []
      
  	// 方法
    	// 将数据插入数组中  
      ArrayList.prototype.insert = function (item) {
          this.array.push(item)
      }
  	// 转为字符串形式
      ArrayList.prototype.toString = function () {
          return this.array.join('-')
      }
  }
  ```

- 初始化数据项

  ```javascript
  // 初始化数据项
  var list = new ArrayList()
  
  list.insert(3)
  list.insert(6)
  list.insert(4)
  list.insert(2)
  list.insert(11)
  list.insert(10)
  list.insert(5)
  
  alert(list)
  ```

## 02 冒泡排序

> 冒泡排序算法相对其他排序运行效率较低, 但是在概念上它是排序算法中最简单的.
>
> 因此, 冒泡排序是在刚开始学习排序时, 最适合学习的一种排序方式.

#### 冒泡排序的思路

- 冒泡排序的思路:

  - 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
  - 如果左边的队员高, 则两队员交换位置
  - 向右移动一个位置, 比较下面两个队员
  - 当走到最右端时, 最高的队员一定被放在了最右边
  - 按照这个思路, 从最左端重新开始, 这次走到倒数第二个位置的队员即可.
  - 依次类推, 就可以将数据排序完成

- 冒泡排序的图解:

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-b8b1aca05ccf1b24?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

  img

- 思路再分析:

  - 第一次找出最高人放在最后, 我们需要两个两个数据项进行比较, 那么这个应该是一个循环操作.
  - 第二次将次高的人找到放在倒数第二个位置, 也是两个比较, 只是不要和最后一个比较(少了一次), 但是前面的两个两个比较也是一个循环操作.
  - 第三次...第四次...
  - 有发现规律吗? 这应该是一个循环中嵌套循环, 并且被嵌套的循环次数越来越少的.
  - 根据这个分析, 你能写出代码实现吗?   

#### 冒泡排序的实现

- 冒泡排序的实现:

  > 一轮轮比较，每一轮都从第一项开始，用当前项A和后一项B比较，如果A>B，就交换位置，每轮比较后当前数组最大的放到末尾，每次循环的长度都少一次。

  ```js
  function bubble_sort(arr) {
    // 外层循环控制比较的轮次
    for (let i = 0; i < arr.length - 1; i++) {
      // 内层循环控制每一轮比较的次数
      for (let j = 0; j < arr.length - 1-i; j++) {
        if (arr[i] > arr[i + 1]) {
          // 交换  
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        }
      }
    }
  }
  ```

  ```javascript
  ArrayList.prototype.bubbleSort = function () {
      // 1.获取数组的长度
      var length = this.array.length
  
      // 2.反向循环, 因此次数越来越少
      for (var i = length - 1; i >= 0; i--) {
          // 3.根据i的次数, 比较循环到i位置
          for (var j = 0; j < i; j++) {
              // 4.如果j位置比j+1位置的数据大, 那么就交换
              if (this.array[j] > this.array[j+1]) {
                  // 交换
                  this.swap(j, j+1)
              }
          }
      }
  }
  
  ArrayList.prototype.swap = function (m, n) {
      var temp = this.array[m]
      this.array[m] = this.array[n]
      this.array[n] = temp
  }
  ```

  对于冒泡排序来说，能不能传入第二个参数（参数为函数），来控制升序和降序？

  ```javascript
  function buddle_sort(arr, Func) {
    let length = arr.length
    for (let j = arr.length - 1; j > 0; j--) {
      for (let i = 0; i < j; i++) {
        if (Func(arr[j], arr[j + 1]) > 0) {
  		// 交换  
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        }
      }
    }
    return arr;
  }
  
  let arr = [7, 4, 3, 67, 34, 1, 8]
  buddle_sort(arr, (a, b) => a - b) // 升序排序 [ 1, 3, 4, 7, 8, 34, 67 ]
  buddle_sort(arr, (a, b) => b - a) // 降序排序 [ 67, 34, 8, 7, 4, 3, 1 ]
  ```

- 代码解析:

  - 代码序号1: 获取数组的长度.
  - 代码序号2: 我们现在要写的外层循环, 外层循环应该让i依次减少, 因此我们这里使用了反向的遍历.
  - 代码需要3: 内层循环, 内层循环我们使用 j < i. 因为上面的i在不断减小, 这样就可以控制内层循环的次数.
  - 代码需要4: 比较两个数据项的大小, 如果前面的大, 那么就进行交换.

- 代码图解流程:

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-143b34a96f876463?imageMogr2/auto-orient/strip|imageView2/2/w/1167/format/webp)

- 测试代码:

  ```javascript
  // 测试冒泡排序
  list.bubbleSort()
  alert(list) // 2,3,4,5,6,10,11
  ```

#### 冒泡排序的效率

- 冒泡排序的比较次数:
  
  如果按照上面的例子来说, 一共有7个数字, 那么每次循环时进行了几次的比较呢?
  
  第一次循环6次比较, 第二次5次比较, 第三次4次比较....直到最后一趟进行了一次比较.
  
  - 对于7个数据项比较次数: 6 + 5 + 4 + 3 + 2 + 1
  
  - 对于N个数据项呢? (N - 1) + (N - 2) + (N - 3) + ... + 1 = N * (N - 1) / 2
- 大O表示法:
  
  大O表示法是描述性能和复杂度的一种表示方法.
  
  推导大O表示法通常我们会使用如下规则:
  - 用常量1取代运行时间中的所有加法常量
  - 在修改后的运行次数函数中, 只保留最高阶项
  - 如果最高阶项存在并且不是1, 则去除与这个项相乘的常数.
- 通过大O表示法推到过程, 我们来推到一下冒泡排序的大O形式：
  - N * (N - 1) / 2 = N²/2 - N/2,根据规则2, 只保留最高阶项, 编程N² / 2
  - N² / 2, 根据规则3, 去除常量, 编程N²
  - 因此**冒泡排序的大O表示法为O(N²)**
- 冒泡排序的交换次数：
  
  - 如果有两次比较才需要交换一次(不可能每次比较都交换一次.), 那么交换次数为N² / 4
  - 由于常量不算在大O表示法中, 因此, 我们可以认为交换次数的大O表示也是O(N²)

## 03 选择排序

> 选择排序改进了冒泡排序, 将交换的次数由O(N²)减少到O(N), 但是比较的次数依然是O(N²)

#### 选择排序的思路

- 选择排序的思路:

  - 选定第一个索引位置，然后和后面元素依次比较
  - 如果后面的队员, 小于第一个索引位置的队员, 则交换位置
  - 经过一轮的比较后, 可以确定第一个位置是最小的
  - 然后使用同样的方法把剩下的元素逐个比较即可
  - 可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后

- 选择排序的图解

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-c570275e3deb7504?imageMogr2/auto-orient/strip|imageView2/2/w/464/format/webp)

  img

- 思路再分析:

  - 选择排序第一次将第0位置的人取出, 和后面的人(1, 2, 3...)依次比较, 如果后面的人更小, 那么就交换.
  - 这样经过一轮之后, 第一个肯定是最小的人.
  - 第二次将第1位置的人取出, 和后面的人(2, 3, 4...)依次比较, 如果后面的人更小, 那么就交换.
  - 这样经过第二轮后, 第二个肯定是次小的人.
  - 第三轮...第四轮...直到最后就可以排好序了. 有发现规律吗?
  - 外层循环依次取出0-1-2...N-2位置的人作为index(N-1不需要取了, 因为只剩它一个了肯定是排好序的)
  - 内层循环从index+1开始比较, 直到最后一个.
  - 经过分析, 你能写出最终的算法吗?

#### 选择排序的实现

- 选择排序的实现:

  ```javascript
  ArrayList.prototype.selectionSort = function () {
      // 1.获取数组的长度
      var length = this.array.length
  
      // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
      for (var i = 0; i < length - 1; i++) {
          // 3.内层循环: 从取数据的后一个位置，即i+1位置开始，依次和min位置比较
          var min = i //当前取数据的位置，最小位置是i
          for (var j = min + 1; j < length; j++) {
              // 4.如果i位置的数据大于j位置的数据, 那么记录最小的位置
              if (this.array[min] > this.array[j]) {
                  min = j // j小 就让min等于j
              }
          }
          // 5.交换min和i位置的数据 
          // 一轮比较完 把找到的最小位置的数和取数据的位置交换 然后取下一个数据
          this.swap(min, i)
      }
  }
  // 每次把找到的最小的数放到前面
  ```
  
- 代码解析:

  - 代码序号1: 依然获取数组的长度.
  - 代码序号2: 外层循环, 我们已经讲过, 需要从外层循环的第0个位置开始, 依次遍历到length - 2的位置.
  - 代码序号3: 先定义一个min, 用于记录最小的位置, 内层循环, 内层循环是从i+1位置开始的数据项, 和i位置的数据项依次比较, 直到length-1的数据项.
  - 代码序号4: 如果比较的位置i的数据项, 大于后面某一个数据项, 那么记录最小位置的数据.
  - 代码序号5: 将min位置的数据, 那么i位置的数据交换, 那么i位置就是正确的数据了.
  - 注意: 这里的交换是基于之前的交换方法, 这里直接调用即可.

- 代码图解流程:

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-71ccc1ed70cb90c8?imageMogr2/auto-orient/strip|imageView2/2/w/938/format/webp)

  img

- 测试代码:

  ```javascript
  // 测试选择排序
  list.selectionSort()
  alert(list) // 2,3,4,5,6,10,11
  ```

#### 选择排序的效率

- 选择排序的比较次数:
  - 选择排序和冒泡排序的比较次数都是N*(N-1)/2, 也就是O(N²).
- 选择排序的交换次数:
  - 选择排序的交换次数只有N-1次, 用大O表示法就是O(N).
  - 所以选择排序通常认为在执行效率上是高于冒泡排序的.

## 04 插入排序

> 插入排序是简单排序中效率最好的一种，插入排序也是学习其他高级排序的基础，比如希尔排序/快速排序，所以也非常重要。
>

#### 插入排序的思路

- 局部有序:

  插入排序思想的核心是局部有序。 什么是局部有序呢? 比如在一个队列中的人, 我们选择其中一个作为标记的队员，这个被标记的队员左边的所有队员已经是局部有序的。这意味着，有一部门人是按顺序排列好的，有一部分还没有顺序。

- 插入排序的思路:

  - 从第一个元素开始，该元素可以认为已经被排序
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描
  - 如果该元素（已排序）大于新元素，将该元素移到下一位置
  - 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置
  - 将新元素插入到该位置后, 重复上面的步骤.

- 插入排序的图解

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-bd898c9bfd2f1540?imageMogr2/auto-orient/strip|imageView2/2/w/383/format/webp)

  img

- 思路再分析:

  - 插入排序应该从下标值1开始(因为0位置默认可以被认为是有序的)
  - 从1位置开始取出元素, 并且判断该元素的大小和0位置进行比较, 如果1位置元素小于0位置元素, 那么交换, 否则不交换.
  - 上面步骤执行完成后, 0 - 1位置已经排序好.
  - 取出2位置的元素, 和1位置进行比较:
    - 如果2位置元素大于1位置元素, 说明2位置不需要任何动作. 0 - 1 - 2已经排序好.
    - 如果2位置元素小于1位置元素, 那么将1移动到2的位置, 并且2继续和0进行比较.
    - 如果2位置元素大于0位置的元素, 那么将2位置放置在1的位置, 排序完成. 0 - 1 - 2搞定.
    - 如果2位置元素小于1位置的元素, 那么将0位置的元素移动到1位置, 并且将2位置的元素放在0位置, 0 - 1 - 2搞定.
  - 按照上面的步骤, 依次找到最后一个元素, 整个数组排序完成.
  - 经常上面的分析, 你能转化成对应的代码吗?

#### 插入排序的实现

- 插入排序的实现:

  > 抓牌 从后往前比 新抓的牌比手里的某张牌大了 就插入到它后面 比到头都没有更小的 就放到第一位
  
  ```js
  function insert(ary){
      //1.准备一个新数组，用来存储抓到手里的牌，开始先抓一张牌进来
      let handle=[];
      handle.push(ary[0]);
      //2.从第二项开始依次抓牌，一直到把台面上的牌抓光
      for(let i=1; i<ary.length; i++){
          // A是新抓的牌
          let A=ary[i];
          // 和手里的牌依次比较(从后向前比)
          for(let j=handle.length-1; j>=0; j--){ //每一次要比较的手里的牌
              let B=handle[j];
              // 如果当前新牌A比要比较的牌B大了，把A放到B的后面
              if(A>B) {
                  handle.splice(j+1,0,A);
                  break;
              }
              //已经比到第一项，我们把新牌放到手中最前面即可
              if(i===0){
                  handle.unshift(A);
              }
       	}
     }
     return ary;
  }
  ```
  
  ```javascript
  ArrayList.prototype.insertionSort = function () {
      // 1.获取数组的长度
      var length = this.array.length
  
      // 2.外层循环: 外层循环是从1位置开始（0位置有序）, 依次遍历到最后
      for (var i = 1; i < length; i++) {
          // 3.记录选出的元素, 放在变量temp中
          var j = i
          var temp = this.array[i]
  
          // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环 与前一个位置比较
          while (this.array[j-1] > temp && j > 0) {
              this.array[j] = this.array[j-1] //把j-1元素放到j位置
              j-- //然后再来到j-1前一个位置比较
          }
  
          // 5.将选出的j位置, 放入temp元素
          this.array[j] = temp
      }
  }
  ```
  
- 代码解析

  - 代码序号1: 获取数组的长度.
  - 代码序号2: 外层循环, 从1位置开始, 因为0位置可以默认看成是有序的了.
  - 代码序号3: 记录选出的i位置的元素, 保存在变量temp中. i默认等于j
  - 代码序号4: 内层循环
    - 内层循环的判断j - 1位置的元素和temp比较, 并且j > 0.
    - 那么就将j-1位置的元素放在j位置.
    - j位置向前移.
  - 代码序号5: 将目前选出的j位置放置temp元素.

- 代码的图解流程(来自维基百科):

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-d483d919e7bc7a76?imageMogr2/auto-orient/strip|imageView2/2/w/300/format/webp)

- 测试代码:

  ```javascript
  // 测试插入排序
  list.insertionSort()
  alert(list) // 2,3,4,5,6,10,11
  ```

#### 插入排序的效率

- 插入排序的比较次数:
  - 第一趟时, 需要的最多次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次.
  - 因此是1 + 2 + 3 + ... + N - 1 = N * (N - 1) / 2.
  - 然而每趟发现插入点之前, 平均只有全体数据项的一半需要进行比较.
  - 我们可以除以2得到 N * (N - 1) / 4. 所以相对于选择排序, 其他比较次数是少了一半的.
- 插入排序的复制次数:
  - 第一趟时, 需要的最多复制次数是1, 第二趟最多次数是2, 依次类推, 最后一趟是N-1次.
  - 因此是1 + 2 + 3 + ... + N - 1 = N * (N - 1) / 2.
- 对于基本有序的情况
  - 对于已经有序或基本有序的数据来说, 插入排序要好很多.
  - 当数据有序的时候, while循环的条件总是为假, 所以它变成了外层循环中的一个简单语句, 执行N-1次.
  - 在这种情况下, 算法运行至需要N(N)的时间, 效率相对来说会更高.
  - 另外别忘了, 我们的比较次数是选择排序的一半, 所以这个算法的效率是高于选择排序的.

## 05 希尔排序

> 希尔排序是插入排序的一种高效的改进版, 并且效率比插入排序要更快.

#### 希尔排序的介绍

- 希尔排序的历史背景:

  - 希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。
  - 我们知道, 优先的排序算法首要条件就是速度. 在简单排序出现后的很多一段时间内, 人们发明了各种各样的算法. 但是最终发现算法的时间复杂度都是O(N²), 似乎没法超越了.
  - 此时, 计算机学术界充斥着"排序算法不可能突破O(N²)"的声音. 就像之前普遍认为人类100米短跑不可能突破10秒大关一样.
  - 终于有一天, 一位科学家发布超越了O(N²)的新排序算法(后来为了纪念这个里程碑, 用Shell来命名了该算法).
  - 紧接着出现了好几种可以超越O(N²)的排序算法, 我们后面将的快速排序也是其中之一.

- 回顾插入排序:

  - 由于希尔排序基于插入排序, 所以有必须回顾一下前面的插入排序.
  - 我们设想一下, 在插入排序执行到一半的时候, 标记符左边这部分数据项都是排好序的, 而标识符右边的数据项是没有排序的.
  - 这个时候, 取出指向的那个数据项, 把它存储在一个临时变量中, 接着, 从刚刚移除的位置左边第一个单元开始, 每次把有序的数据项向右移动一个单元, 直到存储在临时变量中的数据项可以成功插入.

- 插入排序的问题:

  - 假设一个很小的数据项在很靠近右端的位置上, 这里本来应该是较大的数据项的位置.
  - 把这个小数据项移动到左边的正确位置, 所有的中间数据项都必须向右移动一位.
  - 如果每个步骤对数据项都进行N次复制, 平均下来是移动N/2, N个元素就是 N*N/2 = N²/2.
  - 所以我们通常认为插入排序的效率是O(N²)
  - 如果有某种方式, 不需要一个个移动所有中间的数据项, 就能把较小的数据项移动到左边, 那么这个算法的执行效率就会有很大的改进.

- 希尔排序的做法:

  - 比如下面的数字, 81, 94, 11, 96, 12, 35, 17, 95, 28, 58, 41, 75, 15.
  - 我们先让间隔为5, 进行排序. (35, 81), (94, 17), (11, 95), (96, 28), (12, 58), (35, 41), (17, 75), (95, 15)
  - 排序后的新序列, 一定可以让数字离自己的正确位置更近一步.
  - 我们再让间隔位3, 进行排序. (35, 28, 75, 58, 95), (17, 12, 15, 81), (11, 41, 96, 94)
  - 排序后的新序列, 一定可以让数字离自己的正确位置又近了一步.
  - 最后, 我们让间隔为1, 也就是正确的插入排序. 这个时候数字都离自己的位置更近, 那么需要复制的次数一定会减少很多.

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-18698fe457fe8d02?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  img

- 选择合适的增量:

  - 在希尔排序的原稿中, 他建议的初始间距是N / 2, 简单的把每趟排序分成两半.
  - 也就是说, 对于N = 100的数组, 增量间隔序列为: 50, 25, 12, 6, 3, 1.
  - 这个方法的好处是不需要在开始排序前为找合适的增量而进行任何的计算.
  - 我们先按照这个增量来实现我们的代码.

#### 希尔排序的实现

- 希尔排序的实现:

  ```javascript
  ArrayList.prototype.shellSort = function () {
      // 1.获取数组的长度
      var length = this.array.length
  
      // 2.根据长度计算增量 取整
      var gap = Math.floor(length / 2)
  
      // 3.增量不断变小, 大于0就继续排序
      while (gap > 0) {
          // 4.实现插入排序 以gap为间隔 进行分组
          for (var i = gap; i < length; i++) {
              // 4.1.保存临时变量
              var temp = this.array[i] //把gap位置元素取出来 和前一个间隔gap的元素比较 35和81比
              var j = i // 35
  
              // 4.2.插入排序的内层循环 
              // 比较相隔 gap 位置的元素 如果需要，它会交换元素，以 gap 的增量遍历数组
              while (this.array[j - gap] > temp && j > gap - 1) {
                  this.array[j] = this.array[j - gap] // 把j - gap的元素81放到j35的位置
                  j -= gap // 现在再与j-gap前一个元素j-gap-gap比较
              }
  
              // 4.3.将选出的j位置设置为temp
              this.array[j] = temp
          }
        
          // 5.重新计算新的间隔
          gap = Math.floor(gap / 2)
      }
  }
  ```
  
- 代码解析

  - 代码序号1: 获取数组的长度
  - 代码序号2: 计算第一次的间隔, 我们按照希尔提出的间隔实现.
  - 代码序号3: 增量不断变小, 大于0就继续改变增量
  - 代码序号4: 实际上就是实现了插入排序
    - 代码序号4.1: 保存临时变量, j位置从i开始, 保存该位置的值到变量temp中
    - 代码序号4.2: 内层循环, j > gap - 1并且temp大于this.array[j - gap], 那么就进行复制.
    - 代码序号4.3: 将j位置设置为变量temp
  - 代码序号5: 每次while循环后都重新计算新的间隔.

- 测试代码:

  ```javascript
  // 测试希尔排序
  list.shellSort()
  alert(list)
  ```

#### 希尔排序的效率

- 希尔排序的效率
  - 希尔排序的效率很增量是有关系的.
  - 但是, 它的效率证明非常困难, 甚至某些增量的效率到目前依然没有被证明出来.
  - 但是经过统计, 希尔排序使用原始增量, 最坏的情况下时间复杂度为O(N²), 通常情况下都要好于O(N²)
- Hibbard 增量序列
  - 增量的算法为2^k - 1. 也就是为1 3 5 7...等等.
  - 这种增量的最坏复杂度为O(N^3/2), 猜想的平均复杂度为O(N^5/4), 目前尚未被证明.
- Sedgewick增量序列
  - {1, 5, 19, 41, 109, … }, 该序列中的项或者是9*4^i - 9\*2^i + 1或者是4^i - 3*2^i + 1
  - 这种增量的最坏复杂度为O(N^4/3), 平均复杂度为O(N^7/6), 但是均未被证明.
- 总之, 我们使用希尔排序大多数情况下效率都高于简单排序, 甚至在合适的增量和N的情况下, 还好好于快速排序.

## 06 快速排序

> 快速排序几乎可以说是目前所有排序算法中, 最快的一种排序算法.
>
> 当然, 没有任何一种算法是在任意情况下都是最优的, 比如希尔排序确实在某些情况下可能好于快速排序. 但是大多数情况下, 快速排序还是比较好的选择.

#### 快速排序的介绍

- 快速排序的重要性:

  - 如果有一天你面试的时候, 让你写一个排序算法, 你可以洋洋洒洒的写出多个排序算法, 但是如果其中没有快速排序, 那么证明你对排序算法也只是浅尝辄止, 并没有深入的研究过.
  - 因为快速排序可以说是排序算法中最常见的, 无论是C++的STL中, 还是Java的SDK中其实都能找到它的影子.
  - 快速排序也被列为20世纪十大算法之一.

- 快速排序是什么?

  - 希尔排序相当于插入排序的升级版, 快速排序其实是我们学习过的最慢的冒泡排序的升级版.
  - 我们知道冒泡排序需要经过很多次交换, 才能在一次循环中, 将最大值放在正确的位置.
  - 而快速排序可以在一次循环中(其实是递归调用)找出某个元素的正确位置, 并且该元素之后不需要任何移动.

- 快速排序的思想:

  - 快速排序最重要的思想是分而治之.
  - 比如我们下面有这样一顿数字需要排序:
    - 第一步: 从其中选出了65. (其实可以是选出任意的数字, 我们以65举个栗子)
    - 第二步: 我们通过算法: 将所有小于65的数字放在65的左边, 将所有大于65的数字放在65的右边.
    - 第三步: 递归的处理左边的数据.(比如你选择31来处理左侧), 递归的处理右边的数据.(比如选择75来处理右侧, 当然选择81可能更合适)
    - 最终: 排序完成
  - 和冒泡排序不同的是什么呢?
    - 我们选择的65可以一次性将它放在最正确的位置, 之后不需要任何移动.
    - 需要从开始位置两个两个比较, 如果第一个就是最大值, 它需要一直向后移动, 直到走到最后.
    - 也就是即使已经找到了最大值, 也需要不断继续移动最大值. 而插入排序对数字的定位是一次性的.

  ![img](https:////upload-images.jianshu.io/upload_images/1102036-30f0c7dfac490247?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)


#### 快速排序的枢纽

- 在快速排序中有一个很重要的步骤就是选取枢纽(pivot也人称为主元).

- 如何选择才是最合适的枢纽呢?

  - 一种方案是直接选择第一个元素作为枢纽.

    - 但第一个作为枢纽在某些情况下, 效率并不是特别高.

    ![img](https:////upload-images.jianshu.io/upload_images/1102036-0d1429cb140fcd0a?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

    img

  - 另一种方案是使用随机数:

    - 随机取 pivot？但是随即函数本身就是一个耗性能的操作.

  - 另一种比较优秀的解决方案: 取头、中、尾的中位数

    - 例如 8、12、3的中位数就是8

- 枢纽选择的代码实现:

  ```javascript
  // 选择枢纽
  ArrayList.prototype.median = function (left, right) {
      // 1.求出中间的位置
      var center = Math.floor((left + right) / 2)
  
      // 2.判断并且进行交换 三个数两两相比
      if (this.array[left] > this.array[center]) {
          this.swap(left, center)
      }
      if (this.array[center] > this.array[right]) {
          this.swap(center, right)
      }
      if (this.array[left] > this.array[right]) {
          this.swap(left, right)
      }
  
      // 3.巧妙的操作: 将center移动到right - 1的位置.
      this.swap(center, right - 1)
  
      // 4.返回pivot
      return this.array[right - 1]
  }
  ```
  
- 代码解析:

  - 我们封装了一个函数, 该函数用于选择出来合适的枢纽.
  - 该函数要求传入left和right, 这样可以根据left和right求出一个center, 在选择它们三者的中位数.
    - 代码序号1: 根据left/right求出center.
    - 代码序号2: 将left放在最前面, 将center放在中间, 将right放在右边.
    - 代码序号3: 这里有一个巧妙的操作, 我们将pivot值放在了right的紧挨着的左边, 为什么这样操作呢?
      - 这样操作的目的是在之后交换的时候, pivot的值不需要移动来移动去.
      - 可以在最后选定位置后, 直接再交换到正确的位置即可(也是最终的位置).
    - 代码序号4: 返回选择出来的枢纽.

- 测试代码:

  ```javascript
  // 测试中位数选取
  // 原来的数组: 3,6,4,2,11,10,5
  var pivot = list.median(1, 6) // left:6 right:5 center:2
  alert(pivot) // pivot:5
  alert(list) // 3,2,4,10,11,5,6
  ```

#### 快速排序的实现

下面我们来写出快速排序的实现：

> `quickSort` 函数是快速排序的入口，首先检查子数组的大小是否大于 1，如果是，就调用 `partition` 函数找到分割点 `pivot`，然后递归对左右两个子数组进行排序。
>
> `partition` 函数选择子数组的最后一个元素作为基准值 `target`，通过遍历将小于目标值的元素移到数组前面，并将目标值放到中间位置，最终返回基准值的新位置。

```js
function quick(ary){
    // 4.结束递归:(当ARY中小于等于一项，则不用处理)
	if(ary.length<=1){
		return ary;
    }
	// 1.找到数组的中间项，在原有的数组中把它移除
	let middleIndex = Math.floor(ary.length/2);
	let middleValue = ary.splice(middleIndex,1)[0];
	// 2.准备左右两个数组，循环剩下数组中的每一项，比当前项小的放到左边数组中，反之放右边
	let aryleft=[],
		aryRight=[];
	for(let i=0;i<ary.length;i++){
        let item=ary[i];
		item<middleValue? 
            aryLeft.push(item):
        	aryRight.push(item);
	// 3.递归方式让左右两边的数组持续这样处理，一直到左右两边都排好序为止(最后让2为最后的结果)
	return quick(aryLeft).concat(middleValue,quick(aryRight));
}
```

```javascript
// 快速排序实现
ArrayList.prototype.quickSort = function () {
    this.quickSortRec(0, this.array.length - 1)
}

ArrayList.prototype.quickSortRec = function (left, right) {
    // 0.递归结束条件
    if (left >= right) return
    // 1.获取枢纽
    var pivot = this.median(left, right)  //枢纽在倒数第2位
    // 2.开始进行交换
    // 2.1.记录左边开始位置和右边开始位置
    var i = left
    var j = right - 1  //当前枢纽在的位置
    // 2.2.循环查找位置
    while (true) {
        while (this.array[++i] < pivot) { } // i开始 要找到大于枢纽的 因为左边放小的
        while (this.array[--j] > pivot) { } // j开始 要找到小于枢纽的
        if (i < j) {  //左边找的的大数与右边找到的小数 交换
            // 2.3.交换两个数值
            this.swap(i, j)
        } else {
        // 2.4.当i<j的时候(一定不会=, 看下面解释中的序号3), 停止循环因为两边已经找到了相同的位置
            break
        }
    }
    // 3.将枢纽放在正确的位置
    this.swap(i, right - 1)  //这样就得到了枢纽左边都比他小 右边都比它大

    // 4.递归调用左边
    this.quickSortRec(left, i - 1)
    this.quickSortRec(i + 1, right)
}
```

```js
function quickSort(arr) {
  const pivot = arr[0];  //选择第一个数作为枢纽
  const left = [];
  const right = [];
  
  if (arr.length < 2) { return arr; }
  let len = arr.length;
    
  for (let i = 1,  i < len; i++) {
    arr[i] < pivot ? left.push(arr[i]) : right.push(arr[i]);
  }

  return quickSort(left).concat([pivot], quickSort(right));
}

// test
const arr = [91, 60, 96, 7, 35, 65, 10, 65, 9, 30, 20, 31, 77, 81, 24];
console.log(quickSort(arr));
```

代码解析:

- 这里有两个函数: quickSort和quickSortRec.
  - 外部调用时, 会调用quickSort
  - 内部递归时, 会调用quickSortRec
- 我们这里主要讲解一下quickSortRec方法.
  - 代码序号0: 是递归的结束条件. 可以回头再来看这个函数.
  - 代码序号1: 从三个数中获取枢纽值, 这个方法我们在上一节中已经讲过, 这里不再累述.
  - 代码序号2: 我们的重点代码
    - 代码序号2.1: 循环交换合适位置的数值.
    - 代码序号2.2: 使用两个while循环, 递归的查找合适的i(大于枢纽的值)和合适的j(小于枢纽的值).
    - 代码序号2.3: 交换i和j位置的值.
    - 代码序号2.4: 当i<j的时候, 两边查找到了同一个位置, 这个时候停止循环.
  - 代码序号3: 刚才我们查找到的i位置正是pivot应该所在的位置, 和pivot替换即可.
    - 这里你可能会有一个疑问, 为什么将i位置可以换到最后呢? 万一它比pivot小呢?
    - 这是因为我们在while (this.array[++i] < pivot)先使用的是i, 而不是j. 但是这意味着什么呢?
    - 意味着i找到的一个值, 现在停下来的, 必然是大于pivot. 而j会超过i的位置向后找了一个小于pivot.
    - 但是, 这个时候已经不需要继续进行交换了, 直接退出即可.
    - 而退出后, i位置的数值是大于pivot, 所以可以将其换到后面.
  - 代码序号4: 递归调用该函数, 将left, i - 1传入就是左边排序, 将i + 1, right就是右边排序.

```js
// 快速排序函数，接收数组、子数组的起始索引和结束索引
var quickSort = function (arrays, start, end) {
    // 如果子数组的起始索引小于结束索引，表示还有至少两个元素需要排序
    if (start < end) {
        // 使用分区函数找到分割点 pivot
        let pivot = partition(arrays, start, end);
        // 递归对左侧子数组进行快速排序
        quickSort(arrays, start, pivot - 1);
        // 递归对右侧子数组进行快速排序
        quickSort(arrays, pivot + 1, end);
    }
    // 返回排序后的数组
    return arrays;
}

// 分区函数，将小于目标值的元素移到数组前面，返回目标值的新位置
var partition = function (nums, start, end) {
    // 选择目标元素作为基准值
    let target = nums[end];
    // 初始化 i，用于记录小于目标值的元素的位置
    let i = start;
    // 遍历子数组
    for (let j = start; j < end; j++) {
        // 如果当前元素小于目标值
        if (nums[j] < target) {
            // 交换当前元素和 i 指针所指的元素
            [nums[i], nums[j]] = [nums[j], nums[i]];
            // i 指针前进一位
            i++;
        }
    }
    // 将目标值放到中间位置，确保左侧元素小于目标值，右侧元素大于目标值
    [nums[i], nums[end]] = [nums[end], nums[i]];
    // 返回基准值的新位置
    return i;
}
```

下面这种分治的算法较好理解，挖坑填数。

```js
var partition = function (nums, left, right) {
    let pivot = nums[left];
    // 当 left 和 right 指针相遇时，表示一轮分区操作完成，此时基准值左边的元素都小于等于基准值，右边的元素都大于等于基准值。
    while (left < right) {
        while (left < right && nums[right] > pivot) { //从右向左 找到右边第一个小于基准值的元素
            right--;
        }
        if (left < right) {
            nums[left] = nums[right]; //将右边小于基准值的元素移到左边
            left++; //左指针前进一位
        }
        while (left < right && nums[left] < pivot) { // 找到左边第一个大于基准值的元素
            left++;
        }
        if (left < right) {
            nums[right] = nums[left]; // 将左边大于基准值的元素移到右边
            right--;
        }
    }
    nums[left] = pivot; //left === right
    return left;
}
```

```js
var sortArray = function(nums) {
    var quickSort = (nums, start, end) => {
        if (start < end) {
            let pivotIndex = partition(nums, start, end);
            quickSort(nums, start, pivotIndex - 1);
            quickSort(nums, pivotIndex + 1, end);
        }
    };

    var partition = (nums, left, right) => {
        let pivot = nums[left];
        while (left < right) {
        while (left < right && nums[right] > pivot) {
            right--;
        }
        if (left < right) {
            nums[left] = nums[right]; 
            left++; 
        }
        while (left < right && nums[left] < pivot) {
            left++;
        }
        if (left < right) {
            nums[right] = nums[left];
            right--;
        }
    }
        nums[left] = pivot;
        return left;
    };
    quickSort(nums, 0, nums.length - 1);
    return nums;
};
```

#### 快速排序的效率

- 快速排序的最坏情况效率
  - 什么情况下会有最坏的效率呢? 就是每次选择的枢纽都是最左边或者最后边的.
  - 那么效率等同于冒泡排序.
  - 而我们的例子可能有最坏的情况吗? 是不可能的. 因为我们是选择三个值的中位值.
- 快速排序的平均效率:
  - 快速排序的平均效率是O(N * logN).
  - 虽然其他某些算法的效率也可以达到O(N * logN), 但是快速排序是最好的.

## 07 归并排序

```js
var mergeSort = function (nums, start, end) {
    if (start < end) {
        let mid = (start + end) >> 1;
        mergeSort(nums, start, mid);
        mergeSort(nums, mid + 1, end);
        nums = merge(nums, start, mid, end);
    }
    return nums;
}

var merge = function (nums, left, mid, right) {
    let arr = [];
    let i = left, j = mid + 1;
    while (i <= mid && j <= right) {
        if (nums[i] < nums[j]) {
            arr.push(nums[i]);
            i++;
        } else {
            arr.push(nums[j]);
            j++;
        }
    }
    while (i <= mid) {
        arr.push(nums[i++]);
    }
    while (j <= right) {
        arr.push(nums[j++]);
    }
    return arr;
}

let nums = [2, 3, 5, 9, 4, 6, 8];
console.log(mergeSort(nums,0,nums.length-1))
```

## 08 堆排序

用数组表示的完美二叉树 complete binary tree

```js
var move = function (nums, low, high) {
    let i = low, j = 2 * i + 1;
    let temp = nums[i];
    while (j <= high) {
        if (j < high && nums[j] < nums[j + 1]) {
            j++;
        }
        if (temp < nums[j]) {
            nums[i] = nums[j];
            i = j;
            j = 2 * i + 1;
        } else {
            break;
        }
    }
    nums[i] = temp;
}

var heapSort = function (nums) {
    let i, temp;
    let n = nums.length - 1;
    for (i = n >> 1; i >= 0; i--) {
        move(nums, i, n);
    }
    for (i = n; i >= 1; i--) {
        temp = nums[0];
        nums[0] = nums[i];
        nums[i] = temp;
        move(nums, 0, i - 1);
    }
    return nums;
}

let arr = [2,4,1,5,8,6,7,9]
console.log(heapSort(arr))
```

# d13 二分查找

> 二分搜索核心四点要素：
>
> - 初始化：start=0、end=len-1
> - 循环退出条件：left <= right、start + 1 < end
> - 比较中点和目标值：A[mid] ==、 <、> target
> - 判断最后两个元素是否符合：A[start]、A[end] ? target
>
> > 时间复杂度 O(logn)，使用场景一般是有序数组的查找。

## 704 二分查找

给定一个  n 个元素有序的（升序）整型数组  nums 和一个目标值  target  ，写一个函数搜索  nums 中的 target，如果目标值存在返回下标，否则返回 -1。

> 核心算法：从数组的中间元素开始，不断缩小搜索范围，通过比较中间元素和目标元素的大小来确定搜索范围的左半部分或右半部分，直至找到目标元素或确定不存在，返回目标元素的索引或 -1。（不需要找第一个、最后一个位置、或者是没有重复元素）

```js
var search = function (nums, target) {   
    // 定义一个名为search的函数，查找数组nums中的目标元素target
    let start = 0, mid = 0, end = nums.length - 1;   
    // 初始化三个变量，用于表示查找区间的左边界、中间位置、右边界
    while (start <= end) { 
        // 进入一个循环，只要查找区间仍然存在（左边界小于右边界）
        mid = start + ((end - start) >> 1);  
        // 计算当前查找区间的中间位置的索引号 避免整数溢出 
        // >> 1 表示将操作数向右移动一个位，这等同于将其除以 2
        if (nums[mid] === target) { 
            // 如果中间元素等于目标元素
            return mid; 
            // 返回中间元素的索引号
        }
        if (nums[mid] > target) { 
            // 如果中间元素大于目标元素 目标元素位于当前中间元素的左侧
            end = mid - 1; 
            // 将右边界 end 调整到中间元素的左侧，从而缩小查找区间为左半部分。
            // -1是因为已经排除了中间元素本身
        } else {
            start = mid + 1; 
            // 如果中间元素小于目标元素
            // 将左边界 start 调整到中间元素的右侧，从而缩小查找区间为右半部分
        }
    }
    return -1; 
    // 如果未找到目标元素，返回 -1
    };
```

> 如果找到目标元素，它会返回该元素的索引。但是，这个版本的二分查找并不适用于找到目标值第一次出现的位置，因为一旦找到目标值，它就会立即返回，而不考虑该值可能在数组中多次出现的情况。

```js
// 可以直接使用JavaScript 内置函数 indexOf 来查找目标元素在数组 nums 中的索引。indexOf 函数返回目标元素的索引，如果找不到则返回 - 1。
var search = function (nums, target) {
    return nums.indexOf(target);
};
```

## 34 在排序数组中查找元素的第一个和最后一个位置

给定一个包含 n 个整数的排序数组，找出给定目标值 target 的起始和结束位置。 如果目标值不在数组中，则返回[-1, -1]。

> 思路：首先使用二分查找找到目标值在数组中的一个索引，然后通过左右滑动指针来找到目标值的起始和结束位置。

```js
var searchRange = function(nums, target) {
    // 定义一个二分查找函数
    const binarySearch = function(nums, target) {
        let left = 0;
        let right = nums.length - 1;
        while (left <= right) {
            const mid = left + Math.floor((right - left) / 2);
            if (nums[mid] === target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    };
	// 使用二分查找找到目标值的索引
    // 在找到目标值的索引后，通过向左和向右滑动指针找到目标值在数组中的起始位置和结束位置
    const index = binarySearch(nums, target);
    if (index === -1) {
        return [-1, -1];
    }
    let left = index;
    let right = index;
    // 向左滑动，找左边界
    while (left - 1 >= 0 && nums[left - 1] === nums[index]) {
        left--;
    }
    // 向右滑动，找右边界
    while (right + 1 < nums.length && nums[right + 1] === nums[index]) {
        right++;
    }
    return [left, right];
};
```

> 思路：找第一个 target 的索引，和最后一个 target 的索引，所以用两次二分搜索分别找第一次和最后一次的位置

```js
var searchRange = function (nums, target) {
    // 首先，通过比较目标值 target 和数组 nums 的第一个和最后一个元素，检查目标值是否在数组中。如果不在，直接返回 [-1, -1] 表示未找到。
    if (target < nums[0] || target > nums[nums.length - 1]) {
        return [-1, -1];
    }
    // 初始化结果数组，假定目标值不在数组中
    let res = [-1, -1];
    // 初始化左右边界和中间位置
    let left = 0, mid = 0, right = nums.length - 1;
    // 二分查找找到目标值第一次出现的位置
    while (left +1 < right) {
        // 计算当前查找区间的中间位置
        mid = left + ((right - left) >> 1); 
        
        if (nums[mid] === target) {  
            // 如果中间元素等于目标元素，我们不确定这是否是第一次出现  
            // 因此，我们需要继续向左搜索，直到找到第一个等于目标值的元素  
            while (mid > 0 && nums[mid - 1] === target) { 
                // 确保当前索引 mid 不是数组的第一个元素（即不是边界）
                // 而且如果当前 mid 索引左侧的元素（即 nums[mid - 1]）也等于目标值 target，这意味着我们还没有找到目标值的第一次出现，因为可能还有更多的相同目标值在 mid 的左侧
                mid--; 
                // 继续向左搜索，直到找到第一个目标元素或到达数组开始  
            }
            // 记录目标值第一次出现的位置 
            // 此时mid === 0 || (nums[mid] === target && nums[mid - 1] < target)
            res[0] = mid;  
            break; // 找到后退出循环  
        } else if (nums[mid] > target) {  
            // 如果中间元素大于目标元素，目标元素位于当前中间元素的左侧  
            right = mid - 1; // 将右边界调整到中间元素的左侧  
        } else {  
            // 如果中间元素小于目标元素，目标元素位于当前中间元素的右侧  
            left = mid + 1; // 将左边界调整到中间元素的右侧  
        }  
    }
    
    // 如果找到了第一次出现的位置，继续查找最后一次出现的位置
    // 如果数组的第一个元素不等于-1，且在数组中的第一个元素等于 'target' 时执行以下操作，确保目标值 target 在数组中至少出现一次，而且 res[0] 存储的是第一次出现的位置。
    if (res[0] !== -1 && nums[res[0]] === target) {
        // 如果 'res' 数组的第一个元素等于 'nums' 数组的最后一个索引时，那意味着目标值 target 在数组中只出现一次，将 'res' 数组的第二个元素设置为与第一个元素相同，将 res[1] 设置为与 res[0] 相同。
        if (res[0] === nums.length - 1) {
            res[1] = res[0];
        } else {
            // 否则，如果 res[0] 不是数组 nums 的最后一个索引，那么它可能在数组中多次出现。此时，进入一个循环，从 res[0] 的下一个位置开始遍历数组 nums。
            for (let i = res[0] + 1; i < nums.length; i++) {
                // 如果当前索引 i 处的元素不等于目标值 target（即 nums[i] !== target），说明这是目标值的最后一次出现，因此将 res[1] 设置为前一个索引 i - 1 并退出循环。
                if (nums[i] !== target) {
                    res[1] = i - 1;
                    break;
                }
                // 如果循环达到数组的最后一个索引（即 i === nums.length - 1）且最后一个元素仍然等于目标值 target（即 nums[i] === target），那么目标值 target 在数组中出现了多次，并且最后一次出现的位置就是当前索引 i，因此将 res[1] 设置为 i。
                if (i === nums.length - 1 && nums[i] === target) {
                    res[1] = i;
                }
            }
        }
    }
    // 返回结果数组，其中包含目标值在数组中的起始和结束索引
    return res;
};
```

> 处理target在数组里的左右边界的三种情况：target 在数组范围的右边或者左边、target 在数组范围中且数组中不存在target、target 在数组范围中且数组中存在target。

```js
var searchRange = function(nums, target) {
    const getLeftBorder = (nums, target) => {
        let left = 0, right = nums.length - 1;
        let leftBorder = -2;// 记录一下leftBorder没有被赋值的情况
        while(left <= right){
            let middle = left + ((right - left) >> 1);
            if(nums[middle] >= target){ // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }

    const getRightBorder = (nums, target) => {
        let left = 0, right = nums.length - 1;
        let rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left <= right) {
            let middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }

    let leftBorder = getLeftBorder(nums, target);
    let rightBorder = getRightBorder(nums, target);
    // 情况一
    if(leftBorder === -2 || rightBorder === -2) return [-1,-1];
    // 情况三
    if (rightBorder - leftBorder > 1) return [leftBorder + 1, rightBorder - 1];
    // 情况二
    return [-1, -1];
};
```

```js
// IndexOf 从前面查找，只返回第一个满足条件的索引号，如果不存在，则返回-1。lastIndexOf 从后面开始查找，返回索引号，如果不存在，则返回-1。
var searchRange = function(nums, target) {
    return [nums.indexOf(target),nums.lastIndexOf(target)]; //使用内置方法，运行更快
};
/*
var nums = [1, 2, 3, 4, 5, 6, 3, 7, 8];
var target = 3;
var searchRange = function (nums, target) {
	return [nums.indexOf(target), nums.lastIndexOf(target)]; 
}; // 根据题目设置，将返回[2, 6]，因为目标值 3 在数组 nums 中第一次出现的索引是 2，最后一次出现的索引是 6。
*/
```

## 35 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

> 目标值在数组所有元素之前、目标值等于数组中某一个元素、目标值插入数组中的位置、目标值在数组所有元素之后

```js
// 线性查找 O(n)
var searchInsert = function(nums, target) {
    for(let i=nums.length-1; i>=0; i--) {
        if (target === nums[i]) {
            return i;
        } else if (target > nums[i]) {
            return i + 1;
        }
    }
    return 0;
};
```

```js
// O(log n) 左闭右闭
var searchInsert = function(nums, target) {
    let left=0; right=nums.length-1; len = nums.length;  
    // 定义target在左闭右闭的区间里，[left, right] 
    // 如果目标值大于所有数组元素，则应该插入在数组末尾
    while(left <= right){ 
        // 当left==right，区间[left, right]依然有效
        let mid=left +((right-left)>>1);
        // 如果目标值大于中间元素的值，则继续搜索右半部分
        if (nums[mid] > target) {
                right = mid - 1; // target 在左区间，所以[left, middle - 1]
        } else if (nums[mid] < target) {
            left = mid + 1; // target 在右区间，所以[middle + 1, right]
        } else { // nums[middle] == target
            return mid;
        }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前  [0, -1]
        // 目标值等于数组中某一个元素  return middle;
        // 目标值插入数组中的位置 [left, right]，return  right + 1
        // 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1
        return right + 1;
}; 
```

```js
// O(log n) 左闭右开
function searchInsert(nums, target) {
    let left = 0;
    let right = nums.length;

    while (left < right) {
        let mid=left +((right-left)>>1);

        if (nums[mid] > target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            // nums[mid] === target
            return mid;
        }
    }
    // 目标值在数组所有元素之前 [0, 0)
    // 目标值插入数组中的位置 [left, right)，返回 right 表示正确的插入位置
    // 如果目标值在所有元素之后，left 将等于 right
    return right;
}
```

## 74 搜索二维矩阵

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。

```js
var searchMatrix = function(matrix, target) {
    // 获取矩阵的行数  
    const rowCount = matrix.length;  
    // 如果矩阵为空，则直接返回false  
    if (rowCount === 0) return false;  
    // 获取矩阵的列数  
    const colCount = matrix[0].length;  
    
    // 遍历矩阵的每一行  
    for (let i = 0; i < rowCount; i++) {  
        // 在当前行内，初始化左边界left为0  
        let left = 0;  
        // 在当前行内，初始化右边界right为当前行的最后一个元素的索引  
        let right = colCount - 1;  

        // 当左边界不大于右边界时，执行二分查找  
        while (left <= right) {  
            // 计算中间元素的索引  
            const mid = Math.floor((left + right) / 2);  
            // 获取中间元素的值  
            const midValue = matrix[i][mid];  
            // 如果中间元素的值大于目标值，则目标值可能在左半部分，更新右边界  
            if (midValue > target) {  
                right = mid - 1;  
            // 如果中间元素的值小于目标值，则目标值可能在右半部分，更新左边界  
            } else if (midValue < target) {  
                left = mid + 1;  
            // 如果中间元素的值等于目标值，则找到了目标，返回true  
            } else {  
                return true;  
            }  
        }  
    }  
    // 如果遍历完所有行都没有找到目标值，则返回false  
    return false;  
};
```

## 278 第一个错误的版本

假设你有 n 个版本[1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

```js
function firstBadVersion(n) {
    let left = 1;
    let right = n;

    while (left <= right) {
        let mid = left + ((right - left) >> 1);
        
        if (isBadVersion(mid)) {
            // 如果当前版本是错误的，那么第一个错误的版本可能在左侧
            right = mid - 1;
        } else {
            // 如果当前版本是正确的，那么第一个错误的版本一定在右侧
            left = mid + 1;
        }
    }
    // 当 left 和 right 相邻时，left 就是第一个错误的版本
    return left;
}
```

```js
var solution = function(isBadVersion) {
    return function(n) {
    let left = 1;
    let right = n;

    while (left < right) {
        let mid = left + ((right - left) >> 1);
        if (isBadVersion(mid)) {
            // 如果当前版本是错误的，那么第一个错误的版本可能在左侧
            right = mid ;
        } else {
            // 如果当前版本是正确的，那么第一个错误的版本一定在右侧
            left = mid + 1;
        }
    }
    // 当 left 和 right 相邻时，left 就是第一个错误的版本
    return left;
    };
};
```

## 153 寻找旋转排序数组中的最小值

假设按照升序排序的数组在预先未知的某个点上进行了旋转(例如，数组[0, 1, 2, 4, 5, 6, 7] 可能变为[4, 5, 6, 7, 0, 1, 2])。 请找出其中最小的元素。

> 在一个旋转排序数组中，最小元素通常位于旋转点的附近，旋转点是数组中的一个元素，它比旋转点前面和后面的元素都要小。通过比较中间元素和结束元素的大小，确定最小元素所在的一侧，从而高效地找到最小元素。

```js
var findMin = function(nums) {
    let start = 0;
    let end = nums.length - 1;

    while (start + 1 < end) {
        let mid = start + Math.floor((end - start) / 2);
        // 如果中间元素小于等于结束元素，说明最小元素在左侧或就是 mid
        if (nums[mid] <= nums[end]) {
            end = mid;
        } else {
            // 否则，最小元素在 mid 的右侧，更新左指针为 mid
            start = mid;
        }
    }
    // 比较 start 和 end 指针指向的值，返回最小元素
    if (nums[start] > nums[end]) {
        return nums[end];
    }
    return nums[start];
};
```

## 154 寻找旋转排序数组中的最小值 II

给你一个可能存在重复元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

```js
var findMin = function (nums) {
   let start = 0
   let end = nums.length - 1
   let mid = 0
   
   while (start + 1 < end) {
       let mid = start + ((end - start) >> 1)
       
       // 处理数组开头和结尾的重复元素
       while (start < end && nums[start] === nums[start + 1]) {
           start++
       }
       while (start < end && nums[end] === nums[end - 1]) {
           end--
       }
 
       if (nums[mid] >= nums[end]) {
           start = mid
       } else {
           end = mid
       }
   }
   if(nums[start] > nums[end]){
       return nums[end]
   }
   return nums[start]
};
```

## 33 搜索旋转排序数组

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 - 1 。

```js
var search = function (nums, target) {
    let start = 0
    let end = nums.length - 1
    
    while (start + 1 < end) {
        let mid = start + ((end - start) >> 1)
        
        if (nums[mid] === target) {
            return mid
        }
        // 检查左半部分是否有序 
        if (nums[start] < nums[mid]) {
            // 判断目标值是否在左半部分，调整搜索范围
            if (nums[start] <= target && target <= nums[mid]) {
                end = mid
            } else {
                start = mid
            }
        }
        // 检查右半部分是否有序
        if (nums[end] > nums[mid]) {
            // 判断目标值是否在右半部分，调整搜索范围
            if (nums[end] >= target && nums[mid] <= target) {
                start = mid
            } else {
                end = mid
            }
        }
    }
    // 如果在循环中未找到目标值，则检查目标值是否等于start或end处的元素
    if (nums[start] === target) {
        return start
    } else if (nums[end] === target) {
        return end
    }
    // 如果数组中未找到目标值，则返回-1
    return -1
};
```

## 81 搜索旋转排序数组 II

同上，数字可重复。

```js
var search = function (nums, target) {
    let start = 0
    let end = nums.length - 1

    while (start + 1 < end) {
        let mid = start + ((end - start) >> 1)
        
        if (nums[mid] === target) {
            return true
        }
        // 处理数组开头连续重复元素
        while (start < end && nums[start] === nums[start + 1]) {
            start++
        }
        // 处理数组结尾连续重复元素
        while (start < end && nums[end] === nums[end - 1]) {
            end--
        }
        // 旋转有序数组的二分查找
        if (nums[start] < nums[mid]) {
            if (nums[start] <= target && target <= nums[mid]) {
                end = mid
            } else {
                start = mid
            }
        }
        if (nums[end] > nums[mid]) {
            if (nums[end] >= target && nums[mid] <= target) {
                start = mid
            } else {
                end = mid
            }
        }
    }
    // 检查目标值是否等于 start 或 end 处的元素
    if (nums[start] === target || nums[end] === target) {
        return true
    }
    // 如果目标值未找到，返回 false
    return false
};
```

## 69 x的平方根

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

```js
var mySqrt = function(x) {
    // 如果 x 为 0 或 1，则其算术平方根即为 x，直接返回
    if (x === 0 || x === 1) {
        return x;
    }

    let left = 1;
    let right = Math.floor(x / 2); // 算术平方根最大不会超过它的一半
    let result = 0;

    while (left +1 < right) {
        const mid = Math.floor((left + right) / 2);
        const square = mid * mid;

        // 判断中点平方与目标值的关系
        if (square === x) {
            return mid;
        } else if (square < x) {
            // 如果中点平方小于目标值，调整左边界并更新结果
            left = mid + 1;
            result = mid;  // 更新结果，因为我们需要向上取整
        } else {
            // 如果中点平方大于目标值，调整右边界
            right = mid - 1;
        }
    }
    // 返回最终结果
    return result;
};
```

## 367 [有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。不能使用任何内置的库函数，如 `sqrt` 。

```js
function isPerfectSquare(num) {
    // 如果 num 小于 2，那么它是完全平方数，返回 true
    if (num < 2) {
        return true;
    }

    // 初始化左边界为 2，右边界为 num 除以 2 的整数部分
    let left = 2; // 完全平方数的平方根不会小于 2
    let right = Math.floor(num / 2); // 完全平方数的平方根不会大于 num / 2

    // 当左边界小于等于右边界时，执行循环
    while (left <= right) {
        // 计算中间值 mid
        let mid = left + Math.floor((right - left) / 2);
        // 计算 mid 的平方
        let guess = mid * mid;
        
        // 如果 mid 的平方等于 num，说明找到了完全平方数，返回 true
        if (guess === num) {
            return true;
        } else if (guess < num) {
            // 如果 mid 的平方小于 num，说明目标在右侧，更新左边界为 mid + 1
            left = mid + 1;
        } else {
            // 如果 mid 的平方大于 num，说明目标在左侧，更新右边界为 mid - 1
            right = mid - 1;
        }
    }
    // 循环结束后，说明没有找到完全平方数，返回 false
    return false;
}
```

# d14 双指针法

## 27 移除元素

```js
var removeElement = function(nums, val) {
  let k = 0

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== val) {
      numsk] = nums[i]
      k += 1
    }
  }
  return k
};
```

## 344 [反转字符串](https://leetcode.cn/problems/reverse-string/)

```js
var reverseString = function(s) {
    let left = 0;
    let right = s.length - 1;

    while (left <= right) {
        [s[left], s[right]] = [s[right], s[left]];
        left++;
        right--;
    }
    return s;
};
```

## # 替换数字

```js
function replaceDigits(s) {
    let result = '';
    for (let i = 0; i < s.length; i++) {
        if (isNaN(s[i])) {
            // 如果当前字符不是数字，则直接追加到结果字符串
            result += s[i];
        } else {
            // 如果当前字符是数字，则追加 "number" 到结果字符串
            result += 'number';
        }
    }
    return result;
}
```

## 151 [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

> 移除多余空格、将整个字符串反转、将每个单词反转

```js
var reverseWords = function(s) {
    // 先去除首尾空格trim()，然后按照正则表达式 \s+（匹配一个或多个空格），把字符串分割成单词数组，再反转数组reverse()，然后合并成字符串join(' ')
    const wordsArray = s.trim().split(/\s+/);
    const reversedString = wordsArray.reverse().join(' ');
    return reversedString;
};
```

```js
var reverseWords = function(s) {  
    // 将字符串转换为字符数组  
    let strArr = s.split('');   
    // 移除多余空格  
    removeExtraSpaces(strArr);   
    // 分割字符数组为单词数组  
    let words = strArr.join('').split(' ');    
    // 反转单词数组  
    words.reverse();  
    // 连接单词数组为字符串，单词之间用空格分隔  
    return words.join(' ');  
};

// 删除多余空格
function removeExtraSpaces(strArr) {
  let slowIndex = 0;
  let fastIndex = 0;

  while(fastIndex < strArr.length) {
    // 移除开始位置和重复的空格
    if (strArr[fastIndex] === ' ' && (fastIndex === 0 || strArr[fastIndex - 1] === ' ')) {
      fastIndex++;
    } else {
      strArr[slowIndex++] = strArr[fastIndex++];
    }
  }
  // 移除末尾空格
  strArr.length = strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex;
}

// 翻转从 start 到 end 的字符
function reverse(strArr, start, end) {
  let left = start;
  let right = end;

  while(left < right) {
    // 交换
    [strArr[left], strArr[right]] = [strArr[right], strArr[left]];
    left++;
    right--;
  }
}
```

## 206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```js
var reverseList = function(head) {
    if(!head || !head.next) return head;
    let temp = null, pre = null, cur = head;
    while(cur) {
        temp = cur.next; //因为后面要改变节点cur->next的指向 先用temp指针保存一下
        cur.next = pre; 
        pre = cur;  // pre向后移
        cur = temp; // cur向后移 cur = cur.next;
    }
    // temp = cur = null;
    return pre;
};
```

## 19 [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

> 快指针先走n+1，然后快慢指针同时走，快指针走到结尾，删除慢指针指向的下一个节点

```js
var removeNthFromEnd = function(head, n) {
    //虚拟节点
    let ret = new ListNode(0, head),
        slow = fast = ret; 
	//快指针
    while(n--) fast = fast.next;
    //快慢指针
    while (fast.next !== null) {
        fast = fast.next; 
        slow = slow.next
    };
    //删除
    slow.next = slow.next.next;
    return ret.next;
};
```

## 0207 [链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```js
var getIntersectionNode = function (headA, headB) {
  if (headA === null || headB === null) return null;
  let pA = headA;
  let pB = headB;

  while (pA !== pB) {
    // 如果 pA 不为 null，则将 pA 移动到下一个节点；否则，将 pA 重定向到链表 B 的头
    pA = pA ? pA.next : headB;
    // 如果 pB 不为 null，则将 pB 移动到下一个节点；否则，将 pB 重定向到链表 A 的头
    pB = pB ? pB.next : headA;
  }
  return pA
  // 如果两个链表有交点，那么在某一时刻 `pA` 和 `pB` 将相遇于交点 `C`。这是因为它们从各自的头节点出发，在第一次相遇点之前走过的距离是相等的，而在第一次相遇点后，它们共同走过的距离也是相等的。
};
```

## 15 [三数之和](https://leetcode.cn/problems/3sum/)

```js
var threeSum = function (nums) {
    if (nums.length <= 2) {
        return []
    }
    let res = []
    // 将输入数组按升序排序
    nums.sort((a, b) => a - b)
    // 将输入数组按升序排序
    for (let i = 0; i < nums.length; i++) {
        // 如果当前元素大于0，则无需继续，直接返回结果
        if (nums[i] > 0) break
        // 如果当前元素大于0，则无需继续，直接返回结果
        if (i > 0 && nums[i] == nums[i - 1]) continue
        
        let j = i + 1
        let k = nums.length - 1
        while (j < k) {
            let sum = nums[i] + nums[j] + nums[k]
            if (sum == 0) {
                res.push([nums[i], nums[j], nums[k]])
                // 跳过重复元素
                while (j < k && nums[j] == nums[j + 1]) j++
                while (j < k && nums[k] == nums[k - 1]) k--
                // 移动指针到下一个唯一元素
                j++
                k--
            } else if (sum < 0) {
                j++
            } else {
                k--
            }
        }
    }
    return res
};
```

## 18 [四数之和](https://leetcode.cn/problems/4sum/)

```javascript
var fourSum = function (nums, target) {
    if (nums.length < 4) return []
    //升序排序
    nums.sort((a, b) => a - b)
    //初始化结果数组
    const res = [] 
    
    for (let i = 0; i < nums.length - 3; i++) {
        //去重i
        if (i > 0 && nums[i] === nums[i - 1]) continue
        for (let j = i + 1; j < nums.length - 2; j++) {
            //去重j
            if (j > i + 1 && nums[j] === nums[j - 1]) continue
            let l = j + 1, r = nums.length - 1
            while (l < r) {
                const sum = nums[i] + nums[j] + nums[l] + nums[r]
                if (sum < target) { l++; continue }
                if (sum > target) { r--; continue }
                res.push([nums[i], nums[j], nums[l], nums[r]])
                // 对nums[left]和nums[right]去重
                while (l < r && nums[l] === nums[l + 1]) {
                    l++
                };
                while (l < r && nums[r] === nums[r - 1]) {
                    r--
                };
                l++
                r--
            }
        }
    }
    return res
};
```

# d15 滑动窗口

和双指针题目类似，更像双指针的升级版，滑动窗口核心点是维护一个窗口集，根据窗口集来进行处理

核心步骤

- right 右移
- 收缩
- left 右移
- 求结果

## 0 滑动窗口算法框架

```js
function slidingWindow(s, t) {  
    // 初始化两个 Map 对象，用于记录 t 中字符的需求数量和当前窗口内字符的数量  
    const need = new Map();  
    const window = new Map();  
    for (const c of t) {  
        if (!need.has(c)) {  
            need.set(c, 0);  
        }  
        need.set(c, need.get(c) + 1);  
    }  
  
    let left = 0, right = 0;  
    let valid = 0;  
    while (right < s.length) {  
        // c 是将移入窗口的字符  
        const c = s[right];  
        // 右移窗口  
        right++;  
  
        // 更新窗口内字符的数量  
        if (need.has(c)) {  
            if (!window.has(c)) {  
                window.set(c, 0);  
            }  
            window.set(c, window.get(c) + 1);  
            if (window.get(c) === need.get(c)) {  
                valid++;  
            }  
        }  
  
        // 输出当前窗口信息，用于调试  
        console.log(`window: [${left}, ${right})`);  
  
        // 判断左侧窗口是否需要收缩  
        while (valid === need.size && left < right) {  
            // 找到了一个匹配，可以在这里处理结果  
            // 例如，如果问题是求最小覆盖子串，可以在这里更新结果  
  
            // d 是将移出窗口的字符  
            const d = s[left];  
            // 左移窗口  
            left++;  
  
            // 更新窗口内字符的数量  
            if (need.has(d)) {  
                if (window.get(d) === need.get(d)) {  
                    valid--;  
                }  
                window.set(d, window.get(d) - 1);  
            }  
        }  
    }  
  
    // 如果没有找到匹配，可以在这里返回 false 或者其他表示未找到的结果  
    // 如果找到了匹配，可以在上面的 while 循环中处理结果  
}  
```

需要变化的地方

- 1、右指针右移之后窗口数据更新
- 2、判断窗口是否要收缩
- 3、左指针右移之后窗口数据更新
- 4、根据题意计算结果

## 76 [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

```js
var minWindow = function(s, t) {  
    // 创建一个 Map 来保存目标字符串 t 中每个字符的出现次数  
    let target = new Map(),   
    // 创建一个 Map 来保存当前窗口（滑动窗口）中每个字符的出现次数  
    window = new Map();  
      
    // 遍历目标字符串 t，统计每个字符出现的次数  
    for(let i = 0; i < t.length; i++) {  
        let c = t[i];  
        target.set(c, (target.get(c) || 0) + 1);  
    }  
      
    // 初始化滑动窗口的左右指针、有效字符计数、最小窗口长度和结果字符串  
    let left = 0, right = 0, valid = 0, len = Number.MAX_VALUE, res = '';  
      
    // 当右指针没有超出字符串 s 的范围时，持续进行循环  
    while(right < s.length) {  
        // 获取当前右指针指向的字符  
        let c = s[right];  
        // 右指针向右移动  
        right++;  
          
        // 如果当前字符 c 是目标字符串 t 中的字符  
        if(target.has(c)) {  
            // 在当前窗口中增加字符 c 的计数  
            window.set(c, (window.get(c) || 0) + 1);  
            // 如果字符 c 在当前窗口中的计数与目标字符串 t 中的计数相等，说明找到一个有效字符  
            if(window.get(c) == target.get(c)) valid++;  
        }  
          
        // 当窗口中的有效字符数量等于目标字符串 t 的长度时，开始尝试缩小窗口  
        while(valid == target.size) {  
            // 如果当前窗口的长度小于之前记录的最小窗口长度，则更新最小窗口长度和结果字符串  
            if(right - left <= len) {  
                res = s.substring(left, right);  
                len = right - left;  
            }  
              
            // 获取当前左指针指向的字符  
            let d = s[left];  
            // 左指针向右移动  
            left++;  
              
            // 如果字符 d 是目标字符串 t 中的字符  
            if(target.has(d)) {  
                // 如果字符 d 在当前窗口中的计数与目标字符串 t 中的计数相等，说明移出一个有效字符  
                if(window.get(d) === target.get(d)) valid--;  
                // 在当前窗口中减少字符 d 的计数  
                window.set(d, window.get(d) - 1);  
            }  
        }  
    }  
      
    // 返回最小覆盖子串，如果找不到则返回空字符串  
    return res;  
};
```

## 567 [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的排列。如果是，返回 `true` ；否则，返回 `false` 。换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

> 具体来说，它首先统计了`s1`中每个字符出现的次数，并存入`map1`中。然后，它使用滑动窗口的方法来遍历`s2`，并在遍历过程中更新`map2`来记录当前窗口内`s2`字符的出现次数。同时，它还维护了一个`valid`计数器，用来记录当前窗口中满足`s1`字符出现次数的字符数量。
>
> 在滑动窗口的每一次移动中，如果右指针指向的字符在`map1`中存在，则更新`map2`并检查是否满足`s1`中该字符的出现次数。如果满足，则`valid`计数器加1。当窗口大小达到`s1.length`时，检查`valid`是否等于`map1.size`，如果是，则说明`s1`是`s2`的子序列，返回`true`。
>
> 如果窗口大小达到`s1.length`但`valid`不等于`map1.size`，则开始收缩窗口（左指针右移），并更新`map2`和`valid`。这个过程会一直持续到找到`s1`是`s2`的子序列或者遍历完整个`s2`为止。

```js
var checkInclusion = function (s1, s2) {  
    // 创建两个 Map 对象，用于存储 s1 和滑动窗口内的 s2 字符及其出现的次数  
    let map1 = new Map(), map2 = new Map();  
      
    // 遍历 s1 中的每个字符，并统计其在 map1 中的出现次数  
    for (let i = 0; i < s1.length; i++) {  
        if (!map1.has(s1[i])) {  
            // 如果 map1 中不存在该字符，则添加它并设置次数为 1  
            map1.set(s1[i], 1)  
        } else {  
            // 如果 map1 中已存在该字符，则增加其出现次数  
            map1.set(s1[i], map1.get(s1[i]) + 1)  
        }  
    }  
      
    // 初始化左右指针和有效字符计数  
    let l = r = valid = 0;  
      
    // 使用滑动窗口遍历 s2  
    while (r < s2.length) {  
        // 获取当前右指针指向的字符  
        let c = s2[r];  
        // 右指针右移  
        r++;    
        // 如果字符 c 在 map1 中存在（即 s1 中有该字符）
        if (map1.has(c)) {  
            // 在 map2 中更新字符 c 的出现次数  
            map2.set(c, (map2.get(c) || 0) + 1);  
              
            // 如果字符 c 在 map1 和 map2 中的出现次数相同  
            if (map1.get(c) === map2.get(c)) {  
                // 有效字符计数加 1  
                valid++;  
            }  
        }  
          
        // 判断是否需要收缩左侧窗口  
        while (r - l >= s1.length) {  
            // 如果有效字符计数等于 s1 中不同字符的数量（即 s1 完全被包含在滑动窗口内）  
            if (valid === map1.size) {  
                // 返回 true，表示 s1 是 s2 的一个子序列  
                return true;  
            }  
              
            // 获取当前左指针指向的字符  
            let d = s2[l];  
            // 左指针右移  
            l++;  
              
            // 更新滑动窗口内的字符信息  
            if (map2.has(d)) {  
                // 如果字符 d 在 map1 和 map2 中的出现次数相同  
                if (map1.get(d) === map2.get(d)) {  
                    // 有效字符计数减 1  
                    valid--;  
                }  
                // 更新 map2 中字符 d 的出现次数  
                map2.set(d, (map2.get(d) || 0) - 1);  
            }  
        }  
    }  
      
    // 如果遍历完 s2 都没有找到 s1 的完整匹配，则返回 false
    return false;  
};
```

## 438 [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```js
function findAnagrams(s, p){  
    const win = new Map()   
    const need = new Map()  
    const ans = []  
  
    // 遍历目标字符串p，统计每个字符的数量  
    for (let i = 0; i < p.length; i++) {  
        need.set(p[i], need.has(p[i]) ? need.get(p[i]) + 1 : 1)  
    }  
  
    // 定义滑动窗口的左右边界以及匹配字符的计数器  
    let left = 0, right = 0, match = 0  
  
    // 当右边界还未到达字符串s的末尾时，持续移动窗口  
    while (right < s.length) {  
        // 获取当前右边界的字符  
        const c = s[right]  
        // 右边界向右移动  
        right++  
  
        // 如果当前字符是目标字符串p所需要的  
        if (need.has(c)) {  
            // 在当前窗口中增加该字符的数量  
            win.set(c, win.has(c) ? win.get(c) + 1 : 1)  
            // 如果当前窗口中该字符的数量与目标字符串p中该字符的数量相等  
            if (win.get(c) === need.get(c)) {  
                // 匹配字符的计数器加一  
                match++  
            }  
        }  
  
        // 当窗口大小达到目标字符串p的长度时，开始检查是否找到了异位词  
        while (right - left >= p.length) {  
            // 如果所有目标字符都匹配了  
            if (match === need.size) {  
                // 将当前左边界的索引添加到结果数组中  
                ans.push(left)  
            }  
            // 获取当前左边界的字符  
            const d = s[left]  
            // 左边界向右移动  
            left++  
  
            // 如果当前字符是目标字符串p所需要的  
            if (need.has(d)) {  
                // 如果当前窗口中该字符的数量与目标字符串p中该字符的数量相等  
                if (win.get(d) === need.get(d)) {  
                    // 匹配字符的计数器减一  
                    match--  
                }  
                // 在当前窗口中减少该字符的数量  
                win.set(d, win.get(d) - 1)  
            }  
        }  
    }  
  
    // 返回所有找到的异位词的起始索引  
    return ans  
};
```

## 3 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长**子串 的长度。

```js
function lengthOfLongestSubstring(s) {  
    const win = new Set();  // 用于存储当前窗口内的字符
    let left = 0, right = 0; // 左右指针，用于滑动窗口
    let ans = 0; // 记录最长不重复子串的长度

    // 当右指针未到达字符串末尾时，继续循环
    while (right < s.length) {  
        let c = s[right]; // 当前正在遍历的字符

        // 如果当前字符在窗口中，说明出现了重复
        if (win.has(c)) {   
            c = s[left];  // 获取左指针所指向的字符
            win.delete(c);  // 从窗口中移除左指针的字符
            left++;  // 左指针向右移动，缩小窗口
        } else {   
            win.add(c);  // 如果没有重复，将字符加入窗口
            right++;  // 右指针向右移动，扩大窗口
        }   
        
        // 更新最长不重复子串的长度
        ans = Math.max(ans, win.size);  
    }      

    return ans;  // 返回最长不重复子串的长度
}
```

# d16 递归思想

## 344 [反转字符串](https://leetcode.cn/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

```js
var reverseString = function(s) {
    let len = s.length;
    for (let i = 0; i < len >> 1; i++) {
        [s[i], s[len - 1 - i]] = [s[len - 1 - i], s[i]];
    }
};
```

```js
var reverseString = function(s) { 
    reverse(s,0,s.length-1);
    return s;
};

var reverse = function(s, left, right){  //递归写法
    if(left >= right){
        return;
    }
    [s[left], s[right]] = [s[right],s[left]];
    reverse(s,left+1,right-1);
}
```

## 24 [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```js
var swapPairs = function (head) {
  let ret = new ListNode(0, head); // 创建一个虚拟头结点，值为0，next指向传入的链表头
  let cur = ret;

  // 遍历链表，直到没有足够的节点可以进行交换
  while (cur.next && cur.next.next) {
    let temp3 = cur.next.next.next; // 保存节点3
    let temp1 = cur.next; // 保存节点1
	
    cur.next = cur.next.next //虚拟头节点指向2
    cur.next.next = temp1 //2指向1
    temp1.next = temp3 //1指向3
    cur = cur.next.next //移动到34前 2位置
  }
  return ret.next; // 返回从虚拟头结点的下一个节点开始的修改后的链表
};
```

```js
// 递归写法
function swapPairs(head){
    return helper(head)
};

function helper(head) {
    if(head === null || head.next === null){
        return head
    }
    let headNext = head.next.next
    let p = head.next
    p.next = head
    head.next = helper(headNext)
    return p
}
```

## 509 [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

```js
var fib = function(n) {
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
    }
    return dp[n];
}
```

## 95 [不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

```js
var generateTrees = function (n) {
    const buildTree = (l, r) => {
        if (l > r) return [null];
        const res = [];
        // 遍历当前区间内的所有数字，每个数字i都可以作为根节点
        for (let i = l; i <= r; i++) {
            // 递归生成当前节点左子树的所有可能
            const left = buildTree(l, i - 1);
            // 递归生成当前节点右子树的所有可能
            const right = buildTree(i + 1, r);
            // 将左子树的每种可能与右子树的每种可能组合起来，构成以当前节点为根节点的所有可能的二叉搜索树
            for (let j = 0; j < left.length; j++) {
                for (let k = 0; k < right.length; k++) {
                    res.push(new TreeNode(i, left[j], right[k]));
                }
            }
        }
        // 返回当前区间内生成的所有可能的二叉搜索树
        return res;
    };
    // 调用buildTree函数，传入区间[1, n]，即从1到n的所有数字，生成所有可能的二叉搜索树
    return buildTree(1, n);
};
```

# d17 回溯算法

![回溯算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

## 0 回溯算法模板

> 核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。

```js
function backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 78 [子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

```js
var subsets = function(nums) {
    // 用于存储结果
    let res = [];
    // 用于记录回溯路径
    const track = [];

    // 定义回溯函数
    const backtrack = (nums, startIndex) => {
        // 将当前路径加入结果中，形成一个新的子集
        res.push([...track]);
        // 遍历原始数组
        for(let i = startIndex; i < nums.length; i++) {
            // 做出选择，将当前元素加入到路径中
            track.push(nums[i]);
            // 递归调用，继续向下搜索
            backtrack(nums, i + 1);
            // 撤销选择，将当前元素从路径中移除
            track.pop();
        }
    }
    // 调用回溯函数，起始索引为0
    backtrack(nums, 0);
    return res;
};
```

## 90 [子集 II](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列

```js
var subsetsWithDup = function(nums) {
    let result = []
    let path = []
    // 对原始数组进行排序，以便处理重复元素
    let sortNums = nums.sort((a, b) => {
        return a - b
    })
    function backtracing(startIndex, sortNums) {
        result.push([...path])
        // 如果起始索引超出数组长度，则直接返回
        if(startIndex > nums.length - 1) {
            return
        }
        for(let i = startIndex; i < nums.length; i++) {
            // 如果当前元素与前一个相同，并且不是起始索引处的元素，则跳过当前循环，避免重复
            if(i > startIndex && nums[i] === nums[i - 1]) {
                continue
            }
            path.push(nums[i])
            backtracing(i + 1, sortNums)
            path.pop()
        }
    }
    backtracing(0, sortNums)
    return result
};
```

## 46 [全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```js
var permute = function(nums) {
    let len = nums.length;
    const res = [];
    
    // 定义了一个嵌套函数 backtracking
    function backtracking(nums, path) {
        if(path.length === len) {
            res.push(path);
        }
        // 使用一个循环遍历数组 nums
        for(let i = 0; i< nums.length; i++) {
            // 对于每一个未被包含在当前排列中的数字
            // 如果 path 包含当前数字 nums[i]，则跳过当前循环
            if(path.includes(nums[i])) continue;
            // 将当前数字 nums[i] 加入到 path 中并递归调用 backtracking 函数生成剩余数字的排列
            backtracking(nums, [...path, nums[i]]);
        }
    }
    
    // 调用 backtracking 函数开始生成排列，初始时 path 为空数组
    backtracking(nums, []);

    // 返回最终的排列结果数组 res。
    return res;
};
```

## 47 [全排列 II](https://leetcode.cn/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

```js
var permuteUnique = function (nums) {
    nums.sort((a, b) => {
        return a - b
    }) // 将数组排序，确保相同的数字相邻，方便后续处理重复情况
    let result = [] // 用于存放最终结果的数组
    let path = [] // 当前排列的数组
    
    // 定义回溯函数，used 数组用于记录每个数字是否已被使用
    function backtracing(used) { 
        if (path.length === nums.length) { // 当当前排列长度等于原数组长度时，表示已生成一个排列
            result.push([...path]) // 将当前排列加入结果数组
            return
        }
        // 遍历数组 nums
        for (let i = 0; i < nums.length; i++) { 
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) { 
                // 当前数字与前一个数字相同且前一个数字未被使用时，跳过当前循环
                continue
            }
            if (!used[i]) { // 当前数字未被使用时
                used[i] = true // 标记当前数字为已使用
                path.push(nums[i]) // 将当前数字加入到当前排列中
                backtracing(used) // 递归调用回溯函数
                path.pop() // 撤销选择，将当前数字从当前排列中移除
                used[i] = false // 标记当前数字为未使用
            }
        }
    }
    backtracing([]) // 调用回溯函数，初始时 used 为空数组
    return result // 返回最终结果数组
};
```

# d18 动态规划

![img](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

动态规划：是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现(Memorization Search)。

**对于动态规划问题，我将拆解为如下五步曲：**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**常见四种类型：**

1. Matrix DP (10%)
2. Sequence (40%)
3. Two Sequences DP (40%)
4. Backpack (10%)

## 01 矩阵类型（10%）

### 64 [最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

```js
var minPathSum = function (grid) { // 定义名为 minPathSum 的函数，接受一个二维网格数组作为输入
    let m = grid.length; // 获取网格的行数
    let n = grid[0].length; // 获取网格的列数

    // 循环遍历网格，从第二行（索引为1）开始直到最后一行
    for (let i = 1; i < m; i++) {
        // 对于每个第二行及以后的单元格，将其值与上方单元格的值相加
        grid[i][0] += grid[i - 1][0];
    }

    // 循环遍历网格，从第二列（索引为1）开始直到最后一列
    for (let i = 1; i < n; i++) {
        // 对于每个第二列及以后的单元格，将其值与左侧单元格的值相加
        grid[0][i] += grid[0][i - 1];
    }

    // 循环遍历网格，从第二行（索引为1）和第二列（索引为1）开始直到最后一行和最后一列
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            // 对于每个单元格（除了第一行和第一列），计算到达该单元格的最小路径和，考虑上方单元格和左侧单元格中的最小值，并加上当前单元格的值
            grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
        }
    }

    // 返回计算出的网格最后一个单元格（右下角）的最小路径和值
    return grid[m - 1][n - 1];
};
```

### 62 [不同路径](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。  问总共有多少条不同的路径？

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(new Array(n).fill(1)) //第一行和第一列都是1
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[m - 1][n - 1]
};
```

### 63 [不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

> 思路：第一行（列）遇到障碍物之前置为1，之后置为0（包括障碍物）

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    let m = obstacleGrid.length;
    let n = obstacleGrid[0].length;
    let memo = new Array(m);
    for (let i=0;i<m;i++) {
        memo[i] = new Array(n).fill(0)
    }
    function dp(i,j) {
        if (i>=m || i<0||j>=n||j<0 || obstacleGrid[i][j] === 1) {
            return 0;
        }
        if (i===0&&j===0) {
            return 1
        }
        if (memo[i][j] > 0) {
            return memo[i][j]
        }
        let left = dp(i-1, j)
        let right = dp(i, j-1)
        memo[i][j] = left +right;
        return memo[i][j]
    }
    return dp(m-1,n-1)
};
```

# d19 贪心算法



# d20 剑指offer

### 03 数组中重复的数字

 [LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

设备中存有 `n` 个文件，文件 `id` 记于数组 `documents`。若文件 `id` 相同，则定义为该文件存在副本。请返回任一存在副本的文件 `id`。

> 哈希表 O(n) O(n) 这个id在documentCounts存在说明有副本就返回 不存在就计数加1

```js
var findRepeatDocument = function(documents) {  
  const documentCounts = {};  
  // const documentCounts = new Map(); 
  for (const id of documents) {  
    // if (documentCounts.has(id)) {}
    if (documentCounts[id]) {  
      return id; // 一旦发现副本，直接返回ID  
    }  
    documentCounts[id] = (documentCounts[id] || 0) + 1; // 使用逻辑或运算符初始化计数  
  }  
  
  return null; // 如果没有找到副本，返回null  
};
```

### 04 二维数组中的查找

 [LCR 121. 寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

`m`*`n` 的二维数组 `plants` 记录了园林景观的植物排布情况，具有以下特性：

- 每行中，每棵植物的右侧相邻植物不矮于该植物；
- 每列中，每棵植物的下侧相邻植物不矮于该植物。

 请判断 `plants` 中是否存在目标高度值 `target`。

> 首先进行非空判断，即排除matrix＝[]和matrix＝[[]]，然后找目标数，找右上角数字作为目标数，它为第一列最大数字，是本行最小数字。如果target 大于该数则向下查找，否则往左查找。

```js
var findTargetIn2DPlants = function(plants, target) {   
    if (plants.length === 0) return false;  
     
    let row = 0;  
    let col = plants[0].length - 1; // 从右上角开始  
  
    while (row < plants.length && col >= 0) {  
        if (plants[row][col] === target) {  
            return true; // 找到目标高度值  
        } else if (plants[row][col] < target) {  
            row++; // 当前植物低于目标值，向下搜索  
        } else {  
            col--; // 当前植物高于目标值，向左搜索  
        }  
    }  
  
    return false;
};
```

### [剑指offer05 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

[LCR 122. 路径加密](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

假定一段路径记作字符串 `path`，其中以 "`.`" 作为分隔符。现需将路径加密，加密方法为将 `path` 中的分隔符替换为空格 "` `"，请返回加密后的字符串。

```js
var pathEncryption = function(path) {
    let result = '';
    for (let i = 0; i < path.length; i++) {
        // 如果是 '.', 将其替换为 ' ',否则添加原字符
        if (path[i] === '.') {
            result += ' ';
        } else {
            result += path[i];
        }
    }
    return result;
};
```

```js
var pathEncryption = function(path) {
    return path.replaceAll('.', ' ')
};
```

```js
var pathEncryption = function(path) {
    return path.replace(/\./g, ' ')
};
```



###  剑指offer11 旋转数组的最小数字

 [LCR 128. 库存管理 I](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

仓库管理员以数组 `stock` 形式记录商品库存表。`stock[i]` 表示商品 `id`，可能存在重复。原库存表按商品 `id` 升序排列。现因突发情况需要进行商品紧急调拨，管理员将这批商品 `id` 提前依次整理至库存表最后。请你找到并返回库存表中编号的 **最小的元素** 以便及时记录本次调拨。

```js
var stockManagement = function(stock) {
    let left = 0
    let right =  stock.length - 1
    
    while (left < right) {
        let mid = Math.floor((left + right) / 2)
        if (stock[mid] > stock[right]) {
            left = mid + 1
        } else if (stock[mid] < stock[right]){
            right = mid
        } else {
            right --
        }
    }
    return stock[left]
};
```

### 剑指offer14-Ⅰ 剪绳子

 [LCR 131. 砍竹子 I](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

> 整数拆分

现需要将一根长为正整数 `bamboo_len` 的竹子砍为若干段，每段长度均为正整数。请返回每段竹子长度的最大乘积是多少。

```js
// 通过分析得到尽可能切为长度为3的片段，最后得到的乘积最大，则最后变成了3a+b＝n这样的函数求最大值。math.pow(x,y)表示x的y次方。
var cuttingBamboo = function(bamboo_len) {
    if(bamboo_len==1) return 1;
    else if(bamboo_len<=3) return 2;
    else if(bamboo_len%3==0) return 3**(bamboo_len/3);
    else if(bamboo_len%3==1) return 3**(Math.floor(bamboo_len/3)-1)*2*2;
    else if(bamboo_len%3==2) return 3**(Math.floor(bamboo_len/3))*2
};
```

```js
var cuttingBamboo = function(n) {
    let dp = new Array(n + 1).fill(0);
    dp[2] = 1; // 长度为2的绳子可以拆分为1和1
    // 遍历长度为 i 的竹子
    for (let i = 3; i <= n; i++) {
        // 遍历切割位置 j
        for (let j = 1; j < i - 1; j++) {
            dp[i] = Math.max(dp[i], Math.max((i - j) * j, dp[i - j] * j));
        }
    }
    return dp[n];
}
```

### 剑指offer14-Ⅱ 剪绳子

 [LCR 132. 砍竹子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

现需要将一根长为正整数 `bamboo_len` 的竹子砍为若干段，每段长度均为 **正整数**。请返回每段竹子长度的 **最大乘积** 是多少。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

> 考虑大数越界的情况下的求余问题。可能超过int的范围，大数求余方法包括循环求余（O(N)）和快速幂(log2(N))求余。

```js
// 在I 减绳子此基础上，每累积3之后，要取模。贪心算法，所有绳子的长度相等时，乘积最大，最优绳长为3。
var cuttingBamboo = function(bamboo_len) {
    if (bamboo_len <= 3) {
        return bamboo_len - 1;
    }
    // res 用来存储当前计算的最大乘积
    let res = 1;
    // 循环分割长度为 3 的绳子
    while (bamboo_len > 4) {
        res *= 3;
        res %= 1000000007;
        bamboo_len -= 3;
    }
    return res * bamboo_len % 1000000007;
};
```

### 剑指offer17 打印从1到最大的n位数

 [LCR 135. 报数](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

实现一个十进制数字报数程序，请按照数字从小到大的顺序返回一个整数数列，该数列从数字 `1` 开始，到最大的正整数 `cnt` 位数字结束。

> 循环生成整数序列：使用一个 `for` 循环，从 1 开始迭代到 10 的 `cnt` 次方减去 1，这样可以保证生成的整数不超过 `cnt` 位数。在每次循环中，将当前的整数 `i` 添加到 `ans` 数组中。

```js
var countNumbers = function(cnt) {
    let ans = []
    for(let i=1; i < Math.pow(10, cnt); i++){
        ans.push(i)
    }
    return ans
};
```

```js
var countNumbers = function(n) {
    const res = [];
    // 深度优先搜索（DFS）函数，用于生成所有可能的数字组合
    function dfs(index, num, digit) {
        // 当当前生成的数字长度等于 digit 时，将其加入结果数组
        if (index === digit) {
            res.push(parseInt(num.join('')));  // 将数组转换成整数后加入结果数组
            return;
        }
        // 枚举当前位的所有可能数字（0-9）
        for (let i = 0; i < 10; i++) {
            num.push(i.toString());  // 将当前数字转换成字符串后加入数组
            dfs(index + 1, num, digit);  // 递归生成下一位数字
            num.pop();  // 回退一步，以便生成其他组合
        }
    }

    // 遍历从 1 位数到 n 位数的所有可能组合
    for (let digit = 1; digit <= n; digit++) {
        // 对于每个位数，从 1 到 9 开始生成数字（避免从 0 开始）
        for (let first = 1; first < 10; first++) {
            const num = [first.toString()];  // 初始化当前数字
            dfs(1, num, digit);  // 开始深度优先搜索生成剩余位的数字组合
        }
    }
    return res;
}
```

### [剑指offer20 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

[LCR 138. 有效数字](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

**有效数字**（按顺序）可以分成以下几个部分：

1. 若干空格
2. 一个 **小数** 或者 **整数**
3. （可选）一个 `'e'` 或 `'E'` ，后面跟着一个 **整数**
4. 若干空格

**小数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（`'+'` 或 `'-'`）
2. 下述格式之一：
   1. 至少一位数字，后面跟着一个点 `'.'`
   2. 至少一位数字，后面跟着一个点 `'.'` ，后面再跟着至少一位数字
   3. 一个点 `'.'` ，后面跟着至少一位数字

**整数**（按顺序）可以分成以下几个部分：

1. （可选）一个符号字符（`'+'` 或 `'-'`）
2. 至少一位数字

部分有效数字列举如下：`["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]`

部分无效数字列举如下：`["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]`

给你一个字符串 `s` ，如果 `s` 是一个 **有效数字** ，请返回 `true` 。

```js
var validNumber = function(s) {
    return !!s.trim().length && !Number.isNaN(Number(s.trim()));
    // 首先，检查字符串在去除空格后是否是非空的(双感叹号（!!）是将值转为布尔值)。然后，尝试将其转化为数值。如果转化后不是 NaN，则表示这个字符串代表一个数值，返回 true；否则返回 false。 
};
```

```js
// ‘.’出现正确情况：只出现一次，且在e的前面，‘e’出现正确情况：只出现一次，且出现前有数字，‘+’‘-’出现正确情况：只能在开头和e后一位
var validNumber = function(s) {
    if (!s) {
        return false
    }
    s = s.trim()
    let isNum = false
    let isE = false
    let isDot = false

     for(let i = 0; i < s.length; i++) {
        // 1. 先判断是不是数字，是的话isNum = true
        if (s[i] >= '0' && s[i] <= '9') {
            isNum = true
        // 2. 再判断是不是小数点，是的话前面不能有小数点和e
        } else if (s[i] === '.') {
            if (isDot || isE) {
                return false
            }
            isDot = true
        // 3. 再判断是不是e，是的话前面不能有重复的e，必须有数字
        } else if (s[i] === 'e' || s[i] === 'E') {
            if (isE || !isNum) {
                return false
            }
            isE = true
            isNum = false
        // 4. 如果为 '+' 或 '-'，只能出现在第一位或者紧接 'e' 后面
        } else if (s[i] === '+' || s[i] === '-') {
            if (i !== 0 && !['e', 'E'].includes(s[i - 1])) {
                return false
            }
        // 5. 其他情况，都是非法的
        } else {
            return false
        }
     }
     return isNum
};
```



### 剑指offer21 调整数组顺序使奇数位于偶数前面

 [LCR 139. 训练计划 I](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

教练使用整数数组 `actions` 记录一系列核心肌群训练项目编号。为增强训练趣味性，需要将所有奇数编号训练项目调整至偶数编号训练项目之前。请将调整后的训练项目编号以 **数组** 形式返回。

> 使用了一个指针 `k` 来记录奇数编号训练项目应该插入的位置，然后通过交换元素的方式将奇数编号训练项目移动到偶数编号训练项目之前。

```js
var trainingPlan = function(actions) {
    let k = 0;
    for (let i = 0; i < actions.length; ++i) {
        if (actions[i] % 2 === 1) {
            [actions[i], actions[k]] = [actions[k], actions[i]];
            k++;
        }
    }
    return actions;
};
```

> 快排：将基准**右边比基准小的数**与基准**左边比基准大的数**互换
>
> 类比左奇右偶来说：将**右边的奇数**与基准**左边的偶数**互换
>
> 基于双指针思路：分别找到**右边的奇数**和**左边的偶数**的指针位置，进行交换

```js
var trainingPlan = function(nums) {
    let left = 0, right = nums.length - 1;
    while (left < right) {
        // 找到左边的偶数指针
        while (left < right && nums[left] % 2 !== 0) {
            left++;
        }
        // 找到右边的奇数指针
        while (left < right && nums[right] % 2 === 0) {
            right--;
        }
        // 进行交换
        if (left < right) {
            let tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
        }
    }
    return nums;
};
```

### [剑指offer38 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

[LCR 157. 套餐内商品的排列顺序](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

某店铺将用于组成套餐的商品记作字符串 `goods`，其中 `goods[i]` 表示对应商品。请返回该套餐内所含商品的 **全部排列方式** 。

 返回结果 **无顺序要求**，但不能含有重复的元素。

> DFS+剪枝：首先将字符串分割成字符数组，然后定义一个递归函数，如果已经处理到了最后一个字符，就将当前合并为字符串，并将其加入结果数组，否则：使用set记录已处理的字符，遍历剩余字符，如果处理过就跳过，没处理过将当前字符加入到set中，然后通过交换字符的位置来生成不同的排列，交换后递归处理下一个字符并交换回来。

```js
var goodsOrder = function(goods) {
    const results = []; // 存储生成的排列结果的数组
    const chars = goods.split(''); // 将输入字符串分割成字符数组

    // 递归生成所有可能的排列
    function dfs(x) {
        if (x === chars.length - 1) { // 如果当前字符是最后一个
            results.push(chars.join('')); // 将当前字符数组转为字符串并添加到结果
            return; // 退出递归
        }

        const seen = new Set(); // 用于记录已处理的字符，防止重复
        for (let i = x; i < chars.length; i++) { // 遍历剩余字符
            if (seen.has(chars[i])) continue; // 如果字符已经处理过，跳过以避免重复
            seen.add(chars[i]); // 将当前字符添加到 seen 集合中

            // 交换字符
            [chars[x], chars[i]] = [chars[i], chars[x]]; // 将字符 i 和字符 x 交换位置
            dfs(x + 1); // 递归处理下一个字符
            [chars[x], chars[i]] = [chars[i], chars[x]]; // 恢复交换，确保下次递归前还原原始状态
        }
    }
    dfs(0); // 开始递归，从第一个字符开始
    return results; // 返回所有生成的排列
};
```



### 剑指offer39 数组中出现次数超过一半的数字

 [LCR 158. 库存管理 II](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

仓库管理员以数组 `stock` 形式记录商品库存表。`stock[i]` 表示商品 `id`，可能存在重复。请返回库存表中数量大于 `stock.length / 2` 的商品 `id`。

> 统计数量然后找到数量大于 `stock.length / 2` 的商品id

```js
var inventoryManagement = function(stock) {
    const countMap = new Map();
    // 统计每个商品的数量
    for (let i = 0; i < stock.length; i++) {
        const id = stock[i];
        // 商品 id 的当前计数 || 0
        countMap.set(id, (countMap.get(id) || 0) + 1);
    }
    
    // 找出数量大于 stock.length / 2 的商品
    for (const [id, count] of countMap.entries()) {
        if (count > stock.length / 2) {
            return id;
        }
    }
    return null; // 如果不存在数量大于 stock.length / 2 的商品
};
```

```js
// 摩尔投票法 
var inventoryManagement = function(nums) {
    let ans = 0, count = 0; //ans：多数商品 count：ans出现次数 
    for (let i = 0; i < nums.length; i++) {
        if (count === 0) {
            ans = nums[i];
            count++;
        } else {
            // 如果nums[i] === ans 就+1
            count += nums[i] === ans ? 1 : -1;
        }
    }
    return ans;
};
```

### 剑指offer40 最小的k个数

 [LCR 159. 库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。

```js
var inventoryManagement = function(stock, cnt) {
    stock.sort((a,b) => a-b);
    return stock.slice(0, cnt); //从索引0开始到索引cnt-1的元素
};
```

```js
var inventoryManagement = function(arr, k) {
    if (k === 0 || arr.length === 0) return [];

    function quickSort(nums, low, high, k) {
        let pivot = Partition(nums, low, high);
        if (pivot === k) {
            return nums.slice(0, pivot + 1);
        } else if (pivot > k) {
                return quickSort(nums, low, pivot - 1, k);
        } else {
                return quickSort(nums, pivot + 1, high, k);
        }
    }

    function Partition(nums, low, high) {
        let pivot = nums[low];
        while (low < high) {
            // 从右向左移动 high 指针，找到第一个小于枢纽元素 pivot 的元素
            while (low < high && nums[high] >= pivot) high--;
            // 将小于枢纽元素的元素放到左侧
            nums[low] = nums[high];
            // 从左向右找到第一个大于枢纽元素的元素
            while (low < high && nums[low] <= pivot) low++;
            // 将大于枢纽元素的元素放到右侧
            nums[high] = nums[low];
        }
        nums[low] = pivot;
        return low;
    }
    
    return quickSort(arr, 0, arr.length - 1, k - 1);
}
```

### 剑指offer41 数组流中的中位数

 [LCR 160. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

**中位数** 是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

例如，`[2,3,4]` 的中位数是 `3`，`[2,3]` 的中位数是 `(2 + 3) / 2 = 2.5`

设计一个支持以下两种操作的数据结构：

- `void addNum(int num)` - 从数据流中添加一个整数到数据结构中。
- `double findMedian()` - 返回目前所有元素的中位数。

> 它使用了二分搜索插入的方式来维护一个有序数组 `this.nums`，并根据数组的长度来确定中位数。在 `addNum` 方法中，它使用二分搜索找到要插入的位置，并使用 `splice` 方法将新元素插入到数组中，以保持数组的有序性。在 `findMedian` 方法中，根据数组的长度来确定中位数。如果数组长度为偶数，则取中间两个数的平均值作为中位数；如果数组长度为奇数，则取中间的数作为中位数。

```js
var MedianFinder = function() {
    this.nums = [];
};

MedianFinder.prototype.addNum = function(num) {
    let left = 0;
    let right = this.nums.length;

    while (left < right) {
        const mid = Math.floor((left + right) / 2);
        if (this.nums[mid] < num) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    // 在正确的位置插入元素 array.splice(start, deleteCount, item1, item2, ...)
    this.nums.splice(left, 0, num);
};

MedianFinder.prototype.findMedian = function() {
    const len = this.nums.length;
    if (len % 2 === 1) {
        // 如果长度是奇数，中位数是中间的那个数
        return this.nums[Math.floor(len / 2)];
    } else {
        // 如果长度是偶数，中位数是中间两个数的平均值
        const mid1 = this.nums[len / 2 - 1];
        const mid2 = this.nums[len / 2];
        return (mid1 + mid2) / 2;
    }
};
```

> 建立一个小顶堆A和[大顶堆](https://so.csdn.net/so/search?q=大顶堆&spm=1001.2101.3001.7020)B，各保存列表的一半元素。那么什么叫小顶堆和大顶堆呢？小顶堆和大顶堆，其本质是一颗完全二叉树。除叶子节点外，小顶堆的每个父节点的key都要比其左右两个子节点的key小；大顶堆的每个父节点的key都要比其左右两个子节点的key大。这里说的key暂时理解为节点的取值吧，而index为节点在树中的索引或者位置。小顶堆/大顶堆的特点在于，其根节点一定是整个数中最小或者最大的元素：
>
> - A保存较大的一半，长度为N/2（N为偶数）或(N+1)/2（N为奇数）；
> - B保存较小的一半，长度为N/2（N为偶数）或(N-1)/2（N为奇数）

```js
/**
 * initialize your data structure here.
 */
var MedianFinder = function () {
    this.maxHeap = new Heap(true);  // 保存小的一半
    this.minHeap = new Heap(false); // 保存大的一半
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {
    if (this.maxHeap.size() === 0 || num <= this.maxHeap.peek()) {
        this.maxHeap.insert(num);
    } else {
        this.minHeap.insert(num);
    }

    // Balance the heaps ，保持 maxHeap 等于或比 minHeap 多一个
    if (this.maxHeap.size() > this.minHeap.size() + 1) {
        this.minHeap.insert(this.maxHeap.removeTop());
    } else if (this.minHeap.size() > this.maxHeap.size()) {
        this.maxHeap.insert(this.minHeap.removeTop());
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {
    if (this.maxHeap.size() === this.minHeap.size()) {
        return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
    } else {
        return this.maxHeap.peek();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */


// Helper class for Min Heap
class Heap {
    constructor(isMax) {
        this.isMax = isMax;
        this.heap = [];
    }

    insert(num) {
        this.heap.push(num);
        let idx = this.heap.length - 1;
        while (idx > 0) {
            const parentIdx = Math.floor((idx - 1) / 2);

            if (!this.isMax ? this.heap[idx] < this.heap[parentIdx] : this.heap[idx] > this.heap[parentIdx]) {
                [this.heap[idx], this.heap[parentIdx]] = [this.heap[parentIdx], this.heap[idx]];
                idx = parentIdx;
            } else {
                break;
            }
        }
    }

    removeTop() {
        const top = this.heap[0];
        [this.heap[0], this.heap[this.heap.length - 1]] = [this.heap[this.heap.length - 1], this.heap[0]];
        this.heap.pop();
        this.bubbleDown(0);
        return top;
    }

    peek() {
        return this.heap[0];
    }

    size() {
        return this.heap.length;
    }

    bubbleDown(idx) {
        const left = 2 * idx + 1;
        const right = left + 1;

        let swapIdx = idx;
        const compare = (a, b) => {
            return this.isMax ? a > b : a < b;
        }

        if (left < this.heap.length && compare(this.heap[left], this.heap[swapIdx])) {
            swapIdx = left;
        }
        if (right < this.heap.length && compare(this.heap[right], this.heap[swapIdx])) {
            swapIdx = right;
        }
        if (swapIdx !== idx) {
            [this.heap[idx], this.heap[swapIdx]] = [this.heap[swapIdx], this.heap[idx]];
            this.bubbleDown(swapIdx);
        }

    }
}
```

### [剑指 Offer42 连续子数组的最大和](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```js
var maxSales = function(nums) {
    for (let i = 1; i < nums.length; i++) {
        nums[i] += Math.max(nums[i - 1], 0);
    }
    return Math.max(...nums);
};
```

```js
var maxSales = function(nums) {
    let ans = -Infinity;
    let s = 0;

    for (let val of nums) {
        s = Math.max(s + val, val);
        ans = Math.max(ans, s);
    }

    return ans;
};
```

打印出具有最大连续子数组的和的那个子数组，如果存在多个这样的子数组，把最左边的那个打印出来。

```js
var maxSales = function(nums) {
    let ans = -Infinity;
    let s = 0;
    let left = 0, right = 0; // 记录最大连续子数组和的起始和结束索引

    for (let i = 0; i < nums.length; i++) {
        if (s + nums[i] < nums[i]) {
            left = right = i;
            s = nums[i];
        } else {
            s += nums[i];
        }

        if (ans < s) {
            ans = s;
            right = i;
        }
    }
    console.log(nums.slice(left, right + 1)); // 输出最大连续子数组
    return ans;
};
```

### * [43 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

输入一个整数 `n` ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

```js
var digitOneInNumber = function(num) {
    let count = 0;
    for (let i = 0; i <= num; i++) {
        let currentNumber = i.toString();
        for (let char of currentNumber) {
            if (char === '1') {
                count++;
            }
        }
    }
    return count;
};
// 超出时间限制
```

```js
var digitOneInNumber = function(num) {
    let a = 1, b = 10, count = 0;
    while (num >= a) {
        let x = Math.floor(num / b); // 当前位之前的数字部分（高位）
        let y = num % b; // 当前位及其之后的数字部分（低位）

        if (y >= a * 2) {
            count += (x + 1) * a; 
        } else if (y >= a) {
            count += y + 1 + (x - 1) * a; 
        } else {
            count += x * a;
        }

        a = b; // 更新当前位数权重为下一位数的权重
        b *= 10; // 更新下一位数的权重为更高一位数的权重
    }
    return count; // 返回所有小于等于 num 的非负整数中数字 1 出现的总次数
};
```

### 剑指offer45 把数组排成最小的数（快排）

 [LCR 164. 破解闯关密码](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

闯关游戏需要破解一组密码，闯关组给出的有关密码的线索是：

- 一个拥有密码所有元素的非负整数数组 `password`
- 密码是 `password` 中所有元素拼接后得到的最小的一个数

请编写一个程序返回这个密码。

```js
var crackPassword = function(arr) {
    // 调用 quickSort 函数对数组进行排序，并将排序后的数组拼接成字符串返回
    return quickSort(arr).join('')
};

// 定义快速排序函数
function quickSort(arr) {
    // 如果数组长度小于 2，说明已经有序，直接返回该数组
    if (arr.length < 2) {
        return arr
    }
    // 定义左边界为数组第一个元素的索引，右边界为数组最后一个元素的索引
    const left = 0
    const right = arr.length - 1
    // 计算数组中间位置的索引（使用无符号右移运算符提高效率）
    const mid = (left + right) >>> 1
    // 获取中间位置的元素值作为参考值（pivot）
    const midVal = arr.splice(mid, 1)[0]
    // 定义左侧数组和右侧数组，用于存放比参考值小和大的元素
    const leftArr = []
    const rightArr = []
    // 遍历原数组中剩余的元素，比较每个元素与参考值拼接后的字符串的大小关系
    for(let i = 0, length = arr.length; i < length; i++) {
        // 如果拼接后的字符串表示的数字与参考值拼接后的字符串的字典序更小，则将该元素放入左侧数组中
        if (String(arr[i]) + midVal < String(midVal) + arr[i]) {
            leftArr.push(arr[i])
        } else {
            // 否则，将该元素放入右侧数组中
            rightArr.push(arr[i])
        }
    }
    // 分别对左侧数组和右侧数组递归调用 quickSort 函数，并将结果与参考值拼接后返回，形成排序后的数组
    return quickSort(leftArr).concat([midVal], quickSort(rightArr))
}
```

### [剑指offer48 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

[LCR 167. 招式拆解 I](https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

某套连招动作记作序列 `arr`，其中 `arr[i]` 为第 `i` 个招式的名字。请返回 `arr` 中最多可以出连续不重复的多少个招式。

> 解法：滑动窗口+哈希表。本题采用滑动窗口，利用哈希表来做优化。使用哈希表记录每个字符的下一个索引，然后尽量向右移动尾指针来拓展窗口，并更新窗口的最大长度。如果尾指针指向的元素重复，则头指针直接移动到窗口中重复元素的右侧。

```js
var dismantlingAction = function(str) {
    let res = 0; // 记录最长不重复子串的长度
    const dict = new Map(); // 用于记录字符及其上次出现的位置

    // 初始化两个指针，i 为左指针，j 为右指针
    for (let i = -1, j = 0; j < str.length; j++) {
        const c = str[j]; // 当前正在遍历的字符
        // 如果字符在哈希表中，更新左指针 i 的位置
        if (dict.has(c)) {
            i = Math.max(i, dict.get(c)); // 把左指针i移动到重复字符之后的位置
        }
        // 将当前字符的位置记录在哈希表中
        dict.set(c, j);
        // 计算当前不重复子串的长度，并更新最大长度 res
        res = Math.max(res, j - i); // 长度等于右指针减去左指针
    }

    return res; // 返回最长不重复子串的长度
}
```

### [剑指offer49 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)（动态规划）

[LCR 168. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

给你一个整数 `n` ，请你找出并返回第 `n` 个 丑数 。

**说明：**丑数是只包含质因数 2、3 和/或 5 的正整数；1 是丑数。

> 丑数=某较小丑数*某因子。设置指针a,b,c指向首个丑数（即1），循环根据递推公式得到下一个丑数，并将每轮对应指针执行+1即可。

```js
var nthUglyNumber = function(n) {
    let dp = new Array(n);
    dp[0] = 1; // 将第一个丑数设为 1
    let a = 0, b = 0, c = 0;

    // 从第二个丑数开始计算，直到第 n 个丑数
    for (let i = 1; i < n; i++) {
        // 计算当前位置 i 的丑数，该丑数是由已知丑数数组 dp 中的 a、b、c 位置对应的丑数乘以对应的因子（2、3 或 5）得到的三个值中的最小值
        dp[i] = Math.min(dp[a] * 2, dp[b] * 3, dp[c] * 5);
        // 更新指针 a、b、c 的位置
        if (dp[i] === dp[a] * 2) a++;      
        if (dp[i] === dp[b] * 3) b++;
        if (dp[i] === dp[c] * 5) c++;
    }
    // 返回第 n 个丑数
    return dp[n - 1];
};
```

### [剑指offer50 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

[LCR 169. 招式拆解 II](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

某套连招动作记作仅由小写字母组成的序列 `arr`，其中 `arr[i]` 第 `i` 个招式的名字。请返回第一个只出现一次的招式名称，如不存在请返回空格。

> 解法：哈希表。首先遍历字符串s，使用哈希表统计“各字符数量是否>1”，然后再遍历字符串s，在哈希表中找到首个“数量为1的字符”。

```js
var firstUniqChar = function (s) {
  // 统计每个招式名称的出现次数
  let map = new Map();
  for (let c of s) {
    map.set(c, (map.get(c) || 0) + 1);
  }
  // 遍历字符串，找到第一个只出现一次的招式名称
  for (let [key, val] of map.entries()) {
    if (val == 1) return key;
  }
  return " ";
};
```

```js
var firstUniqChar = function(s) {
    for(let x of s){
        if(s.indexOf(x) === s.lastIndexOf(x)) return x
    }
    return ' '
};
```



### （）[剑指offer51 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)（归并排序）

[LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 `record`，返回其中存在的「交易逆序对」总数。

> 利用归并排序的“合并”部分，在合并的过程中比较左右区间，从而计算逆序对。

![img](https://img-blog.csdnimg.cn/20210705210123731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0MDI4MA==,size_16,color_FFFFFF,t_70)

```js
var reversePairs = function(record) {  
    // 创建一个临时数组，长度比原数组多1，用于归并排序时的元素存储  
    let t = new Array(record.length + 1);  
  
    // 定义一个归并排序的函数，用于排序并计算逆序对
    function merge_sort(arr, l, r){
        if(l >= r)  return 0;    
        let mid = l + r >> 1;
        
        // 递归调用merge_sort函数，分别计算左右两个子数组的逆序对数量，并求和
        let ans = merge_sort(arr,l, mid)+ merge_sort(arr, mid + 1, r);
        
        // 初始化临时数组和指针  
        let k = 0, i = l , j = mid + 1;  
  
        // 合并左右两个子数组，同时计算逆序对数量  
        while(i <= mid && j <= r){  
            // 如果左子数组的元素小于等于右子数组的元素，则直接放入临时数组  
            if(arr[i] <= arr[j]) {  
                t[k++] = arr[i++]  
            }else {  
                // 如果左子数组的元素大于右子数组的元素，则产生逆序对  
                // 逆序对数量等于右子数组剩余元素数量（因为左子数组当前元素大于右子数组所有剩余元素）  
                ans += mid - i + 1;  
                // 将右子数组的元素放入临时数组  
                t[k++] = arr[j++];  
            }  
        }  
  
        // 将左子数组剩余元素放入临时数组  
        while(i <= mid){  
            t[k++] = arr[i++]  
        }  
  
        // 将右子数组剩余元素放入临时数组  
        while(j <= r){  
            t[k++] = arr[j++]  
        }  
  
        // 将临时数组中的元素复制回原数组  
        // copy back   
        for(let i = l , j = 0; i <= r ; i++, j++){  
            arr[i] = t[j]  
        }  
  
        // 返回当前子数组的逆序对数量  
        return ans  
    }  
  
    // 调用merge_sort函数，对整个数组进行排序并计算逆序对数量  
    return merge_sort(record, 0, record.length - 1)  
};
```

### （）[剑指offer53-I 在排序数组中查找数字](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)（二分查找）

[LCR 172. 统计目标成绩的出现次数](https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

某班级考试成绩按非严格递增顺序记录于整数数组 `scores`，请返回目标成绩 `target` 的出现次数。

```js
var countTarget = function(scores, target) {
    return scores.filter(score => score === target).length;
};
```

```js
// 定义二分查找左边界的函数  
const binarySearchLeft = (scores, target) => {  
  let left = 0;                             // 初始化左边界为数组起始位置  
  let right = scores.length - 1;            // 初始化右边界为数组结束位置  
  
  while (left <= right) {                    // 当左边界小于等于右边界时循环  
    let mid = Math.floor(left + (right - left) / 2); 
  
    // 如果中间位置的值等于目标值  
    if (scores[mid] == target) {  
      right = mid - 1;        // 目标值可能在左半部分，更新右边界为中间位置左边一个位置  
    } else if (scores[mid] < target) {      // 如果中间位置的值小于目标值  
      left = mid + 1;         // 目标值必定在右半部分，更新左边界为中间位置右边一个位置  
    } else if (scores[mid] > target) {      // 如果中间位置的值大于目标值  
      right = mid - 1;        // 目标值必定在左半部分，更新右边界为中间位置左边一个位置  
    }  
  }  
  
  return left;        // 返回左边界索引，此时left指向的是第一个大于target的位置或数组末尾之后  
};  
  
// 定义二分查找右边界的函数  
const binarySearchRight = (scores, target) => {  
  let left = 0;                             // 初始化左边界为数组起始位置  
  let right = scores.length - 1;            // 初始化右边界为数组结束位置  
  
  while (left <= right) {                    // 当左边界小于等于右边界时循环  
    let mid = Math.floor(left + (right - left) / 2); // 计算中间位置  
  
    // 如果中间位置的值等于目标值  
    if (scores[mid] == target) {  
      left = mid + 1;      // 目标值可能在右半部分，更新左边界为中间位置右边一个位置  
    } else if (scores[mid] < target) {      // 如果中间位置的值小于目标值  
      left = mid + 1;      // 目标值必定在右半部分，更新左边界为中间位置右边一个位置  
    } else if (scores[mid] > target) {      // 如果中间位置的值大于目标值  
      right = mid - 1;     // 目标值必定在左半部分，更新右边界为中间位置左边一个位置  
    }  
  }  
  
  return right;      // 返回右边界索引，此时right指向的是第一个小于target的位置或数组起始位置之前  
};  
  
// 定义计算目标值出现次数的函数  
var countTarget = function(scores, target) {  
  const leftIdx = binarySearchLeft(scores, target);   
  const rightIdx = binarySearchRight(scores, target); 
  
  // 判断左右边界索引是否有效  
  if (leftIdx > scores.length - 1 || rightIdx < 0 || leftIdx > rightIdx) {  
    return 0;  // 如果无效，则返回0  
  } else if (leftIdx >= 0 && rightIdx <= scores.length - 1 && leftIdx <= rightIdx) {  
    let ans = rightIdx - leftIdx + 1;  // 计算目标值的出现次数，为右边界索引减去左边界索引再加1  
    return ans;                        // 返回出现次数  
  }  
};
```

### [剑指offer53-II 0~n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)（二分查找）

[LCR 173. 点名](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

某班级 n 位同学的学号为 0 ~ n-1。点名结果记录于升序数组 `records`。假定仅有一位同学缺席，请返回他的学号。

```js
var takeAttendance = function(records) {
    let i = 0;  
    let j = records.length - 1;  

    while (i <= j) {  
        let m = Math.floor((i + j) / 2); // 获得列表中间值的索引  

        if (records[m] === m) {  
            i = m + 1;  
        } else {  
            j = m - 1;  
        }  
    }  
    return i;  
}  
```

### [剑指offer57-I 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)（双指针）

[LCR 179. 查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

购物车内的商品价格按照升序记录于数组 `price`。请在购物车中找到两个商品的价格总和刚好是 `target`。若存在多种情况，返回任一结果即可。

```js
var twoSum = function(price, target) {
    let left = 0;
    let right = price.length-1;
    while(left<right){
        const sum = price[left]+price[right];
        if(sum === target){
            return [price[left],price[right]]
        } else if(sum < target){
            left++;
        } else {
            right--;
        }
    }
    return null;
};
```

### [剑指offer57-II.和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)（滑动窗口）

[LCR 180. 文件组合](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 **正整数**（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 `target` 的所有文件。请返回所有符合该要求的文件传输组合列表。

**注意**，返回时需遵循以下规则：

- 每种组合按照文件编号 **升序** 排列；
- 不同组合按照第一个文件编号 **升序** 排列。

```js
var fileCombination = function(target) {    
  let left = 1, right = 1;  
  // 用于存储所有满足条件的数字组合  
  const ans = [];  
  
  // 当前数字组合的和  
  let window = 0;  
   
  while(left <= Math.floor(target / 2)){  
    // 如果当前数字组合的和小于目标值  
    if(window < target) {  
      // 将右指针指向的数字加到当前数字组合的和中  
      window += right;  
      // 右指针向右移动，准备下一个数字  
      right++;  
    }  
  
    // 如果当前数字组合的和大于目标值  
    if(window > target) {  
      // 从当前数字组合的和中减去左指针指向的数字  
      window -= left;  
      // 左指针向右移动，排除当前数字  
      left++;  
    }  
  
    // 如果当前数字组合的和等于目标值  
    if(window == target){  
      // 创建一个新数组，用于存储当前满足条件的数字组合  
      const arr = [];  
      // 从左指针到右指针之前的数字都加入这个新数组中  
      for(let i = left; i < right; i++) arr.push(i);  
      // 将这个满足条件的数字组合加入结果数组中  
      ans.push([...arr]);  
      // 从当前数字组合的和中减去左指针指向的数字  
      window -= left;  
      // 左指针向右移动，准备寻找下一个满足条件的数字组合  
      left++;  
    }  
  
  }  
  
  // 返回所有满足条件的数字组合  
  return ans;  
};
```

### [58-I 反转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)（双指针）

[LCR 181. 字符串中的单词反转](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

你在与一位习惯从右往左阅读的朋友发消息，他发出的文字顺序都与正常相反但单词内容正确，为了和他顺利交流你决定写一个转换程序，把他所发的消息 `message` 转换为正常语序。

注意：输入字符串 `message` 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

> 首先倒序遍历字符串s，记录单词左右索引边界i,j；每确定一个单词的边界（遇到空格），则将其添加到单词列表l中；最终，将单词列表拼接为字符串。

```js
var reverseMessage = function(s) {
    s = s.trim(); // 删除首尾空格
    let i = s.length - 1; // 指向字符串的最后一个字符
    let j = i;
    let words = []; // 用于存储反转后的单词

    while (i >= 0) {
        // 搜索首个空格
        while (i >= 0 && s[i] !== ' ') {
            i--;
        }
        // 将单词加入数组 字符串的 slice 方法提取子字符串的方式是含头不含尾
        words.push(s.slice(i + 1, j + 1)); 
        
        // 跳过单词间的空格
        while (i >= 0 && s[i] === ' ') {
            i--;
        }
        // 更新 j 为下一个单词的结尾
        j = i;
    }

    // 反转后的单词用单个空格连接
    return words.join(' ');
};
```

### [58-II 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

[LCR 182. 动态口令](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

某公司门禁密码使用动态口令技术。初始密码为字符串 `password`，密码更新均遵循以下步骤：

- 设定一个正整数目标值 `target`
- 将 `password` 前 `target` 个字符按原顺序移动至字符串末尾

请返回更新后的密码字符串。

```js
var dynamicPassword = function(password, target) {
    let ans="";
    // 从目标位置开始，遍历字符串的后半部分
    for(let i=target;i<password.length;i++){
        ans=ans+password[i];
    }
    // 从头开始，遍历目标位置之前的部分
    for(let i=0;i<target;i++){
        ans=ans+password[i];
    }
    return ans;
};
```

```js
var dynamicPassword = function(password, target) {
  password = password.split('');
  const s = password.splice(0, target);
  return password.concat(s).join('');
};
```



### （）[剑指offer59-I 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

[LCR 183. 望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

科技馆内有一台虚拟观景望远镜，它可以用来观测特定纬度地区的地形情况。该纬度的海拔数据记于数组 `heights` ，其中 `heights[i]` 表示对应位置的海拔高度。请找出并返回望远镜视野范围 `limit` 内，可以观测到的最高海拔值。

```js
function maxElevationWithinLimit(heights, limit) {
    const res = [];
    const deque = [];
    const len = heights.length;

    // 循环遍历整个 heights 数组
    for (let i = 0; i < len; i++) {
        // 确保 deque 中的索引对应的值构成从大到小的顺序
        // 如果队尾元素小于当前元素 heights[i]，就弹出队尾元素
        while (deque.length && heights[deque[deque.length - 1]] < heights[i]) {
            deque.pop();
        }
        // 将当前索引推入队尾
        deque.push(i);
        // 确保 deque 中的队头元素在当前滑动窗口的范围内
        // 如果队头元素的索引小于 i - limit + 1，表示它已超出滑动窗口，需移除
        while (deque.length && deque[0] < i - limit + 1) {
            deque.shift();
        }
        // 当滑动窗口完全形成（即 i >= limit - 1），记录当前窗口的最大海拔值
        if (i >= limit - 1) {
            res.push(heights[deque[0]]);
        }
    }

    // 返回存储滑动窗口最大海拔值的结果数组
    return res;
}
```

### [剑指offer61 扑克牌的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

[LCR 186. 文物朝代判断](https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

展览馆展出来自 13 个朝代的文物，每排展柜展出 5 个文物。某排文物的摆放情况记录于数组 `places`，其中 `places[i]` 表示处于第 `i` 位文物的所属朝代编号。其中，编号为 0 的朝代表示未知朝代。请判断并返回这排文物的所属朝代编号是否连续（如遇未知朝代可算作连续情况）。

> 先对数组执行排序，然后可通过遍历数组，判断 nums[i] = nums[i + 1] 是否成立来判别重复，最后排序后，数组末位元素 nums[len-1]为最大牌；元素 nums[joker]为最小牌，其中 joker为大小王的数量。

```js
var checkDynasty = function(places) {
    const len = places.length;
    let joker = 0; // 统计未知朝代的数量

    // 排序数组
    places.sort((a, b) => a - b);

    // 统计未知朝代的数量
    for (let i = 0; i < len; i++) {
        if (places[i] === 0) {
            joker++; // 未知朝代的数量
        } else if (i > 0 && places[i] === places[i - 1]) {
            // 如果有重复朝代编号，提前返回 false
            return false;
        }
    }

    // 计算最大编号和最小编号之间的差
    const minPlace = places[joker]; // 最小的非零编号
    const maxPlace = places[len - 1]; // 最大编号
    
    // 如果最大与最小的差小于 5，且数量合理，则判定为连续
    return maxPlace - minPlace < 5;
};
```

### [剑指offer64 求1+2+...+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

[LCR 189. 设计机械累加器](https://leetcode.cn/problems/qiu-12n-lcof/)

请设计一个机械累加器，计算从 1、2... 一直累加到目标数值 `target` 的总和。注意这是一个只能进行加法操作的程序，不具备乘除、if-else、switch-case、for 循环、while 循环，及条件判断语句等高级功能。

```js
var mechanicalAccumulator = function (target) {
  if (target === 1) return 1;
  return target + mechanicalAccumulator(target - 1);
};
```

### （）[剑指offer66 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

[LCR 191. 按规则计算统计结果](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)

为了深入了解这些生物群体的生态特征，你们进行了大量的实地观察和数据采集。数组 `arrayA` 记录了各个生物群体数量数据，其中 `arrayA[i]` 表示第 `i` 个生物群体的数量。请返回一个数组 `arrayB`，该数组为基于数组 `arrayA` 中的数据计算得出的结果，其中 `arrayB[i]` 表示将第 `i` 个生物群体的数量从总体中排除后的其他数量的乘积。

> 根据表格主对角线（全为1），可将表格分为上三角和下三角两部分。分别迭代计算下三角和上三角两部分的乘积。引入辅助变量res=1，首先算B[i]的下三角各元素的乘积，直接乘入B[i]，然后计算B[i]的上三角各元素的乘积，记为res，并乘入B[i]。

```js
var statisticalResult = function(arrayA) {
    var len = arrayA.length;
    var result = Array(n).fill(1); // 初始化结果数组
    var right = 1; // 初始化右边乘积

    // 计算左边的乘积
    for (var i = 1; i < len; i++) {
        result[i] = result[i - 1] * arrayA[i - 1]; // 累积左边的乘积
    }

    // 计算右边的乘积
    for (var i = len - 2; i >= 0; i--) {
        right *= arrayA[i + 1]; // 累积右边的乘积
        result[i] *= right; // 更新结果数组
    }

    return result;
};
```

### （）[剑指offer67.把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

[LCR 192. 把字符串转换成整数 (atoi)](https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 `0` 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被固定为 `−231` ，大于 `231 − 1` 的整数应该被固定为 `231 − 1` 。
6. 返回整数作为最终结果。

**注意：**

- 本题中的空白字符只包括空格字符 `' '` 。
- 除前导空格或数字后的其余字符串外，**请勿忽略** 任何其他字符。

> 解法：大数越界。考虑四种字符首部字符、符号位、非数字字符和数字字符。在数字越界处理方面，在每轮数字拼接前，判断res在拼接后是否超过2147483647，若超过则加上符号位直接返回。

```js
var myAtoi = function(str) {
    str = str.trim(); // 删除首尾空格
    if (!str) return 0; // 空字符串时返回 0
    
    let sign = 1; // 符号
    let i = 0; // 初始索引
    if (str[0] === '-') {
        sign = -1; // 设置负号
        i++; // 移动索引
    } else if (str[0] === '+') {
        i++; // 如果有正号，跳过
    }
    
    let res = 0; // 最终结果
    const intMax = 2 ** 31 - 1; // 最大值
    const intMin = -(2 ** 31); // 最小值
    const boundary = Math.floor(2 ** 31 / 10); // 溢出检测边界
    
    // 处理数字部分
    for (; i < str.length; i++) {
        const c = str[i];
        if (c < '0' || c > '9') break; // 如果遇到非数字字符，退出
        
        // 溢出检测
        if (res > boundary || (res === boundary && c > '7')) {
            return sign === 1 ? intMax : intMin;
        }
        
        // 计算当前结果
        res = res * 10 + (c.charCodeAt(0) - '0'.charCodeAt(0));
    }
    
    return sign * res; // 返回结果
};
```

## 03、链表

### [剑指offer06.从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

 [LCR 123. 图书整理 I](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。

> 递归（递归回溯的过程就是从尾到头遍历的过程）

```js
var reverseBookList = function(head) {
    let res = [];
    
    function dfs(node) {
        if (node === null) return;
        // 先递归后处理，确保在回溯阶段处理节点值，实现逆序遍历链表。
        dfs(node.next);  // 递归调用下一个节点
        res.push(node.val);  // 在递归返回后将当前节点的值添加到结果数组
    }
    
    dfs(head);  // 从头节点开始递归
    return res;
};
```

> 栈：将给定的链表反转，然后按顺序收集节点的值，最终以数组形式返回。

```js
var reverseBookList = function(head) {
    let res = null;
    let ans = [];

    // 反转链表
    while (head) {
      let tmp = head.next; // 保存下一个节点
      head.next = res; // 反转指向
      res = head; // 移动 `res` 指针
      head = tmp; // 移动 `head` 指针
    }

    // 将反转后的链表节点值存入数组
    while (res) {
      ans.push(res.val); // 将值加入数组
      res = res.next; // 移动到下一个节点
    }

    return ans; // 返回结果数组
};
```

```js
var reverseBookList = function(head) {
    let result = [];
    while (head !== null) {
        result.unshift(head.val); //将当前节点的值插入到数组 result 的开头
        head = head.next;
    }
    return result;
}
```

### [剑指offer18.删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

[LCR 136. 删除链表的节点](https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

> 遍历链表，寻找 `s.next` 的值是否等于 `val`。

```js
var deleteNode = function(head, val) {
    // 如果头节点的值等于 `val`，则直接返回下一个节点，删除头节点
    if (head.val === val) {
        return head.next; // 返回链表的第二个节点作为新的头
    }
    // 否则，初始化 `s` 为 `head`，用于遍历链表
    let s = head;
    // 遍历链表直到 `s.next` 为 `null`
    while (s.next !== null) {
        // 如果 `s.next` 的值等于 `val`，说明找到了要删除的节点
        if (s.next.val === val) {
            // 将 `s.next` 指向 `s.next.next`，跳过要删除的节点
            s.next = s.next.next;
            return head; // 返回更新后的链表头
        }
        // 否则，继续向下遍历链表
        s = s.next;
    }
};
```

### [剑指offer22.链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

[LCR 140. 训练计划 II](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

给定一个头节点为 `head` 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 `cnt` 个训练项目编号。

> 双指针

```js
// 双指针：先定义两个快慢指针指向头节点 先让快指针移动k步 然后快慢指针一起走 返回慢指针节点
var trainingPlan = function(head, k) {
    let fast = head;
    let slow = head;
    
    for (let i = 0; i < k; i++) {
        fast =fast.next;
    }

    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }
    
    return slow;
};
```

> 两次遍历数组：首先遍历整个链表，计算总节点数。基于总长度，计算从头部到倒数第k个节点所需的步数。再次遍历链表，移动预定的步数，最终得到倒数第k个节点。

```js
var trainingPlan = function(head, cnt) {
    let total = 0
    let origin = head
    let index = 0
    
    while(head){
        total++
        head = head.next
    }

    while(origin && index < (total - cnt)){
        origin = origin.next
        index++
    }
    return origin
};
```

### [剑指offer24.反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

[LCR 141. 训练计划 III](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

给定一个头节点为 `head` 的单链表用于记录一系列核心肌群训练编号，请将该系列训练编号 **倒序** 记录于链表并返回。

> 整个过程可以用三个指针来实现：`prev`（前一个节点）、`current`（当前节点）、`nextTemp`（下一个节点）。迭代反转：在每一步中，先将 `current.next` 保存到 `nextTemp`，确保不会丢失对后续节点的引用。将 `current.next` 指向 `prev`，实现当前节点的反转。移动 `prev` 指向 `current`，以更新反转后的链表尾部。移动 `current` 指向 `nextTemp`，继续处理下一个节点。

```js
var trainningPlan = function (head) {
    if(!head || !head.next) return head;
    var prev = null;
    while (head) {
        const nextTemp = head.next; // 因为后面要改变节点head.next的指向 先用temp指针保存一下
        head.next = prev; // 指向null
        prev = head; // prev向后移 更新prev为节点head
        head = nextTemp; // head向后移 更新head为节点head.next
    }
    return prev;
};
```

### [剑指offer25.合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

[LCR 142. 训练计划 IV](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

给定两个以 **有序链表** 形式记录的训练计划 `l1`、`l2`，分别记录了两套核心肌群训练项目编号，请合并这两个训练计划，按训练项目编号 **升序** 记录于链表并返回。

**注意**：新链表是通过拼接给定的两个链表的所有节点组成的。

> 递归

```js
var trainningPlan = function(l1, l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1.val < l2.val) {
        l1.next = trainningPlan(l1.next, l2);
        return l1;
    } else {
        l2.next = trainningPlan(l1, l2.next);
        return l2;
    }
};
```

> 迭代

```js
var trainningPlan = function(l1, l2) {
    const dummyNode = new ListNode(0);
    var curNode = dummyNode;
    while (l1 != null && l2 != null) {
        // 如果 l1.val 小于或等于 l2.val，将 l1 连接到新链表，并将 l1 指针移动到下一个节点；
        if (l1.val <= l2.val) {
            curNode.next = l1;
            l1 = l1.next;
        } else {
            curNode.next = l2;
            l2 = l2.next;
        }
        // 让 curNode 指向新链表的末端，以确保后续的节点可以正确连接
        curNode = curNode.next
    }
    // 如果 l1 到达末尾，链表1已经全部合并完毕，此时将 l2 剩余部分连接到 curNode.next
    if (l1 == null) curNode.next = l2;
    if (l2 == null) curNode.next = l1;

    return dummyNode.next;
};
```

### （）[剑指offer35.复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

[LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

> 解法：拼接+拆分。考虑构建原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。

```js
var copyRandomList = function(head) {
     if (!head) {
      return null; // 如果头节点为空，返回 null
    }

    let cur = head;

    // 1. 复制各节点，并构建拼接链表
    while (cur) {
      const tmp = new Node(cur.val); // 创建新节点
      tmp.next = cur.next; // 将新节点的下一个指针指向当前节点的下一个
      cur.next = tmp; // 将当前节点的下一个指针指向新节点
      cur = tmp.next; // 移动到下一个原始节点
    }

    // 2. 构建各新节点的 random 指向
    cur = head; // 从头节点开始
    while (cur) {
      if (cur.random) {
        cur.next.random = cur.random.next; // 设置新节点的随机指针
      }
      cur = cur.next.next; // 跳过一个节点，继续构建 random 指向
    }

    // 3. 拆分两个链表
    cur = head.next; // 新链表的头
    let res = cur; // 记录新链表的起始节点
    let pre = head; // 旧链表的节点

    while (cur.next) {
      pre.next = pre.next.next; // 更新旧链表的 next 指针
      cur.next = cur.next.next; // 更新新链表的 next 指针
      pre = pre.next; // 移动到下一个旧链表节点
      cur = cur.next; // 移动到下一个新链表节点
    }

    pre.next = null; // 断开旧链表的最后一个节点
    return res; // 返回新链表的头节点
  }
```

```js
var copyRandomList = function(head) {
    if(!head) return head
    let node = head
    let map = new Map()
    // 遍历链表，创建新节点，并存入 Map 中
    while(node) {
        map.set(node, new Node(node.val)) // 原节点作为键，新节点作为值
        node = node.next
    }
    // 设置新节点的 next 和 random 指针
    node = head; // 重置 node 为原链表的头
    while(node) {
        // 复制节点 map.get(node) 的 next 指针指向 node.next 节点对应的复制节点
        map.get(node).next = map.get(node.next) || null
        map.get(node).random = map.get(node.random)
        node = node.next
    }
    return map.get(head)
};
```

### [剑指offer52.两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

[LCR 171. 训练计划 V](https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

某教练同时带教两位学员，分别以链表 `l1`、`l2` 记录了两套核心肌群训练计划，节点值为训练项目编号。两套计划仅有前半部分热身项目不同，后续正式训练项目相同。请设计一个程序找出并返回第一个正式训练项目编号。如果两个链表不存在相交节点，返回 `null` 。

> 如果两个链表有交点，当两个指针循环两遍之后，将在相交点相遇。

```js
var getIntersectionNode = function(headA, headB) {
    if(headA == null || headB == null) return null
    let pA = headA
    let pB = headB
    // 继续循环直到两个指针相等
    while(pA != pB){
        // 如果pA到达链表A的末尾，将其重置为链表B的头部
        pA = pA == null ? headB : pA.next
        pB = pB == null ? headA : pB.next
    }
    // 当 pA 和 pB 相等时，即找到相交节点，返回该节点
    return pA
};
```

## 04、栈与队列

### [剑指offer09.两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

[LCR 125. 图书整理 II](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：

- `push(bookID)`：把借阅的书籍还到图书馆。
- `pop()`：从图书馆中借出书籍。

为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 **最早** 归还到图书馆的书籍。你需要返回 **每次读者借出书的值** 。

如果没有归还的书可以取出，返回 `-1` 。

```js
var CQueue = function() {
    this.inCar = []; // 用于存放还书的书车
    this.outCar = []; // 用于存放借书的书车
};

CQueue.prototype.appendTail = function(value) {
    this.inCar.push(value)
};

CQueue.prototype.deleteHead = function() {
    // 如果借书的书车为空，且还书的书车也为空，则返回 -1
    if(this.outCar.length == 0){
        if (this.inCar.length == 0) {
            return -1;
        }
        // 如果借书的书车为空，则将还书的书车中的书籍全部移到借书的书车中
        while (this.inCar.length != 0) {
            this.outCar.push(this.inCar.pop());
        }
    }
    // 从借书的书车中取出书籍并返回
    return this.outCar.pop();
};
```

### [剑指offer30.包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

[LCR 147. 最小栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/)

请你设计一个 **最小栈** 。它提供 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

```js
var MinStack = function() {
  this.mainStack = []; // 用于存储所有元素
  this.minStack = [];  // 用于追踪最小值
};

/** 
 * 将元素 x 推入栈
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
  // 将元素推入主栈
  this.mainStack.push(x);

  // 如果最小栈为空，或者当前元素小于等于最小栈的顶端元素，则将它推入最小栈
  if (this.minStack.length === 0 || x <= this.minStack[this.minStack.length - 1]) {
    this.minStack.push(x);
  }
};

/**
 * 弹出栈顶元素
 * @return {void}
 */
MinStack.prototype.pop = function() {
  if (this.mainStack.length === 0) {
    return; // 栈为空时不操作
  }

  // 弹出主栈的顶部元素
  const popped = this.mainStack.pop();

  // 如果弹出的元素是当前最小值，最小栈也需要弹出对应元素
  if (popped === this.minStack[this.minStack.length - 1]) {
    this.minStack.pop();
  }
};

/**
 * 返回栈顶元素
 * @return {number}
 */
MinStack.prototype.top = function() {
  if (this.mainStack.length === 0) {
    throw new Error("Stack is empty"); // 栈为空时抛出错误
  }
  return this.mainStack[this.mainStack.length - 1];
};

/**
 * 返回最小值
 * @return {number}
 */
MinStack.prototype.getMin = function() {
  if (this.minStack.length === 0) {
    throw new Error("Stack is empty"); // 栈为空时抛出错误
  }
  return this.minStack[this.minStack.length - 1];
};
```

### [剑指offer31.栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

[LCR 148. 验证图书取出顺序](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

现在图书馆有一堆图书需要放入书架，并且图书馆的书架是一种特殊的数据结构，只能按照 **一定** 的顺序 **放入** 和 **拿取** 书籍。给定一个表示图书放入顺序的整数序列 `pushed`，请判断序列 `popped` 是否为按照正确的顺序拿取书籍的操作序列。你可以假设放入书架的所有书籍编号都不相同。

（输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序）

> 栈的弹入与弹出：入栈操作：按照压栈序列的顺序执行；出栈操作：每次入栈后，循环判断【栈顶元素=弹出序列的当前元素】是否成立，将符合弹出序列顺序的栈顶元素全部弹出并i+=1。

```js
var validateBookSequences = function(pushed, popped) {
    let stack = [];  // 用于模拟堆栈操作的数组
    let i = 0;  // 追踪弹出数组(popped)的索引

    // 遍历推入数组(pushed)的每个元素
    for (const num of pushed) {
        stack.push(num);  // 将当前元素压入堆栈
        // 当堆栈不为空，并且堆栈的顶部元素与弹出数组(popped)当前索引的元素相同时
        while (stack.length && stack[stack.length - 1] === popped[i]) {
            stack.pop();  // 弹出堆栈的顶部元素
            i++;  // 移动弹出数组(popped)的索引
        }
    }

    // 如果堆栈为空，并且已处理完所有弹出数组(popped)的元素，说明验证通过
    return stack.length === 0 && i === popped.length;
};
```

### [剑指offer59-II.队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

[LCR 184. 设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

请设计一个自助结账系统，该系统需要通过一个队列来模拟顾客通过购物车的结算过程，需要实现的功能有：

- `get_max()`：获取结算商品中的最高价格，如果队列为空，则返回 -1
- `add(value)`：将价格为 `value` 的商品加入待结算商品队列的尾部
- `remove()`：移除第一个待结算的商品价格，如果队列为空，则返回 -1

注意，为保证该系统运转高效性，以上函数的均摊时间复杂度均为 O(1)

```js
var Checkout = function() {
    // 使用两个数组，主队列和最大值队列
    this.queue = []; // 存储待结算商品
    this.maxQueue = []; // 维护当前商品中的最大值
};

/**
 * 获取当前队列中的最大值
 * @return {number}
 */
Checkout.prototype.get_max = function() {
    // 如果最大值队列为空，表示主队列也是空的，返回 -1
    if (this.maxQueue.length === 0) {
        return -1;
    }
    // 最大值始终在辅助队列的队首
    return this.maxQueue[0];
};

/** 
 * 添加新商品到队列
 * @param {number} value
 * @return {void}
 */
Checkout.prototype.add = function(value) {
    // 将商品价格添加到队列末尾
    this.queue.push(value);
    
    // 在最大值队列中保持单调递减
    while (this.maxQueue.length > 0 && this.maxQueue[this.maxQueue.length - 1] < value) {
        this.maxQueue.pop(); // 弹出比新值小的元素
    }
    // 插入新值
    this.maxQueue.push(value);
};

/**
 * 移除队列头部的商品
 * @return {number}
 */
Checkout.prototype.remove = function() {
    if (this.queue.length === 0) {
        return -1; // 如果主队列为空，返回 -1
    }
    // 移除队列头部的元素
    const removedValue = this.queue.shift();
    
    // 如果这个值是最大值队列的队首，则从最大值队列中移除
    if (removedValue === this.maxQueue[0]) {
        this.maxQueue.shift();
    }
    
    return removedValue; // 返回被移除的商品价格
};
```

## 05、树

### （1）[剑指offer07.重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)（先序+中序）

[LCR 124. 推理二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)

某二叉树的先序遍历结果记录于整数数组 `preorder`，它的中序遍历结果记录于整数数组 `inorder`。请根据 `preorder` 和 `inorder` 的提示构造出这棵二叉树并返回其根节点。

 注意：`preorder` 和 `inorder` 中均不含重复数字。

> 根据前序和中序可以构造一颗二叉树，根据中序和后续也可以构建一颗二叉树。 反正必须要有中序才能构建，因为没有中序，你没办法确定树的形状。 比如先序和后序是不能构建唯一的一颗二叉树的。

> （先序+中序）：该方法主要利用前序遍历的第一个元素作为根节点，并根据根节点在中序遍历中的位置来划分左、右子树，然后递归地构建这些子树。

```js
var deduceTree = function(preorder, inorder) {
    if(preorder.length===0 ||inorder.length===0) return null
    let root=new TreeNode(preorder[0]) // 使用前序列表的第一个元素作为根节点
    let index=inorder.indexOf(root.val) // 在中序列表中找到根节点的位置，用于划分左右子树
    root.left=deduceTree(
        preorder.slice(1,index+1), 
        // 从前序数组的第二个元素开始（索引 1），到根节点在中序数组中的位置结束（索引 index + 1）
        inorder.slice(0,index)) // 从中序数组的第一个元素到根节点位置之前的所有元素
    // 从根节点位置之后的所有元素
    root.right=deduceTree(preorder.slice(index+1),inorder.slice(index+1))
    return root
};
```

> 中序+后序

```js
var buildTree = function(inorder, postorder) {
    if(postorder.length===0 ||inorder.length===0) return null
    let root=new TreeNode(postorder[postorder.length - 1]) // 使用后序的最后一个元素作为根节点
    let index=inorder.indexOf(root.val) // 在中序列表中找到根节点的位置，用于划分左右子树
    // 从第一个元素到根节点位置之前的所有元素
    root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
    root.right = buildTree(
        inorder.slice(index + 1), // 获取中序遍历数组从根节点位置之后的所有元素
        postorder.slice(index, postorder.length - 1));
    	// 后序遍历数组从左子树部分结束位置到倒数第二个元素（去掉最后一个根节点元素）
    return root
};
```

> 先序+后序：确定根节点，然后前序遍历第二个元素是左子树的根节点（如果存在），找到左子树根节点在后序遍历中的位置，从而确定左右子树的范围。

```js
var constructFromPrePost = function(preorder, postorder) {
    if (!preorder.length || !postorder.length) return null;
    let root = new TreeNode(preorder[0]);
    if (preorder.length === 1) return root;
    let lroot = preorder[1];
    let lrindex = postorder.indexOf(lroot); // 在后序遍历中找到左子树根节点的位置

    root.left = constructFromPrePost(
    	preorder.slice(1, lrindex + 2), 
    	// 从第一个元素（左子树根节点）到从左子树结束后的下一个元素
    	postorder.slice(0, lrindex + 1));   // 从第一个元素到左子树结束
    root.right = constructFromPrePost(
        preorder.slice(lrindex +1 + 1), // 前序 从左子树结束后的下一个元素开始到数组结束
        postorder.slice(lrindex +1, postorder.length - 1)); 
    	// 后序 从左子树结束到数组倒数第二个元素（不包含根节点）
    
    return root;
};
```

### （2）[剑指offer26.树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

[LCR 143. 子结构判断](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/)

给定两棵二叉树 `tree1` 和 `tree2`，判断 `tree2` 是否以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。注意，**空树** 不会是以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。

```js
// 从某个具体的节点开始 判断 A 是否包含与 B 结构和节点值相同的子树
var judge =function (A,B){
    if(!B) return true
    if(A==null) return false
    // 根节点的值相等&&遍历左子树的值相等&&遍历右子树的值相等
    return A.val==B.val&&judge(A.left,B.left)&&judge(A.right,B.right)
}
var isSubStructure = function(A, B) {
    if(!B||!A) return false
    // 检查以当前节点 A 为起点是否包含 B，或者检查 A 的左子树和右子树是否包含 B
    return judge(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B)
};
```

### （3）剑指offer27.二叉树的镜像

[LCR 144. 翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

给定一棵二叉树的根节点 `root`，请左右翻转这棵二叉树，并返回其根节点。

> 递归

```js
var mirrorTree = function(root) {
    if(!root) return null;
    [root.left, root.right] = [mirrorTree(root.right), mirrorTree(root.left)];
    return root
};
```

> 迭代

```js
var mirrorTree = function (root) {
    if(!root) return root;
    let stack = [root];
    while (stack.length) {
        let node = stack.pop();
        [node.left, node.right] = [node.right, node.left];
        if (node.left) stack.push(node.left);
        if (node.right) stack.push(node.right);
    }
    return root;
};
```

### （4）剑指offer28.对称的二叉树。

[LCR 145. 判断对称二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)

请设计一个函数判断一棵二叉树是否 **轴对称**。

> 解法：后序遍历。过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

```js
var checkSymmetricTree = function(root) {
  // 空树是对称的
  if (!root) return true;
  function isMirror(left, right) {
    if (!left && !right) return true; // 两者都是空，说明是对称的
    if (!left || !right) return false; // 一个为空，另一个不为空，不对称
    if (left.val !== right.val) return false; // 节点值不相等，不对称
    // 递归比较左子树的左侧和右子树的右侧，以及左子树的右侧和右子树的左侧
    return isMirror(left.left, right.right) && isMirror(left.right, right.left);
  }
  // 比较根节点的左子树和右子树是否对称
  return isMirror(root.left, root.right);
};
```

### （5）剑指offer32-I.从上到下打印二叉树（层序遍历）

[LCR 149. 彩灯装饰记录 I](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

一棵圣诞树记作根节点为 `root` 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从 **左** 到 **右** 的顺序返回每一层彩灯编号。

> 首先进行非空判断，然后初始化结果数组和队列，接着按层次顺序遍历二叉树的所有节点，逐层将每个节点的值添加到结果数组 `res` 中，并将左右子节点作为下一层的节点添加到 `next` 数组中，再更新 `queue` 为 `next` 以进行下一层的遍历。

```js
var decorateRecord = function(root) {
    if(!root) return [];
    let res = []; // 结果数组
    let queue = [root]; // 队列
    
    while (queue.length > 0) {
        let next = [];
        for (let node of queue) {
            res.push(node.val); // 将当前节点的值添加到结果数组res中
            if (node.left) next.push(node.left); // 如果左子节点存在，将其添加到next
            if (node.right) next.push(node.right);
        }
        queue = next;// 将queue更新到下一层
    }
    return res; 
};
```

### （6）剑指offer32-II.从上到下打印二叉树（层次遍历&分层记录节点）

[LCR 150. 彩灯装饰记录 II](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

一棵圣诞树记作根节点为 `root` 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从左到右的顺序返回每一层彩灯编号，每一层的结果记录于一行。

```js
var decorateRecord = function(root) {
    if (!root) return [];
    let res = []; // 结果数组
    let queue = [root]; // 队列
    
    while (queue.length > 0) {
        let next = [];
        let level = []; // 存储当前层节点值的数组
        for (let node of queue) {
            level.push(node.val); // 将当前节点的值添加到当前层数组level中
            if (node.left) next.push(node.left); // 如果左子节点存在，将其添加到next
            if (node.right) next.push(node.right);
        }
        res.push(level); // 将当前层数组level添加到结果数组res中
        queue = next; // 将queue更新到下一层
    }
    return res; 
};
```

### （7）剑指offer32-III.从上到下打印二叉树（层次遍历&分层记录节点&偶数层反转）

[LCR 151. 彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

一棵圣诞树记作根节点为 `root` 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照如下规则记录彩灯装饰结果：

- 第一层按照从左到右的顺序记录
- 除第一层外每一层的记录顺序均与上一层相反。即第一层为从左到右，第二层为从右到左。

```js
var decorateRecord = function(root) {
    if (!root) return [];
    let res = []; // 结果数组
    let queue = [root]; // 队列
    let depth = 0; // 层次深度

    while (queue.length > 0) {
        let next = [];
        let level = []; // 存储当前层节点值的数组
        depth += 1;
        for (let node of queue) {
            if (depth % 2 === 0) {
                // 偶数层将节点值插入到数组开头
                level.unshift(node.val);
            } else {
                // 奇数层将节点值插入到数组末尾
                level.push(node.val);
            }
            if (node.left) next.push(node.left); // 如果左子节点存在，将其添加到next
            if (node.right) next.push(node.right);
        }
        res.push(level); // 将当前层数组level添加到结果数组res中
        queue = next; // 将queue更新到下一层
    }
    return res; 
};
/*        if (depth % 2 === 0) { // 偶数层反转
            level.reverse();
}
*/
```

### （8）剑指offer33.二叉搜索树的后序遍历序列

[LCR 152. 验证二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

请实现一个函数来判断整数数组 `postorder` 是否为二叉搜索树的后序遍历结果。

> 在二叉搜索树中，左子树的元素必小于根，右子树的元素必大于根。根节点：后序遍历序列的最后一个节点，右子树起点：从头开始遍历知道第一个比根节点大的元素。

```js
const verifyTreeOrder = function (postorder) {
    if (postorder.length <= 2) return true; // 只有根节点或根节点加上左右一个子节点，则默认是有效的二叉搜索树
    const root = postorder.pop(); // 后序遍历数组的最后一个元素是当前树的根节点
    
    // 从左到右找到第一个大于根节点的元素，右子树的起始点
    let index = 0;
    while (index < postorder.length && postorder[index] < root) {
        index += 1; 
    }
    
    // 分割出左子树和右子树
    const leftTree = postorder.slice(0, index); 
    const rightTree = postorder.slice(index);
    
    // 检查右子树中的所有元素是否都大于根节点
    const isRightTreeValid = rightTree.every(item => item > root); 
    // 递归验证左子树和右子树，只有当左右子树都有效且右子树的所有值都大于根节点时，整个树才是有效的
    return isRightTreeValid && verifyTreeOrder(leftTree) && verifyTreeOrder(rightTree); 
};
```

```js
// 递归：首先非空判断， 然后定义一个递归函数来对每个子数组进行验证，递归函数需要首先找到根节点（最后一个元素）和右子树起点（第一个大于根节点的），然后验证左右子树，最后整个数组再调用递归函数。
var verifyTreeOrder = function(postorder) {
    if (postorder.length === 0) return true;
 
    const verify = (left, right) => {
        if (left >= right) return true;
        const root = postorder[right]; // 后序遍历数组的最后一个元素是当前树的根节点
        
        let index = left; // 从左到右找到第一个大于根节点的元素，这个索引是右子树的开始
        while (postorder[index] < root) index++;

        // 检查右子树的所有节点是否都大于根节点
        let rightIndex = index;
        while (rightIndex < right) {
            if (postorder[rightIndex] < root) {
                return false;
            }
            rightIndex++;
        }
        
        return verify(left, index - 1) && verify(index, right - 1); 
    };
    return verify(0, postorder.length - 1);
};
```

### （9）剑指offer34.二叉树中和为某一值的路径

[LCR 153. 二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。**叶子节点** 是指没有子节点的节点。

> 解法：回溯法，包含先序遍历+路径记录两部分。

```js
// 首先定义一个空的结果数组和递归函数dfs，遍历树的所有节点，将当前节点加入结果数组cur.push(node.val)，如果当前节点是叶子节点，并且路径和等于目标值，res.push([...cur])将当前路径加入结果数组，如果当前节点有左右子节点，递归调用 dfs 处理子节点，然后在返回上一层递归之前，从路径数组cur中移除当前节点的值cur.pop()，以便处理其他路径。
var pathTarget = function(root, target) {
    const res = [];  
    const dfs = (node, cur) => {
        if (!node) return;
        cur.push(node.val);
        // 如果当前节点是叶子节点，并且路径和等于目标值：
        if (!node.left && !node.right) {
            // 使用reduce方法计算当前路径cur中所有节点值的总和 初始值为0
            if (cur.reduce((sum, val) => sum + val, 0) === target) {
                res.push([...cur]);
            }
        }
        if (node.left) dfs(node.left, cur);
        if (node.right) dfs(node.right, cur);
        cur.pop(); // 回溯：移除当前节点的值，以便处理其他路径
    };
    dfs(root, []); // 从根节点开始递归，初始路径为空
    return res;
};
```

```js
var pathTarget = function(root, target) {
    const res = []; // 用于存储所有满足条件的路径
    const temp = []; // 用于存储当前路径
    // 定义一个递归函数
    function recur(node, tempRes) {
        if (!node) return; // 如果当前节点为空，则直接返回
        
        // 添加当前节点的值到当前路径
        temp.push(node.val);
        tempRes += node.val; // 更新当前路径的和
        
        // 如果当前路径和等于目标，并且是叶子节点，则将路径加入结果
        if (tempRes === target && !node.left && !node.right) {
            res.push([...temp]); // 将当前路径复制到结果中
        }

        // 递归处理左子节点
        recur(node.left, tempRes);
        // 递归处理右子节点
        recur(node.right, tempRes);
        // 回溯：在递归结束后，移除当前节点的值，以恢复到之前的状态
        temp.pop();
    }
    // 从根节点开始递归
    recur(root, 0);
    // 返回所有满足条件的路径
    return res;
};
```

### （10）剑指offer36.二叉搜索树与双向链表

[LCR 155. 将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

> 解法：中序遍历 双向 循环（*中序遍历二叉排序树 = 遍历有序数组*）

```js
var treeToDoublyList = function(root) {
    if (!root)     return null;
    // 前置变量，用于构建双向链表
    let head = null; // 将是链表的头节点
    let pre = null; // 用于保存上一个处理的节点
    
    // 定义递归的中序遍历函数 左-根-右
    const dfs = function(cur) {
        if (!cur) return; // 当当前节点为空时，直接返回
        dfs(cur.left); // 递归左子树
        
        if (pre) {
            pre.right = cur; // 前一个节点的右指针指向当前节点
            cur.left = pre;  // 当前节点的左指针指向前一个节点 建立双向连接
        } else {
            // 如果没有前一个节点，说明这是第一个节点，将其设置为头节点
            head = cur;
        }
        
        pre = cur; // 更新前一个节点为当前节点
        dfs(cur.right); // 递归右子树
    };
    // 从根节点开始进行中序遍历
    dfs(root);
    // 将头节点和最后一个节点连接起来，形成循环双向链表
    head.left = pre; 
    pre.right = head; 

    return head;
};
```

### （11）剑指offer37.序列化二叉树

[LCR 156. 序列化与反序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

> 解法：DFS深度优先搜素。

```js
// 遍历每一个节点 如果是空节点就添加none 否则result.push(String(node.val)) 递归左右子树  然后从头开始序列化 并以逗号连接
var serialize = function(root) {
    // 序列化一个二叉树为字符串
    const result = [];
    function dfs(node) {
        if (!node) { // 如果节点为空
            result.push("None"); // 添加 "None" 表示空节点
            return;
        }
        result.push(String(node.val));
        dfs(node.left); // 递归左子树
        dfs(node.right); // 递归右子树
    };
    dfs(root); // 从根节点开始序列化
    return result.join(','); // 返回序列化的字符串
};
// 先将字符串分割成数组 然后定义递归函数构建二叉树 每一个元素index 如果是none就返回null 否则创建节点new TreeNode(parseInt(dataList[index], 10)) 然后构建左右子树 最后调用
var deserialize = function(data) {
    // 从字符串反序列化为二叉树
    const dataList = data.split(','); // 将字符串分割为数组
    let index = 0;
    function dfs() {
        if (dataList[index] === "None") { // 如果当前元素是 "None"
            index++;
            return null; // 返回 null 作为空节点
        }
        const node = new TreeNode(parseInt(dataList[index], 10));// 创建节点（转换为十进制整数
        index++; // 移动到下一个元素
        node.left = dfs(); // 构建左子树
        node.right = dfs(); // 构建右子树
        return node;
    };
    return dfs(); // 从第一个元素开始反序列化
};
```

### （12）剑指offer54.二叉搜索树的第k大节点

[LCR 174. 寻找二叉搜索树中的目标节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

某公司组织架构以二叉搜索树形式记录，节点值为处于该职位的员工编号。请返回第 `cnt` 大的员工编号。

> 二叉搜索树，中序遍历，得到的是递增序列。

```js
var findTargetNode = function(root, cnt) {
    let arr = [];
    // 中序遍历
    function inorder(root) {
        if (!root) return;
        inorder(root.left);
        arr.push(root.val);
        inorder(root.right);
    };
    inorder(root);
    return arr[arr.length - cnt];
};
```

### （13）剑指offer55-I.二叉树的深度

[LCR 175. 计算二叉树的深度](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

某公司架构以二叉树形式记录，请返回该公司的层级数。

```js
var calculateDepth = function(root) {
    // 如果根节点为空，返回深度 0
    if (!root) {
        return 0;
    }
    // 递归计算左右子树的深度
    const leftDepth = calculateDepth(root.left);
    const rightDepth = calculateDepth(root.right);
    // 返回左右子树深度的较大值加上当前节点层级 1
    return Math.max(leftDepth, rightDepth) + 1;
};
```

### （14）剑指offer55-II.平衡二叉树（后序遍历）

[LCR 176. 判断是否为平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

> 解法：后序遍历。
>
> 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数；
>
> 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

```js
var isBalanced = function(root) {
    function getDepth(node) {
        if(!node) return 0;
        const leftDepth = getDepth(node.left);
        const rightDepth = getDepth(node.right);
        return Math.max(leftDepth, rightDepth) + 1;        
    }
    // 判断是否为空树或者只有一个节点的树
    if (!root || (!root.left && !root.right)) return true;
    // 判断左右子树的深度差是否大于 1
    if (Math.abs(getDepth(root.left) - getDepth(root.right)) > 1) return false;
    // 递归判断左右子树是否平衡
    return isBalanced(root.left) && isBalanced(root.right);
};
```

### （15）剑指offer68-I.二叉搜索树的最近公共祖先

[LCR 193. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

> 对于二叉搜索树中的每个节点，其左子树的所有节点值都小于该节点的值，而其右子树的所有节点值都大于该节点的值。

```js
var lowestCommonAncestor = function(root, p, q) {
    if (!root) return null;
    // 如果根节点的值大于两个节点的值，说明最近公共祖先在根节点的左子树上
    if (root.val > p.val && root.val > q.val) {
        // 递归调用左子树，寻找最近公共祖先
        return lowestCommonAncestor(root.left, p, q);
    // 如果根节点的值小于两个节点的值，说明最近公共祖先在根节点的右子树上
    } else if (root.val < p.val && root.val < q.val) {
        // 递归调用右子树，寻找最近公共祖先
        return lowestCommonAncestor(root.right, p, q);
    } else {
        return root;
    }
};
```

### （16）剑指offer68-II.二叉树的最近公共祖先

[LCR 194. 二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```js
var lowestCommonAncestor = function(root, p, q) {
    if(!root) return null;
    if(root === p || root === q) return root;
    const left = lowestCommonAncestor(root.left, p, q);// 递归查找左子树
    const right = lowestCommonAncestor(root.right, p, q);// 递归查找右子树
    if(left && right) return root;
    if(left) return left;
    if(right) return right;
};
```

## 06、位运算

### （1）剑指offer15.二进制中1的个数

[LCR 133. 位 1 的个数](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 [汉明重量](http://en.wikipedia.org/wiki/Hamming_weight)）。

> 解法：十进制转二进制。首先将十进制数字转化为二进制数，然后在二进制数中查找字符'1'。

```js
var hammingWeight = function(n) {
  const binary = n.toString(2); // 将整数转为二进制字符串
  let count = 0;
  for (let char of binary) { // 遍历二进制字符串
    if (char === '1') {
      count += 1;
    }
  }
  return count;
};
```

```js
var hammingWeight = function(n) {
    let res=0
    while(n!=0){
        n=n& (n-1) // 'n & (n - 1)' 会将 'n' 的最右侧的 '1' 置零，其余位不变
        res++; // 记录一次操作，表示移除了一个 '1'
    }
    return res
};
```

### （2）剑指offer16.数值的整数次方

[LCR 134. Pow(x, n)](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，xn）。

> 正数、负数、奇数、偶数。

```js
var myPow = function(x, n) {
    if (n === 0) return 1;
    if (n === 1) return x;
    if (n === -1) return 1 / x;
    if (n % 2 === 0) { // 如果 n 是偶数
        const a = myPow(x, n / 2);
        return a * a;
    } else {
        const a = myPow(x, (n - 1) / 2);
        return a * a * x; 
    }
};
```

> 解法：快速幂。

```js
var myPow = function(x, n) {
    // 处理负指数的情况
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }
    let res = 1;
    // 通过循环将指数 n 逐步减半，并且每次将底数 x 进行平方操作，这样可以得到下一次计算的底数。同时判断指数是否为奇数，若为奇数则将当前的底数乘到结果中。最终得到的结果就是底数 x 的指数幂。
    while (n > 0) {
        if (n % 2 === 1) {
            res *= x;
        }
        x *= x;
        n = Math.floor(n / 2);
    }
    return res;
};
```

### （3）剑指offer56-I.数组中数字出现的次数

[LCR 177. 撞色搭配](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

整数数组 `sockets` 记录了一个袜子礼盒的颜色分布情况，其中 `sockets[i]` 表示该袜子的颜色编号。礼盒中除了一款撞色搭配的袜子，每种颜色的袜子均有两只。请设计一个程序，在时间复杂度 O(n)，空间复杂度O(1) 内找到这双撞色搭配袜子的两个颜色编号。

```js
var sockCollocation = function(sockets) {
    let set = new Set()
    sockets.forEach(e => {
        if (set.has(e)) {
            set.delete(e)
        } else {
            set.add(e)
        }
    })
    return Array.from(set) // 将集合转为数组并返回
};
```

### （4）剑指offer56-II.数组中数字出现的次数

[LCR 178. 训练计划 VI](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

教学过程中，教练示范一次，学员跟做三次。该过程被混乱剪辑后，记录于数组 `actions`，其中 `actions[i]` 表示做出该动作的人员编号。请返回教练的编号。

```js
var trainingPlan = function(nums) {
    const map = new Map();
    	// 统计
        for (let num of nums) {
            if (map.has(num)) map.set(num, map.get(num) + 1);
            else map.set(num, 1);
        }
    	// 遍历
        for (let [num, times] of map.entries()) {
            if (times === 1) return num;
        }
};
```

### （5）剑指offer65.不用加减乘除做加法

[LCR 190. 加密运算](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

计算机安全专家正在开发一款高度安全的加密通信软件，需要在进行数据传输时对数据进行加密和解密操作。假定 `dataA` 和 `dataB` 分别为随机抽样的两次通信的数据量：

- 正数为发送量
- 负数为接受量
- 0 为数据遗失

请不使用四则运算符的情况下实现一个函数计算两次通信的数据量之和（三种情况均需被统计），以确保在数据传输过程中的高安全性和保密性。

> 解法：位运算中的无进位和与异或，进位和与运算规律相同。

```js
var encryptionCalculate = function(a, b) {
    a = a & 0xFFFFFFFF; // 确保将数字转换为32位整数
    b = b & 0xFFFFFFFF;
    while (b !== 0) {
        const carry = a & b; // 计算进位（与运算）
        a = a ^ b; // 计算非进位和（异或运算）
        b = (carry << 1) & 0xFFFFFFFF; // 计算新的进位，进行左移
    }
    return a ;
};
```

## 07、动态规划

### （1）剑指offer10-I.斐波那契数列

[LCR 126. 斐波那契数](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

```js
var fib = function(n) {
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
    }
    return dp[n];
}
```

### （2）剑指offer10-II.青蛙跳台阶问题

[LCR 127. 跳跃训练](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

今天的有氧运动训练内容是在一个长条形的平台上跳跃。平台有 `num` 个小格子，每次可以选择跳 **一个格子** 或者 **两个格子**。请返回在训练过程中，学员们共有多少种不同的跳跃方式。

结果可能过大，因此结果需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1

> 解法：动态规划。跳上n 级台阶有 f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况：跳上1级或2级台阶，即 f(n)=f(n-1)+f(n-2)。 

```js
var trainWays = function(num) {
    let dp = [1, 1];
    for (let i = 2; i <= num; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
    }
    return dp[num];
};
```

### 【】（3）剑指offer19.正则表达式匹配

[LCR 137. 模糊搜索验证](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

请设计一个程序来支持用户在文本编辑器中的模糊搜索功能。用户输入内容中可能使用到如下两种通配符：

- `'.'` 匹配任意单个字符。
- `'*'` 匹配零个或多个前面的那一个元素。

 请返回用户输入内容 `input` 所有字符是否可以匹配原文字符串 `article`。

> 普通字符匹配、.匹配、*匹配两种情况0个或多个

```js
var articleMatch = function(s, p) {
    // 边界条件，考虑原文字符串 s 或输入内容 p 分别为空的情况
    if (!p) return !s; // 如果输入内容 p 为空，只有在原文字符串 s 也为空时才匹配
    if (!s && p.length === 1) return false; // 如果原文字符串 s 为空且输入内容 p 长度为 1，则不能匹配

    const m = s.length, n = p.length;
    // 创建一个 (m+1)x(n+1) 的二维数组 dp，初始化为 false
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(false));
    // const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));
    dp[0][0] = true; // 空字符串与空输入内容匹配

    // 初始化 dp 数组，匹配空的原文字符串
    for (let c = 2; c <= n; c++) {
        if (p[c - 1] === '*') {
            dp[0][c] = dp[0][c - 2]; // '*' 可以匹配前面的字符 0 次
        }
    }

    // 填充 dp 表格
    for (let r = 1; r <= m; r++) {
        for (let c = 1; c <= n; c++) {
            // 当前原文字符和输入内容相同或输入内容字符是 '.（可以匹配任何字符）'，那么当前的字符匹配取决于前面的字符是否匹配，因此，dp[r][c] 可以继承 dp[r-1][c-1] 的值。
            if (s[r - 1] === p[c - 1] || p[c - 1] === '.') {
                dp[r][c] = dp[r - 1][c - 1];
            } else if (p[c - 1] === '*') { // 如果当前输入内容字符是 '*'
                if (p[c - 2] === s[r - 1] || p[c - 2] === '.') {
                    // 如果前一个字符能匹配当前字符或者前一个字符是'.'，'*' 作为多个字符使用
                    dp[r][c] = dp[r - 1][c] || dp[r][c - 2];
                } else {
                    // 如果前一个字符不能匹配当前字符,'*' 作为 0 个字符使用
                    dp[r][c] = dp[r][c - 2];
                }
            } else {
                dp[r][c] = false; // 当前字符不匹配
            }
        }
    }
    return dp[m][n]; // 返回整个原文字符串和输入内容是否匹配的结果
};
```

### （4）剑指offer42.连续子数组的最大和

[LCR 161. 连续天数的最高销售额](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

某公司每日销售额记于整数数组 `sales`，请返回所有 **连续** 一或多天销售额总和的最大值。

要求实现时间复杂度为 `O(n)` 的算法。

> 遍历数组，在每个位置上更新当前子数组的最大和。

```js
var maxSales = function(nums) {
    for (let i = 1; i < nums.length; i++) {
        nums[i] += Math.max(nums[i - 1], 0);
    }
    return Math.max(...nums);
};
```

### （5）剑指offer46.把数字翻译成字符串

[LCR 165. 解密数字](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

现有一串神秘的密文 `ciphertext`，经调查，密文的特点和规则如下：

- 密文由非负整数组成
- 数字 0-25 分别对应字母 a-z

请根据上述规则将密文 `ciphertext` 解密为字母，并返回共有多少种解密结果。

> 动态规划：爬楼梯的升级版，满足条件才能爬两格。即两个数字凑起来大于等于10且小于26。
>

```js
var crackNumber = function(num) {
    // 初始化翻译方法的前一个和当前的数量为1
    let pre = 1,
        cur = 1,
        str = String(num); // 将数字转换为字符串
    const len = str.length;
    // 遍历数字的每一位
    for (let i = 0; i < len; i++) {
        // 判断当前位和下一位数字组合是否在10到25之间 当前位是 "1" 或者当前位是 "2" 并且下一位小于 "6"
        const satisfy = i + 1 < len && (str.charAt(i) === "1" || (str.charAt(i) === "2" && str.charAt(i + 1) < "6"));
        // 更新翻译方法的数量
        // 将 cur 的值赋给 pre，将条件表达式 satisfy ? pre + cur : cur 的结果赋给 cur
        [pre, cur] = [cur, satisfy ? pre + cur : cur];
    }
    // 返回最终的翻译方法数量
    return cur;
};
```

### （6）剑指offer47.礼物的最大值

现有一个记作二维矩阵 `frame` 的珠宝架，其中 `frame[i][j]` 为该位置珠宝的价值。拿取珠宝的规则为：

- 只能从架子的左上角开始拿珠宝
- 每次可以移动到右侧或下侧的相邻位置
- 到达珠宝架子的右下角时，停止拿取

注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 `frame = [[0]]`。

```js
var jewelleryValue = function(frame) {
    // 获取矩阵的行数和列数
    const col = frame[0].length, row = frame.length;
    // new Array(row + 1).fill(0) 创建一个长度为 row + 1 的数组，每个元素都是 undefined。
    // map(() => new Array(col + 1).fill(0)) 为数组的每个元素（每一行）创建一个长度为 col + 1 的数组，并用 0 初始化。
	const arr = new Array(row + 1).fill(0).map(() => new Array(col + 1).fill(0));

    // 从 1 开始遍历每一行和每一列
    for (let i = 1; i <= row; i++) {
        for (let j = 1; j <= col; j++) {
            // 计算当前格子 (i, j) 的最大价值
            // 通过取上方 (i-1, j) 或左方 (i, j-1) 的最大值加上当前格子的价值 frame[i-1][j-1]
            arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]) + frame[i - 1][j - 1];
        }
    }

    // 返回右下角位置的最大价值，即 arr[row][col]
    return arr[row][col];
};
```

### 【】（7）剑指offer60.n个骰子的点数

[LCR 185. 统计结果概率](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/)

你选择掷出 `num` 个色子，请返回所有点数总和的概率。你需要用一个浮点数数组返回答案，其中第 `i` 个元素代表这 `num` 个骰子所能掷出的点数集合中第 `i` 小的那个的概率。

```js
var statisticsProbability = function(n) {
    // 初始化dp数组，表示一个骰子的情况，每个点数出现的概率都是1/6
    let dp = new Array(6).fill(1 / 6);

    // 从第二个骰子开始进行计算，直到第n个骰子
    for (let i = 2; i <= n; i++) {
        // 临时数组tmp，用来存储当前骰子的点数出现的概率
        const tmp = new Array(5 * i + 1).fill(0);
        // 遍历上一个骰子的所有概率
        for (let j = 0; j < dp.length; j++) {
            // 遍历当前骰子的所有点数（1到6）
            for (let k = 0; k < 6; k++) {
                // 更新临时数组的概率(将前一个骰子的概率分布加上当前骰子的点数)
                tmp[j + k] += dp[j] / 6;
            }
        }
        // 将临时数组赋值给dp，进行下一轮计算
        dp = tmp;
    }

    // 返回结果，即n个骰子时每个点数的概率
    return dp;
};
```

### （8）剑指offer62.圆圈中最后剩下的数字

[LCR 187. 破冰游戏](https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

社团共有 `num` 位成员参与破冰游戏，编号为 `0 ~ num-1`。成员们按照编号顺序围绕圆桌而坐。社长抽取一个数字 `target`，从 0 号成员起开始计数，排在第 `target` 位的成员离开圆桌，且成员离开后从下一个成员开始计数。请返回游戏结束时最后一位成员的编号。

> 解法：约瑟夫环问题，f(n,m)=[f(n-1,m)+m]%n。

```js
var iceBreakingGame = function(num, target) {
    let res = 0 // 最后位置
    for(let i = 2; i <= num; i++){ // 当只有1个人时唯一的幸存者显然是位置0，所以从2开始
        res = (res + target) % i // 将之前的幸存者位置res向右移动target个位置，再取模当前人数 i
    }
    return res
};
```

## 08、图

### 【】（1）剑指offer12.矩阵中的路径

> 解法：DFS+剪枝。采用的是深度优先方式进行搜索（深度优先搜索--DFS可以理解为暴力法遍历矩阵中所有字符串的可能性，通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推），并且用剪枝方式（遇到这条路不可能和目标字符串匹配成功的情况，则应立即返回）避免无效搜索来避免超时。递归过程：标记当前矩阵元素，搜索下一个单元格，还原当前矩阵元素。

[LCR 129. 字母迷宫](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)

字母迷宫游戏初始界面记作 `m x n` 二维字符串数组 `grid`，请判断玩家是否能在 `grid` 中找到目标单词 `target`。
注意：寻找单词时 **必须** 按照字母顺序，通过水平或垂直方向相邻的单元格内的字母构成，同时，同一个单元格内的字母 **不允许被重复使用** 。

```js
var wordPuzzle = function(grid, target) {
	if (!grid || !grid.length || !target || target.length === 0) {  
        return false;  
    }  
  
    const rows = grid.length;  
    const cols = grid[0].length;  
  
    // 定义一个辅助函数，用于递归搜索目标单词  
    function dfs(row, col, targetIndex) {  
        // 如果已经找到了整个单词  
        if (targetIndex === target.length) {  
            return true;  
        }  
  
        // 边界检查  
        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] !== target[targetIndex]) {  
            return false;  
        }  
  
        // 标记当前字符为已访问（在JavaScript中通过修改原数组实现）  
        const temp = grid[row][col];  
        grid[row][col] = '';  
  
        // 尝试四个方向（上、下、左、右）  
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];  
        for (const [dx, dy] of directions) {  
            const newRow = row + dx;  
            const newCol = col + dy;  
            if (dfs(newRow, newCol, targetIndex + 1)) {  
                return true;  
            }  
        }  
  
        // 回溯，恢复当前字符  
        grid[row][col] = temp;  
        return false;  
    }  
  
    // 遍历整个网格，从每个字符开始搜索  
    for (let i = 0; i < rows; i++) {  
        for (let j = 0; j < cols; j++) {  
            if (grid[i][j] === target[0] && dfs(i, j, 0)) {  
                return true;  
            }  
        }  
    }  
  
    return false;  
};
```

### 【】（2）剑指offer13.机器人的运动范围

[LCR 130. 衣橱整理](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

家居整理师将待整理衣橱划分为 `m x n` 的二维矩阵 `grid`，其中 `grid[i][j]` 代表一个需要整理的格子。整理师自 `grid[0][0]` 开始 **逐行逐列** 地整理每个格子。

整理规则为：在整理过程中，可以选择 **向右移动一格** 或 **向下移动一格**，但不能移动到衣柜之外。同时，不需要整理 `digit(i) + digit(j) > cnt` 的格子，其中 `digit(x)` 表示数字 `x` 的各数位之和。

请返回整理师 **总共需要整理多少个格子**。

> 解法：DFS。通过分析机器人只能从右或下两个方向进行行走才能到达满足条件的格子（可达解）。

```js
var wardrobeFinishing = function(m, n, cnt) {
  // 定义一个函数来计算一个数的各个位数的和  
  function sumOfDigits(num) {  
    let result = 0;  
    while (num > 0) {  
      result += num % 10;  
      num = Math.floor(num / 10);  
    }  
    return result;  
  }  
  
  // 定义一个函数来执行深度优先搜索  
  function dfs(i, j, visited) {  
    // 如果越界或者位数和大于cnt，或者已经被访问过，则返回  
    if (i >= m || j >= n || sumOfDigits(i) + sumOfDigits(j) > cnt || visited[i][j]) {  
      return;  
    }  
  
    // 标记当前位置为已访问  
    visited[i][j] = true;  
  
    // 递归地向右和向下搜索  
    dfs(i + 1, j, visited);  
    dfs(i, j + 1, visited);  
  }  
  
  // 创建一个二维数组来记录哪些位置被访问过  
  let visited = new Array(m);  
  for (let i = 0; i < m; i++) {  
    visited[i] = new Array(n).fill(false);  
  }  
  
  // 从(0, 0)开始搜索  
  dfs(0, 0, visited);  
  
  // 统计被访问过的位置数量  
  let count = 0;  
  for (let i = 0; i < m; i++) {  
    for (let j = 0; j < n; j++) {  
      if (visited[i][j]) {  
        count++;  
      }  
    }  
  }  
  
  return count; 
};
```

### （3）剑指offer29.顺时针打印矩阵

[LCR 146. 螺旋遍历二维数组](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

给定一个二维数组 `array`，请返回「**螺旋遍历**」该数组的结果。

**螺旋遍历**：从左上角开始，按照 **向右**、**向下**、**向左**、**向上** 的顺序 **依次** 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。

> 解法：将矩阵的上t、下b、左l、右r四个边界用于打印的res列表，然后进行从左向右、从上到下、从右到左和从下到上的顺序进行循环（根据边界将元素按顺序添加到res列表的尾部，边界向内收缩1，判断边界是否相遇）。

```js
var spiralArray = function(matrix) {
    if (matrix.length == 0) return [];
    let m = matrix.length, n = matrix[0].length;
    let top = 0, bottom = m - 1, left = 0, right = n - 1;
    const res = [];
    while(res.length < m * n) {
        // 如果上边界小于等于下边界，从左到右遍历当前上边界所在的行
        if(top <= bottom) {
            for(let i = left; i <= right; i++) {
                res.push(matrix[top][i])
            }
            // 上边界下移，表示已经遍历完当前行的所有元素
            top++;
        }
        if(left <= right) {
            for(let i = top; i <= bottom; i++) {
                res.push(matrix[i][right])
            }
            // 右边界左移
            right--;
        }
        if(top <= bottom) {
            for(let i = right; i >= left; i--) {
                res.push(matrix[bottom][i])
            }
            // 下边界上移
            bottom--;
        }
        if(left <= right) {
            for(let i = bottom; i >= top; i--) {
                res.push(matrix[i][left])
            }
            // 上边界下移
            left++;
        } 
    }
    return res;
};
```

## 09、贪心算法

### 剑指offer63.股票中的最大利润

[LCR 188. 买卖芯片的最佳时机](https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/)

数组 `prices` 记录了某芯片近期的交易价格，其中 `prices[i]` 表示的 `i` 天该芯片的价格。你只能选择 **某一天** 买入芯片，并选择在 **未来的某一个不同的日子** 卖出该芯片。请设计一个算法计算并返回你从这笔交易中能获取的最大利润。

如果你不能获取任何利润，返回 0。

> 解法：贪心算法，因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。

```js
var bestTiming = function(prices) {
  let min = Infinity;
  let max = 0;
  
  // 遍历每一天的价格
  for (let i = 0; i < prices.length; i++) {
    // 计算当前价格减去最低价格的利润，并更新最大利润
    max = Math.max(prices[i] - min, max);
    // 更新最低价格为当前价格和已知最低价格中的较小值
    min = Math.min(prices[i], min);
  }
  
  // 返回最大利润
  return max;
};
```

> 动态规划

```js
var bestTiming = function(prices) {
    const len = prices.length;
    if (len === 0) return 0;
    const dp = new Array(len);
    dp[0] = [0, -prices[0]]; // dp[0][0]: 不持有股票的利润, dp[0][1]: 持有股票的利润
    
    // 遍历每一天的价格
    for(let i = 1; i < len; i++) {
        dp[i] = []; // 初始化当天的状态
        // 计算当天不持有股票的最大利润
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        // 计算当天持有股票的最大利润
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    
    // 返回最后一天不持有股票的最大利润
    return dp[len-1][0];
};
```

## 10、找规律

### （1）剑指offer43.1~n整数中1出现的次数

[LCR 162. 数字 1 的个数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

给定一个整数 `num`，计算所有小于等于 `num` 的非负整数中数字 `1` 出现的个数。

> 解法：通过枚举找规律。

```js
var digitOneInNumber = function(n) {
    let count = 0; // 初始化计数器，存储1出现的次数

    // 从个位开始，逐步处理个位、十位、百位等
    for (let i = 1; i <= n; i *= 10) {
        let divide = i * 10; // 当前位数范围的基数
        let p = Math.floor(n / divide); // 当前位数以上的部分
        let k = n % divide; // 当前位数及以下的部分

        // 计算当前位数上的数字1出现的次数
        count += p * i;

        // 根据当前位数以下的部分k来决定rest的值
        if (k >= 2 * i) { // 如果当前位数及以下的部分足够大
            count += i; // 当前位上会完整地出现i个1
        } else if (k >= i) { // 如果当前位数及以下的部分在合适的范围内
            count += k - i + 1; // 当前位上会出现部分1
        }
    }

    return count; // 返回1出现的总次数
};
```

### （2）剑指offer44.数字序列中某一位的数字

[LCR 163. 找到第 k 位数字](https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

某班级学号记录系统发生错乱，原整数学号序列 `[0,1,2,3,4,...]` 分隔符丢失后变为 `01234...` 的字符序列。请实现一个函数返回该字符序列中的第 `k` 位数字。

> 解法：找规律。

```js
var findKthNumber = function(k) {
 let i = 1; // 初始化位数，从1位开始

    // 循环判断k是否超过当前位数范围的数字总个数
    // 9 * Math.pow(10, i - 1) * i 表示i位数的总个数乘以每个数字的位数
    while (k > 9 * Math.pow(10, i - 1) * i) {
        k -= 9 * Math.pow(10, i - 1) * i; // 减去当前位数范围的数字总个数
        i += 1; // 处理下一个位数
    }

    // 找到k所在的具体数字
    // Math.pow(10, i - 1) 是当前位数的第一个数字
    // Math.floor((k - 1) / i) 是找到具体的数字位置
    let num = Math.pow(10, i - 1) + Math.floor((k - 1) / i);

    // 转换为字符串
    let numStr = num.toString();

    // 找到字符串中第 (k - 1) % i 位的字符，并返回对应的数字
    return parseInt(numStr[(k - 1) % i]);
};
```

